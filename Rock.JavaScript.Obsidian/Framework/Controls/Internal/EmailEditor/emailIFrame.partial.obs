<!-- Copyright by the Spark Development Network; Licensed under the Rock Community License -->
<template>
    <iframe v-if="!isResetting"
            id="email-iframe-wrapper"
            ref="iFrameElement"
            frameborder="0"
            border="0"
            :srcdoc="internalSrcDoc"></iframe>
</template>

<style scoped>
iframe {
    position: absolute;
    border: 0;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    width: 100%;
    height: 100%;
}
</style>

<script setup lang="ts">
    import { nextTick, onBeforeUnmount, PropType, ref, watch } from "vue";
    import {
        createGlobalBodyWidthProvider,
        createGlobalBodyAlignmentProvider,
        createGlobalBodyBackgroundColorProvider,
        createGlobalBackgroundColorProvider,
        createGlobalButtonWidthValuesProvider,
        createMediaQueryEffect,
        createGlobalButtonBackgroundColorProvider,
        createGlobalDividerWidthProvider,
        createGlobalDividerHorizontalAlignmentProvider
    } from "./providers.partial";
    import {
        copyShorthandInlineStyles,
        createComponentElement,
        createComponentElementPlaceholder,
        getComponentHelper,
        moveShorthandInlineStyles,
        moveStandaloneInlineStyles,
        removeTemporaryAttributes,
        removeTemporaryClasses,
        removeTemporaryElements,
        removeTemporaryWrappers,
        RockCssClassContentEditable,
        RockRuntimeElementCssClass,
        RockRuntimeWrapperElementCssClass,
        EmptyDropzoneSvgPixelWidth,
        SmallEmptyClass,
        checkDropzoneSize,
        RockStylesCssClass,
        RockRuntimeClassCssClassPrefix,
        ensureBodyWrapsEmailWrapper,
        GlobalStylesCssSelectors,
        getComponentTypeName,
        getComponentHostSelector,
        pixelConverter
    } from "./utils.partial";
    import {
        CssStyleDeclarationKebabKey,
        ComponentTypeDragDropMessage,
        ComponentTypeDragEndMessage,
        ComponentTypeDragLeaveMessage,
        ComponentTypeDragOverMessage,
        ComponentTypeDragStartMessage,
        EditorComponentTypeName,
        CloneComponentRequest,
        CompleteComponentRequest,
        ComponentTypeDragEndRequest,
        ComponentTypeDragStartRequest,
        DeleteComponentRequest,
        ComponentTypeDragOverRequest,
        ComponentTypeDragDropRequest,
        ComponentTypeDragLeaveRequest,
        ValueProvider,
        ButtonWidthValues,
        ReplaceComponentRequest,
        HorizontalAlignment
    } from "./types.partial";
    import { GetHtmlRequest } from "./types";
    import { useVModelPassthrough } from "@Obsidian/Utility/component";
    import {
        findDirectChildContaining,
        findNearestIFrameElementFromPoint,
        isDocument,
        isElement,
        isHTMLElement,
        removeWhiteSpaceFromChildElements,
        removeWhiteSpaceFromElement,
        removeWhiteSpaceFromElementAndChildElements
    } from "@Obsidian/Utility/dom";
    import { Enumerable } from "@Obsidian/Utility/linq";

    const props = defineProps({
        /** This is reactive. If it is changed, the inner HTML for the editor will be updated. */
        html: {
            type: String as PropType<string>,
            required: true
        },

        selectedComponentElement: {
            type: Object as PropType<HTMLElement | null | undefined>,
            required: true
        },

        cssVariables: {
            type: Object as PropType<Record<string, string>>,
            required: true
        },

        cloneComponentRequest: {
            type: Object as PropType<CloneComponentRequest | null | undefined>,
            required: true
        },

        replaceComponentRequest: {
            type: Object as PropType<ReplaceComponentRequest | null | undefined>,
            required: true
        },

        completeComponentRequest: {
            type: Object as PropType<CompleteComponentRequest | null | undefined>,
            required: true
        },

        deleteComponentRequest: {
            type: Object as PropType<DeleteComponentRequest | null | undefined>,
            required: true
        },

        componentTypeDragStartRequest: {
            type: Object as PropType<ComponentTypeDragStartRequest | null | undefined>,
            required: true
        },

        componentTypeDragOverRequest: {
            type: Object as PropType<ComponentTypeDragOverRequest | null | undefined>,
            required: true
        },

        componentTypeDragDropRequest: {
            type: Object as PropType<ComponentTypeDragDropRequest | null | undefined>,
            required: true
        },

        componentTypeDragLeaveRequest: {
            type: Object as PropType<ComponentTypeDragLeaveRequest | null | undefined>,
            required: true
        },

        componentTypeDragEndRequest: {
            type: Object as PropType<ComponentTypeDragEndRequest | null | undefined>,
            required: true
        },

        getHtmlRequest: {
            type: Object as PropType<GetHtmlRequest | null | undefined>,
            required: true
        }
    });

    const emit = defineEmits<{
        (e: "update:selectedComponentElement", value: HTMLElement | null | undefined): void;
        (e: "emailDocumentUpdated", value: Document): void;
    }>();

    const draggingCssClass = `${RockRuntimeClassCssClassPrefix}-is-dragging` as const;
    const nonRowHoveredClass = `${RockRuntimeClassCssClassPrefix}-non-row-hovered` as const;

    // #region Values

    const isResetting = ref<boolean>(false);
    const internalSrcDoc = ref<string>(props.html);
    const iFrameElement = ref<HTMLIFrameElement | undefined>();
    const draggingComponentTypeName = ref<EditorComponentTypeName | null | undefined>();
    const draggingElement = ref<HTMLElement | null | undefined>();
    const draggingPlaceholderElement = ref<HTMLElement | null | undefined>();
    const dragCursorX = ref<number | null | undefined>();
    const dragCursorY = ref<number | null | undefined>();
    const internalSelectedComponentElement = useVModelPassthrough(props, "selectedComponentElement", emit);
    const emptySectionElementToBeAddedTo = ref<HTMLElement | null | undefined>();
    const wrapperAutoRemovalObserver = ref<MutationObserver | null | undefined>();
    const sectionComponentMutationObserver = ref<MutationObserver | null | undefined>();
    const dropzoneEmptyResizeObserver = ref<ResizeObserver | null | undefined>();

    // Global default providers and effects.
    const globalBodyWidthProvider = ref<ValueProvider<number | null | undefined> | undefined>();
    const globalBodyAlignmentProvider = ref<ValueProvider<string | null | undefined> | undefined>();
    const globalBodyColorProvider = ref<ValueProvider<string | null | undefined> | undefined>();
    const globalBackgroundColorProvider = ref<ValueProvider<string | null | undefined> | undefined>();
    const globalButtonWidthValuesProvider = ref<ValueProvider<ButtonWidthValues | null | undefined> | undefined>();
    const globalBodyWidthMediaQueryEffect = ref<Disposable | undefined>();
    const globalButtonBackgroundColorProvider = ref<ValueProvider<string | null | undefined> | undefined>();
    const globalDividerWidthProvider = ref<ValueProvider<number | null | undefined> | undefined>();
    const globalDividerHorizontalAlignmentProvider = ref<ValueProvider<HorizontalAlignment | null | undefined> | undefined>();

    // #endregion

    // #region Computed Values

    const emailDocument = ref<Document | null | undefined>(iFrameElement.value?.contentDocument as Document);

    // #endregion

    // #region Functions

    /**
     * Adds event handlers to the iframe.
     */
    function addEventHandlers(iFrameElement: HTMLIFrameElement): void {
        iFrameElement.addEventListener("load", async () => {
            const iFrameWindow = iFrameElement.contentWindow!;

            // Window Events
            // Add the handler that processes interwindow communication.
            iFrameWindow.removeEventListener("message", onIFrameMessageReceived);
            iFrameWindow.addEventListener("message", onIFrameMessageReceived);

            // Document Events
            // Add handler for dealing with dragging components within the editor.
            iFrameWindow.document.removeEventListener("mousedown", onIFrameComponentMouseDown);
            iFrameWindow.document.addEventListener("mousedown", onIFrameComponentMouseDown);

            // Add handler that selects components within the editor.
            iFrameWindow.document.removeEventListener("click", onIFrameClick);
            iFrameWindow.document.addEventListener("click", onIFrameClick);

            // Add handler for delete and escape keys being pressed.
            iFrameWindow.document.removeEventListener("keydown", onIFrameKeyDownDelete);
            iFrameWindow.document.addEventListener("keydown", onIFrameKeyDownDelete);
            iFrameWindow.document.removeEventListener("keydown", onIFrameKeyDownEscape);
            iFrameWindow.document.addEventListener("keydown", onIFrameKeyDownEscape);

            await onIFrameLoaded();
        });
    }

    /**
     * Removes event handlers from the iframe.
     */
    function removeEventHandlers(iFrameElement: HTMLIFrameElement): void {
        const iFrameWindow = iFrameElement.contentWindow;

        if (iFrameWindow) {
            iFrameWindow.removeEventListener("load", onIFrameLoaded);
            iFrameWindow.removeEventListener("message", onIFrameMessageReceived);
            iFrameWindow.document.removeEventListener("mousedown", onIFrameComponentMouseDown);
            iFrameWindow.document.removeEventListener("click", onIFrameClick);
            iFrameWindow.document.removeEventListener("keydown", onIFrameKeyDownEscape);
            iFrameWindow.document.removeEventListener("keydown", onIFrameKeyDownDelete);
        }
    }

    /**
     * Sends a message to the iframe.
     *
     * This is used for forwarding events to the iframe
     * so they can be handled in the iframe's context.
     */
    function sendMessageToIFrame(message:
        ComponentTypeDragStartMessage
        | ComponentTypeDragDropMessage
        | ComponentTypeDragOverMessage
        | ComponentTypeDragLeaveMessage
        | ComponentTypeDragEndMessage): void {
        if (!iFrameElement.value?.contentWindow) {
            throw new Error("Unable to post message. The iframe is not initialized.");
        }

        // FYI, if the message is an object, it cannot contain methods.
        // When postMessage is called, the message is serialized.
        // When the iframe handles the message event, the message is deserialized.
        // The message references will not be the same!
        iFrameElement.value.contentWindow.postMessage(message, "/");
    }

    /**
     * Gets a component's descendant elements that are allowed to be edited in-line.
     *
     * This does not mean that inline editing is enabled yet on those elements, but that it *can be* enabled.
     */
    function getInlineEditableElements(componentElement: HTMLElement): Enumerable<HTMLElement> {
        const generator = function* (): Generator<HTMLElement, void, unknown> {
            if (componentElement.classList.contains(RockCssClassContentEditable)) {
                yield componentElement;
            }

            for (const element of componentElement.querySelectorAll(`.${RockCssClassContentEditable}`)) {
                if (isHTMLElement(element)) {
                    yield element;
                }
            }
        };
        return Enumerable.from(generator);
    }

    /**
     * Selects a component.
     *
     * This should handle all things about selecting a component.
     */
    function selectComponent(componentElement: HTMLElement): void {
        // IMPORTANT! This needs to be able to be called multiple times.
        // The first selection will highlight the component and show its properties.
        // Subsequent selections will enable inline editing.
        if (internalSelectedComponentElement.value === componentElement) {
            // The component is already selected. Make editable regions editable.
            getInlineEditableElements(componentElement)
                .forEach(element => {
                    // Ensure inline editing is enabled on a proper element.
                    const editableElement = getOrCreateEditableWrapper(element);

                    // Enable content editing.
                    editableElement.setAttribute("contenteditable", "true");

                    // Cleanup when editing stops.
                    editableElement.addEventListener("blur", () => {
                        editableElement.removeAttribute("contenteditable");
                        unwrapEditableElement(editableElement);
                    }, { once: true });
                });
            return;
        }
        else {
            internalSelectedComponentElement.value = componentElement;
        }
    }

    /**
     * Deselects a component.
     *
     * This should handle all things about deselecting a component.
     */
    function deselectComponentElement(componentElement: HTMLElement): void {
        componentElement.classList.remove("selected");

        // Removed the selected class from the wrapper too, if needed.
        if (componentElement.parentElement?.classList.contains("component-side-menu-wrapper")) {
            componentElement.parentElement.classList.remove("selected");
        }

        // Disable in-line editing for in-line editable elements.
        getInlineEditableElements(componentElement)
            .forEach(element => {
                const editableElement = getOrCreateEditableWrapper(element);
                element.removeAttribute("contenteditable");
                unwrapEditableElement(editableElement);
            });

        // Remove selected ranges for elements that were being edited inline.
        const { selection, ranges } = getRangesWithinElement(componentElement);
        if (selection && ranges.length) {
            ranges.forEach(range => {
                selection.removeRange(range);
            });
        }
    }

    /**
     * Ensures the element is editable by wrapping it in a <div> if necessary.
     */
    function getOrCreateEditableWrapper(element: HTMLElement): HTMLElement {
        // If the element is already a proper editable container, return it.
        if (element.tagName !== "TD") {
            return element;
        }

        // Check if there's already a wrapper div inside the <td>
        const existingWrapper = element.querySelector(".rock-content-editable-wrapper");
        if (existingWrapper && isHTMLElement(existingWrapper)) {
            return existingWrapper;
        }

        // Create a new wrapper div
        const wrapper = document.createElement("div");
        wrapper.className = "rock-content-editable-wrapper";
        wrapper.contentEditable = "true";

        // Move child elements into the new wrapper
        while (element.firstChild) {
            wrapper.appendChild(element.firstChild);
        }

        // Insert wrapper into the <td>
        element.appendChild(wrapper);

        return wrapper;
    }

    /**
    * Removes the temporary wrapper div and restores the original structure.
    */
    function unwrapEditableElement(wrapper: HTMLElement): void {
        if (!wrapper.classList.contains("rock-content-editable-wrapper")) {
            return;
        }

        const parent = wrapper.parentElement;
        if (!parent) {
            return;
        }

        // Move all children out of the wrapper and place them back in the parent
        while (wrapper.firstChild) {
            parent.insertBefore(wrapper.firstChild, wrapper);
        }

        // Remove the now-empty wrapper
        try {
            wrapper.remove();
        }
        catch {
            // Ignore errors if wrapper is already removed.
        }
    }

    function getRangesWithinElement(element: HTMLElement): { selection: Selection | null | undefined, ranges: Range[] } {
        const selection = element.ownerDocument.defaultView?.getSelection();
        const ranges: Range[] = [];
        if (selection) {
            if ((selection.rangeCount ?? 0) > 0) {
                for (let i = 0; i < selection.rangeCount; i++) {
                    const range = selection.getRangeAt(i);

                    // Check if the range is within or intersects with the element
                    if (element.contains(range.startContainer) || element.contains(range.endContainer)) {
                        ranges.push(range);
                    }
                }
            }
        }

        return { selection, ranges };
    }

    function cloneSelectedComponent(): void {
        if (internalSelectedComponentElement.value) {
            let clonableElement: HTMLElement | null = null;

            if (internalSelectedComponentElement.value.parentElement?.classList.contains(RockRuntimeWrapperElementCssClass)) {
                clonableElement = internalSelectedComponentElement.value.parentElement;
            }
            else {
                clonableElement = internalSelectedComponentElement.value;
            }

            // Clone element.
            const clone = clonableElement.cloneNode(true) as HTMLElement;

            // Add the clone after the current component.
            const isRootDropzone = internalSelectedComponentElement.value.matches(".component-section") &&
                !internalSelectedComponentElement.value.closest(".dropzone");

            if (isRootDropzone) {
                const ancestorStructureDropzone = clonableElement.parentElement?.closest(".structure-dropzone");

                if (isHTMLElement(ancestorStructureDropzone)) {
                    const ancestorStructureDropzoneChild = findDirectChildContaining(ancestorStructureDropzone, clonableElement);

                    if (isHTMLElement(ancestorStructureDropzoneChild)) {
                        ancestorStructureDropzone.insertBefore(clone, ancestorStructureDropzoneChild.nextElementSibling);
                    }
                    else {
                        // Do not clone, otherwise the section component will be placed outside of a structure dropzone.
                        console.error("Unable to clone section. The section and is no longer a descendant of a structure dropzone.");
                    }
                }
                else {
                    // Do not clone, otherwise the section component will be placed outside of a structure dropzone.
                    console.error("Unable to clone section. There is no structure dropzone to place it in.");
                }
            }
            else {
                clonableElement.parentElement?.insertBefore(clone, clonableElement.nextSibling);
            }

            // Select the new component.
            internalSelectedComponentElement.value = clone.classList.contains("component") ? clone : clone.querySelector(".component") as HTMLElement;
        }
    }

    function replaceSelectedComponent(newComponentElement: HTMLElement): void {
        if (internalSelectedComponentElement.value) {
            let replaceableElement: HTMLElement | null = internalSelectedComponentElement.value;

            // If the selected component is wrapped in a Rock runtime wrapper, replace the wrapper instead.
            if (replaceableElement.parentElement?.classList.contains(RockRuntimeWrapperElementCssClass)) {
                replaceableElement = replaceableElement.parentElement;
            }

            if (!replaceableElement.parentElement) {
                console.error("replaceSelectedComponent: Cannot replace the component, no valid parent found.");
                return;
            }

            const wrappedComponentElement = wrapComponentElement(replaceableElement.ownerDocument, newComponentElement);

            // Replace the old component with the new one in the DOM.
            replaceableElement.parentElement.replaceChild(wrappedComponentElement, replaceableElement);

            // Update selection to the new component.
            internalSelectedComponentElement.value = newComponentElement;
        }
    }

    function deleteSelectedComponent(): void {
        if (internalSelectedComponentElement.value) {
            let parentElement: HTMLElement | null = null;

            if (internalSelectedComponentElement.value.parentElement?.classList.contains(RockRuntimeWrapperElementCssClass)) {
                parentElement = internalSelectedComponentElement.value.parentElement.parentElement;
                internalSelectedComponentElement.value.parentElement.remove();
            }
            else {
                parentElement = internalSelectedComponentElement.value.parentElement;
                internalSelectedComponentElement.value.remove();
            }

            if (parentElement?.children.length === 0 && [...parentElement.childNodes].every(n => !n.nodeValue?.trim())) {
                // Clear all inner HTML if there are no children nor non-empty text elements.
                parentElement.innerHTML = "";
            }

            internalSelectedComponentElement.value = null;
        }
    }

    /**
     * Gets the processed HTML for this email iframe.
     */
    function getHtml(options: GetHtmlRequest): void {
        try {
            const clone = document.createElement("iframe");

            // Hide the clone.
            clone.style.display = "none";

            // Append the cloned iframe to the body to get access to the clone's contentDocument.
            document.body.appendChild(clone);

            const cloneDocument = clone.contentDocument ?? clone.contentWindow?.document;

            if (cloneDocument) {
                cloneDocument.open();
                cloneDocument.writeln(iFrameElement.value?.contentWindow?.document.documentElement.outerHTML ?? "");
                cloneDocument.close();

                removeTemporaryElements(cloneDocument);
                removeTemporaryAttributes(cloneDocument);
                removeTemporaryWrappers(cloneDocument);
                removeTemporaryClasses(cloneDocument);

                const html = cloneDocument.documentElement.outerHTML ?? "";

                // Remove the cloned iframe element before returning the HTML.
                clone.remove();

                options.onSuccess({
                    html,
                    bodyWidth: globalBodyWidthProvider.value?.value
                });
            }
            else {
                throw new Error("An error occurred while preparing HTML.");
            }
        }
        catch (e) {
            if (options.onError) {
                options.onError(e?.["message"] ?? "An unknown error occurred while preparing HTML.");
            }
            else {
                throw e;
            }
        }
    }

    function isComponentElement(element: HTMLElement): element is HTMLElement {
        return element.classList.contains("component") && element.dataset.state === "component";
    }

    function wrapComponentElements(element: Document | Element): void {
        const document = isDocument(element) ? element : element.ownerDocument;
        element.querySelectorAll(`.component[data-state="component"]`)
            .forEach(componentElement => {
                if (isHTMLElement(componentElement)) {
                    wrapComponentElement(document, componentElement);
                }
            });
    }

    /**
     * Adds a wrapper to a component element.
     */
    function wrapComponentElement(document: Document, componentElement: HTMLElement): HTMLElement {
        // Do not wrap if the element is not a component element.
        if (!isComponentElement(componentElement)) {
            return componentElement;
        }

        // Do not wrap if a wrapper already exists.
        if (componentElement.parentElement?.classList.contains("component-side-menu-wrapper")) {
            return componentElement;
        }

        const componentTypeNameCssClass = [...componentElement.classList].find(cssClass => cssClass.startsWith("component-"));

        // Create the wrapper element.
        const wrapper = document.createElement("div");
        wrapper.classList.add(RockRuntimeWrapperElementCssClass, "component-side-menu-wrapper");
        if (componentTypeNameCssClass) {
            wrapper.classList.add(`for-${componentTypeNameCssClass}`);
        }

        // Insert wrapper before the component and move the component inside it.
        componentElement.parentNode?.insertBefore(wrapper, componentElement);
        wrapper.appendChild(componentElement);

        // Add hover effect that prevents the row from being highlighted
        // if a subcomponent is being hovered over.
        if (getComponentTypeName(componentElement) !== "row") {
            wrapper.addEventListener("mouseenter", () => {
                document.body.classList.add(nonRowHoveredClass);
            });
            wrapper.addEventListener("mouseleave", () => {
                document.body.classList.remove(nonRowHoveredClass);
            });
        }
        else {
            wrapper.addEventListener("mouseenter", (e) => {
                // Check if a non-row is currently hovered. The other events may not have triggered,
                // so check again here.
                if (Enumerable.from(document.elementsFromPoint(e.clientX, e.clientY))
                    .where(e => e.classList.contains("component") && getComponentTypeName(e) !== "row")
                    .any()
                ) {
                    document.body.classList.add(nonRowHoveredClass);
                }
                else {
                    document.body.classList.remove(nonRowHoveredClass);
                }
            });
            wrapper.addEventListener("mouseleave", () => {
                document.body.classList.remove(nonRowHoveredClass);
            });
        }

        // Automatically remove the wrapper if all of its children elements are removed.
        wrapperAutoRemovalObserver.value?.observe(wrapper, { childList: true });

        // Add a resize observer if a section component.
        if (componentElement.classList.contains("component-section")) {
            watchSectionComponentSizeChanges(componentElement);
        }

        return wrapper;
    }

    function watchSectionComponentSizeChanges(componentElement: Element): void {
        // Check dropzones now.
        componentElement.querySelectorAll(".dropzone")
            .forEach(dropzone => {
                watchSectionComponentDropzoneSizeChanges(dropzone);
            });

        // Keep watching for new/removed dropzones.
        sectionComponentMutationObserver.value?.observe(componentElement, { childList: true, subtree: true });
    }

    function watchSectionComponentDropzoneSizeChanges(dropzone: Element): void {
        // Check size now.
        checkDropzoneSize(dropzone.getBoundingClientRect(), dropzone);

        // Keep checking size.
        dropzoneEmptyResizeObserver.value?.observe(dropzone);
    }

    function unwatchSectionComponentDropzoneSizeChanges(dropzone: Element): void {
        // Keep checking size.
        dropzoneEmptyResizeObserver.value?.unobserve(dropzone);
    }

    async function fixOldWizardElements(document: Document): Promise<void> {
        // RSVP Component Fixes

        // The old wizard set some font styles and padding on the content elements instead of the button elements.
        const propertiesToMove: CssStyleDeclarationKebabKey[] = [
            "font-family",
            "font-size"
        ];
        Enumerable.from(document.querySelectorAll(".accept-button-shell"))
            .ofType(isHTMLElement)
            .forEach(buttonShellElement => {
                const buttonContentElement = buttonShellElement.querySelector(".rsvp-accept-content");

                if (isHTMLElement(buttonContentElement)) {
                    const buttonElement = buttonContentElement.querySelector(".rsvp-accept-link");

                    if (isHTMLElement(buttonElement)) {
                        moveStandaloneInlineStyles(
                            buttonContentElement,
                            buttonElement,
                            propertiesToMove);

                        moveShorthandInlineStyles(
                            buttonContentElement,
                            buttonElement,
                            "padding",
                            ["padding-top", "padding-bottom", "padding-right", "padding-left"]);

                        // The old wizard was missing "display" inline style on the button elements.
                        buttonElement.style.display = "inline-block";

                        // Copy the button shell padding to the button element for the Corner Radius property.
                        copyShorthandInlineStyles(
                            buttonShellElement,
                            buttonElement,
                            "border-radius",
                            ["border-top-left-radius", "border-top-right-radius", "border-bottom-right-radius", "border-bottom-left-radius"]
                        );
                    }
                }
            });
        Enumerable.from(document.querySelectorAll(".decline-button-shell"))
            .ofType(isHTMLElement)
            .forEach(buttonShellElement => {
                const buttonContentElement = buttonShellElement.querySelector(".rsvp-decline-content");

                if (isHTMLElement(buttonContentElement)) {
                    const buttonElement = buttonContentElement.querySelector(".rsvp-decline-link");

                    if (isHTMLElement(buttonElement)) {
                        moveStandaloneInlineStyles(
                            buttonContentElement,
                            buttonElement,
                            propertiesToMove);

                        moveShorthandInlineStyles(
                            buttonContentElement,
                            buttonElement,
                            "padding",
                            ["padding-top", "padding-bottom", "padding-right", "padding-left"]);

                        // The old wizard was missing "display" inline style on the button elements.
                        buttonElement.style.display = "inline-block";

                        // Copy the button shell padding to the button element for the Corner Radius property.
                        copyShorthandInlineStyles(
                            buttonShellElement,
                            buttonElement,
                            "border-radius",
                            ["border-top-left-radius", "border-top-right-radius", "border-bottom-right-radius", "border-bottom-left-radius"]
                        );

                        // The old wizard was missing the "rel" attribute on the decline button element.
                        buttonElement.setAttribute("rel", "noopener noreferrer");
                    }
                }
            });

        // Auto-migrate each component type to ensure they are all using the latest versions.
        document.querySelectorAll(".component").forEach(componentElement => {
            try {
                const componentTypeName = getComponentTypeName(componentElement);
                const componentHelper = getComponentHelper(componentTypeName);
                if (componentHelper?.isMigrationRequired(componentElement)) {
                    componentElement.replaceWith(componentHelper.migrate(componentElement));
                }
            }
            catch (e) {
                // Log and ignore errors so the email can load.
                console.error(`Error migrating component type ${e}`, componentElement);
            }
        });

        // Wait for the next tick to ensure the DOM is updated before wrapping body.
        await nextTick();

        ensureBodyWrapsEmailWrapper(document);
    }

    function hidePlaceholderAndRemoveEmptySectionHighlight(): void {
        draggingPlaceholderElement.value?.remove();
        emptySectionElementToBeAddedTo.value?.classList.remove("component-type-over");
        emptySectionElementToBeAddedTo.value = null;
    }

    function showPlaceholderBefore(element: HTMLElement): void {
        // Clear the section component that was potentially being dragged over.
        if (emptySectionElementToBeAddedTo.value) {
            emptySectionElementToBeAddedTo.value.classList.remove("component-type-over");
            emptySectionElementToBeAddedTo.value = null;
        }

        // Move the placeholder element before the element.
        if (draggingPlaceholderElement.value) {
            const parentElement = element.parentElement;

            if (parentElement) {
                parentElement.insertBefore(draggingPlaceholderElement.value, element);
            }
        }
    }

    function showPlaceholderAfter(element: HTMLElement): void {
        // Clear the section component that was potentially being dragged over.
        if (emptySectionElementToBeAddedTo.value) {
            emptySectionElementToBeAddedTo.value.classList.remove("component-type-over");
            emptySectionElementToBeAddedTo.value = null;
        }

        // Move the placeholder element after the element.
        if (draggingPlaceholderElement.value) {
            const parentElement = element.parentElement;

            if (parentElement) {
                parentElement.insertBefore(draggingPlaceholderElement.value, element.nextSibling);
            }
        }
    }

    function showPlaceholderAsLastChildOf(element: HTMLElement): void {
        // Clear the section component that was potentially being dragged over.
        if (emptySectionElementToBeAddedTo.value) {
            emptySectionElementToBeAddedTo.value.classList.remove("component-type-over");
            emptySectionElementToBeAddedTo.value = null;
        }

        if (draggingPlaceholderElement.value) {
            element.appendChild(draggingPlaceholderElement.value);
        }
    }

    function highlightEmptySection(element: HTMLElement): void {
        // Remove the placeholder element if there is one but don't clear it out.
        draggingPlaceholderElement.value?.remove();

        if (element !== emptySectionElementToBeAddedTo.value) {
            // Remove the highlighting from the previous section if highlighted.
            if (emptySectionElementToBeAddedTo.value) {
                emptySectionElementToBeAddedTo.value.classList.remove("component-type-over");
            }

            // Highlight the new section.
            emptySectionElementToBeAddedTo.value = element;
            emptySectionElementToBeAddedTo.value.classList.add("component-type-over");
        }
    }

    // #endregion Functions

    // #region Event Handlers

    /**
     * Handles the editor iframe being loaded.
     *
     * This is a good time to add initial, temporary elements
     * to the editor, like CSS, fonts, etc., but they should
     * be removed before saving the email communication message.
     */
    async function onIFrameLoaded(): Promise<void> {
        console.log(`"loaded" iframe`);

        const iFrameDocument = iFrameElement.value?.contentDocument;

        if (!iFrameDocument) {
            throw new Error("iframe: Unable to handle 'load' event. The iframe document has not been initialized.");
        }

        // Only include styles needed for editing the email, such as drag effects.
        // Styles for individual components in the HTML email should be styled by
        // CSS defined in the Communication Template as these will be stripped out.
        var style = iFrameDocument.createElement("style");
        style.className = RockRuntimeElementCssClass;
        function createCssRuleset(selector, declarations): string {
            // Start with the selector
            let cssString = `${selector} {\n`;

            // Add each declaration
            for (const [property, value] of Object.entries(declarations)) {
                cssString += `  ${property}: ${value};\n`;
            }

            // Close the ruleset
            cssString += `}`;
            return cssString;
        }

        style.textContent = `
${createCssRuleset(":root", props.cssVariables)}

        body.${draggingCssClass}, body.${draggingCssClass} * {
            cursor: grabbing;
        }

        html ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
            background-color: rgba(0,0,0,0.03);
            border-radius: 4px
        }

        html ::-webkit-scrollbar-thumb {
            width: 8px;
            background-color: rgba(0,0,0,0.2);
            border-radius: 4px
        }

        html ::-webkit-scrollbar-thumb:hover {
            background-color: rgba(0,0,0,0.3)
        }

        .dropzone:empty,
        .structure-dropzone:empty {
            position: relative;
            padding: var(--spacing-large) var(--spacing-medium);
            outline: 1px dashed var(--color-interface-medium);
            outline-offset: -1px;
            background-color: var(--color-interface-softer);
            min-height: 22px;
        }

        .component-type-over.dropzone:empty,
        .component-type-over.structure-dropzone:empty {
            background-color: var(--color-info-soft);
        }

        .dropzone:empty::after,
        .structure-dropzone:empty::after {
            font-family: 'FontAwesome';
            font-weight: 900;
            /*content: "\\f055 \\00A0 Add Content";*/
            content: "";
            color: var(--color-info-strong);
            display: block;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: ${EmptyDropzoneSvgPixelWidth}px; /* Match SVG width */
            height: 15px; /* Match SVG height */
            background-image: url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAzIiBoZWlnaHQ9IjE1IiB2aWV3Qm94PSIwIDAgMTAzIDE1IiAKICAgIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLCAwKSI+CiAgICAgICAgCjxnIGNsaXAtcGF0aD0idXJsKCNjbGlwMF8zMDA3XzMyMzM0KSI+CjxwYXRoIGQ9Ik03LjUgMC43MTg3NUMzLjc1MzkxIDAuNzE4NzUgMC43MTg3NSAzLjc1MzkxIDAuNzE4NzUgNy41QzAuNzE4NzUgMTEuMjQ2MSAzLjc1MzkxIDE0LjI4MTIgNy41IDE0LjI4MTJDMTEuMjQ2MSAxNC4yODEyIDE0LjI4MTIgMTEuMjQ2MSAxNC4yODEyIDcuNUMxNC4yODEyIDMuNzUzOTEgMTEuMjQ2MSAwLjcxODc1IDcuNSAwLjcxODc1Wk0xMS40Mzc1IDguMjY1NjJDMTEuNDM3NSA4LjQ0NjA5IDExLjI4OTggOC41OTM3NSAxMS4xMDk0IDguNTkzNzVIOC41OTM3NVYxMS4xMDk0QzguNTkzNzUgMTEuMjg5OCA4LjQ0NjA5IDExLjQzNzUgOC4yNjU2MiAxMS40Mzc1SDYuNzM0MzhDNi41NTM5MSAxMS40Mzc1IDYuNDA2MjUgMTEuMjg5OCA2LjQwNjI1IDExLjEwOTRWOC41OTM3NUgzLjg5MDYyQzMuNzEwMTYgOC41OTM3NSAzLjU2MjUgOC40NDYwOSAzLjU2MjUgOC4yNjU2MlY2LjczNDM4QzMuNTYyNSA2LjU1MzkxIDMuNzEwMTYgNi40MDYyNSAzLjg5MDYyIDYuNDA2MjVINi40MDYyNVYzLjg5MDYyQzYuNDA2MjUgMy43MTAxNiA2LjU1MzkxIDMuNTYyNSA2LjczNDM4IDMuNTYyNUg4LjI2NTYyQzguNDQ2MDkgMy41NjI1IDguNTkzNzUgMy43MTAxNiA4LjU5Mzc1IDMuODkwNjJWNi40MDYyNUgxMS4xMDk0QzExLjI4OTggNi40MDYyNSAxMS40Mzc1IDYuNTUzOTEgMTEuNDM3NSA2LjczNDM4VjguMjY1NjJaIiBmaWxsPSIjMDA3QUZGIi8+CjwvZz4KPGRlZnM+CjxjbGlwUGF0aCBpZD0iY2xpcDBfMzAwN18zMjMzNCI+CjxyZWN0IHdpZHRoPSIxNCIgaGVpZ2h0PSIxNCIgZmlsbD0id2hpdGUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAuNSAwLjUpIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KCiAgICA8L2c+CiAgICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyMywgMSkiPgogICAgICAgIAo8cGF0aCBkPSJNOS4zNzMwNSAxMUg4LjEwMTU2TDcuMDYyNSA4LjI1MTk1SDIuOTA2MjVMMS45Mjg3MSAxMUgwLjY1MDM5MUw0LjQxMDE2IDEuMTk3MjdINS41OTk2MUw5LjM3MzA1IDExWk02LjY4NjUyIDcuMjE5NzNMNS4xNDg0NCAzLjA0Mjk3QzUuMDk4MzEgMi45MDYyNSA1LjA0ODE4IDIuNjg3NSA0Ljk5ODA1IDIuMzg2NzJINC45NzA3QzQuOTI1MTMgMi42NjQ3MSA0Ljg3MjcyIDIuODgzNDYgNC44MTM0OCAzLjA0Mjk3TDMuMjg5MDYgNy4yMTk3M0g2LjY4NjUyWk0xNi42NDY1IDExSDE1LjUyNTRWOS44MTA1NUgxNS40OThDMTQuOTc4NSAxMC43MTI5IDE0LjE3NjQgMTEuMTY0MSAxMy4wOTE4IDExLjE2NDFDMTIuMjEyMiAxMS4xNjQxIDExLjUwODEgMTAuODUxOSAxMC45Nzk1IDEwLjIyNzVDMTAuNDU1NCA5LjU5ODYzIDEwLjE5MzQgOC43NDQxNCAxMC4xOTM0IDcuNjY0MDZDMTAuMTkzNCA2LjUwNjUxIDEwLjQ4NSA1LjU3OTEgMTEuMDY4NCA0Ljg4MTg0QzExLjY1MTcgNC4xODQ1NyAxMi40Mjg3IDMuODM1OTQgMTMuMzk5NCAzLjgzNTk0QzE0LjM2MSAzLjgzNTk0IDE1LjA2MDUgNC4yMTQxOSAxNS40OTggNC45NzA3SDE1LjUyNTRWMC42MzY3MTlIMTYuNjQ2NVYxMVpNMTUuNTI1NCA3LjgzNDk2VjYuODAyNzNDMTUuNTI1NCA2LjIzNzYzIDE1LjMzODUgNS43NTkxMSAxNC45NjQ4IDUuMzY3MTlDMTQuNTkxMSA0Ljk3NTI2IDE0LjExNzIgNC43NzkzIDEzLjU0MyA0Ljc3OTNDMTIuODU5NCA0Ljc3OTMgMTIuMzIxNiA1LjAyOTk1IDExLjkyOTcgNS41MzEyNUMxMS41Mzc4IDYuMDMyNTUgMTEuMzQxOCA2LjcyNTI2IDExLjM0MTggNy42MDkzOEMxMS4zNDE4IDguNDE2MDIgMTEuNTI4NiA5LjA1NDA0IDExLjkwMjMgOS41MjM0NEMxMi4yODA2IDkuOTg4MjggMTIuNzg2NSAxMC4yMjA3IDEzLjQxOTkgMTAuMjIwN0MxNC4wNDQzIDEwLjIyMDcgMTQuNTUwMSA5Ljk5NTEyIDE0LjkzNzUgOS41NDM5NUMxNS4zMjk0IDkuMDkyNzcgMTUuNTI1NCA4LjUyMzExIDE1LjUyNTQgNy44MzQ5NlpNMjQuODkwNiAxMUgyMy43Njk1VjkuODEwNTVIMjMuNzQyMkMyMy4yMjI3IDEwLjcxMjkgMjIuNDIwNiAxMS4xNjQxIDIxLjMzNTkgMTEuMTY0MUMyMC40NTY0IDExLjE2NDEgMTkuNzUyMyAxMC44NTE5IDE5LjIyMzYgMTAuMjI3NUMxOC42OTk1IDkuNTk4NjMgMTguNDM3NSA4Ljc0NDE0IDE4LjQzNzUgNy42NjQwNkMxOC40Mzc1IDYuNTA2NTEgMTguNzI5MiA1LjU3OTEgMTkuMzEyNSA0Ljg4MTg0QzE5Ljg5NTggNC4xODQ1NyAyMC42NzI5IDMuODM1OTQgMjEuNjQzNiAzLjgzNTk0QzIyLjYwNTEgMy44MzU5NCAyMy4zMDQ3IDQuMjE0MTkgMjMuNzQyMiA0Ljk3MDdIMjMuNzY5NVYwLjYzNjcxOUgyNC44OTA2VjExWk0yMy43Njk1IDcuODM0OTZWNi44MDI3M0MyMy43Njk1IDYuMjM3NjMgMjMuNTgyNyA1Ljc1OTExIDIzLjIwOSA1LjM2NzE5QzIyLjgzNTMgNC45NzUyNiAyMi4zNjEzIDQuNzc5MyAyMS43ODcxIDQuNzc5M0MyMS4xMDM1IDQuNzc5MyAyMC41NjU4IDUuMDI5OTUgMjAuMTczOCA1LjUzMTI1QzE5Ljc4MTkgNi4wMzI1NSAxOS41ODU5IDYuNzI1MjYgMTkuNTg1OSA3LjYwOTM4QzE5LjU4NTkgOC40MTYwMiAxOS43NzI4IDkuMDU0MDQgMjAuMTQ2NSA5LjUyMzQ0QzIwLjUyNDcgOS45ODgyOCAyMS4wMzA2IDEwLjIyMDcgMjEuNjY0MSAxMC4yMjA3QzIyLjI4ODQgMTAuMjIwNyAyMi43OTQzIDkuOTk1MTIgMjMuMTgxNiA5LjU0Mzk1QzIzLjU3MzYgOS4wOTI3NyAyMy43Njk1IDguNTIzMTEgMjMuNzY5NSA3LjgzNDk2Wk0zNy44MjQyIDEwLjU4OThDMzcuMDk5NiAxMC45NzI3IDM2LjE5NzMgMTEuMTY0MSAzNS4xMTcyIDExLjE2NDFDMzMuNzIyNyAxMS4xNjQxIDMyLjYwNjEgMTAuNzE1MiAzMS43Njc2IDkuODE3MzhDMzAuOTI5IDguOTE5NiAzMC41MDk4IDcuNzQxNTQgMzAuNTA5OCA2LjI4MzJDMzAuNTA5OCA0LjcxNTQ5IDMwLjk4MTQgMy40NDg1NyAzMS45MjQ4IDIuNDgyNDJDMzIuODY4MiAxLjUxNjI4IDM0LjA2NDUgMS4wMzMyIDM1LjUxMzcgMS4wMzMyQzM2LjQ0MzQgMS4wMzMyIDM3LjIxMzUgMS4xNjc2NCAzNy44MjQyIDEuNDM2NTJWMi42NjAxNkMzNy4xMjI0IDIuMjY4MjMgMzYuMzQ3NyAyLjA3MjI3IDM1LjUgMi4wNzIyN0MzNC4zNzQzIDIuMDcyMjcgMzMuNDYwNiAyLjQ0ODI0IDMyLjc1ODggMy4yMDAyQzMyLjA2MTUgMy45NTIxNSAzMS43MTI5IDQuOTU3MDMgMzEuNzEyOSA2LjIxNDg0QzMxLjcxMjkgNy40MDg4NSAzMi4wMzg3IDguMzYxMzMgMzIuNjkwNCA5LjA3MjI3QzMzLjM0NjcgOS43Nzg2NSAzNC4yMDU3IDEwLjEzMTggMzUuMjY3NiAxMC4xMzE4QzM2LjI1MiAxMC4xMzE4IDM3LjEwNDIgOS45MTMwOSAzNy44MjQyIDkuNDc1NTlWMTAuNTg5OFpNNDIuNTk1NyAxMS4xNjQxQzQxLjU2MTIgMTEuMTY0MSA0MC43MzQgMTAuODM4MiA0MC4xMTQzIDEwLjE4NjVDMzkuNDk5IDkuNTMwMjcgMzkuMTkxNCA4LjY2MjExIDM5LjE5MTQgNy41ODIwM0MzOS4xOTE0IDYuNDA2MjUgMzkuNTEyNyA1LjQ4Nzk2IDQwLjE1NTMgNC44MjcxNUM0MC43OTc5IDQuMTY2MzQgNDEuNjY2IDMuODM1OTQgNDIuNzU5OCAzLjgzNTk0QzQzLjgwMzQgMy44MzU5NCA0NC42MTY5IDQuMTU3MjMgNDUuMjAwMiA0Ljc5OThDNDUuNzg4MSA1LjQ0MjM4IDQ2LjA4MiA2LjMzMzMzIDQ2LjA4MiA3LjQ3MjY2QzQ2LjA4MiA4LjU4OTE5IDQ1Ljc2NTMgOS40ODQ3IDQ1LjEzMTggMTAuMTU5MkM0NC41MDI5IDEwLjgyOTEgNDMuNjU3NiAxMS4xNjQxIDQyLjU5NTcgMTEuMTY0MVpNNDIuNjc3NyA0Ljc3OTNDNDEuOTU3NyA0Ljc3OTMgNDEuMzg4IDUuMDI1MzkgNDAuOTY4OCA1LjUxNzU4QzQwLjU0OTUgNi4wMDUyMSA0MC4zMzk4IDYuNjc5NjkgNDAuMzM5OCA3LjU0MTAyQzQwLjMzOTggOC4zNzA0NCA0MC41NTE4IDkuMDI0NDEgNDAuOTc1NiA5LjUwMjkzQzQxLjM5OTQgOS45ODE0NSA0MS45NjY4IDEwLjIyMDcgNDIuNjc3NyAxMC4yMjA3QzQzLjQwMjMgMTAuMjIwNyA0My45NTgzIDkuOTg2IDQ0LjM0NTcgOS41MTY2QzQ0LjczNzYgOS4wNDcyIDQ0LjkzMzYgOC4zNzk1NiA0NC45MzM2IDcuNTEzNjdDNDQuOTMzNiA2LjYzODY3IDQ0LjczNzYgNS45NjQxOSA0NC4zNDU3IDUuNDkwMjNDNDMuOTU4MyA1LjAxNjI4IDQzLjQwMjMgNC43NzkzIDQyLjY3NzcgNC43NzkzWk01My42ODM2IDExSDUyLjU2MjVWNy4wMDc4MUM1Mi41NjI1IDUuNTIyMTQgNTIuMDIwMiA0Ljc3OTMgNTAuOTM1NSA0Ljc3OTNDNTAuMzc1IDQuNzc5MyA0OS45MTAyIDQuOTkxMjEgNDkuNTQxIDUuNDE1MDRDNDkuMTc2NCA1LjgzNDMxIDQ4Ljk5NDEgNi4zNjUyMyA0OC45OTQxIDcuMDA3ODFWMTFINDcuODczVjRINDguOTk0MVY1LjE2MjExSDQ5LjAyMTVDNDkuNTUwMSA0LjI3Nzk5IDUwLjMxNTggMy44MzU5NCA1MS4zMTg0IDMuODM1OTRDNTIuMDg0IDMuODM1OTQgNTIuNjY5NiA0LjA4NDMxIDUzLjA3NTIgNC41ODEwNUM1My40ODA4IDUuMDczMjQgNTMuNjgzNiA1Ljc4NjQ2IDUzLjY4MzYgNi43MjA3VjExWk01OS4wNDk4IDEwLjkzMTZDNTguNzg1NSAxMS4wNzc1IDU4LjQzNjggMTEuMTUwNCA1OC4wMDM5IDExLjE1MDRDNTYuNzc4IDExLjE1MDQgNTYuMTY1IDEwLjQ2NjggNTYuMTY1IDkuMDk5NjFWNC45NTcwM0g1NC45NjE5VjRINTYuMTY1VjIuMjkxMDJMNTcuMjg2MSAxLjkyODcxVjRINTkuMDQ5OFY0Ljk1NzAzSDU3LjI4NjFWOC45MDEzN0M1Ny4yODYxIDkuMzcwNzcgNTcuMzY1OSA5LjcwNTczIDU3LjUyNTQgOS45MDYyNUM1Ny42ODQ5IDEwLjEwNjggNTcuOTQ5MiAxMC4yMDcgNTguMzE4NCAxMC4yMDdDNTguNjAwOSAxMC4yMDcgNTguODQ0NyAxMC4xMjk2IDU5LjA0OTggOS45NzQ2MVYxMC45MzE2Wk02Ni4xNzI5IDcuNzgwMjdINjEuMjMwNUM2MS4yNDg3IDguNTU5NTcgNjEuNDU4MyA5LjE2MTEzIDYxLjg1OTQgOS41ODQ5NkM2Mi4yNjA0IDEwLjAwODggNjIuODExOCAxMC4yMjA3IDYzLjUxMzcgMTAuMjIwN0M2NC4zMDIxIDEwLjIyMDcgNjUuMDI2NyA5Ljk2MDk0IDY1LjY4NzUgOS40NDE0MVYxMC40OTQxQzY1LjA3MjMgMTAuOTQwOCA2NC4yNTg4IDExLjE2NDEgNjMuMjQ3MSAxMS4xNjQxQzYyLjI1ODEgMTEuMTY0MSA2MS40ODExIDEwLjg0NzMgNjAuOTE2IDEwLjIxMzlDNjAuMzUwOSA5LjU3NTg1IDYwLjA2ODQgOC42ODAzNCA2MC4wNjg0IDcuNTI3MzRDNjAuMDY4NCA2LjQzODE1IDYwLjM3NiA1LjU1MTc2IDYwLjk5MTIgNC44NjgxNkM2MS42MTEgNC4xODAwMSA2Mi4zNzg5IDMuODM1OTQgNjMuMjk0OSAzLjgzNTk0QzY0LjIxMDkgMy44MzU5NCA2NC45MTk2IDQuMTMyMTYgNjUuNDIwOSA0LjcyNDYxQzY1LjkyMjIgNS4zMTcwNiA2Ni4xNzI5IDYuMTM5NjUgNjYuMTcyOSA3LjE5MjM4VjcuNzgwMjdaTTY1LjAyNDQgNi44MzAwOEM2NS4wMTk5IDYuMTgyOTQgNjQuODYyNiA1LjY3OTM2IDY0LjU1MjcgNS4zMTkzNEM2NC4yNDc0IDQuOTU5MzEgNjMuODIxMyA0Ljc3OTMgNjMuMjc0NCA0Ljc3OTNDNjIuNzQ1OCA0Ljc3OTMgNjIuMjk2OSA0Ljk2ODQyIDYxLjkyNzcgNS4zNDY2OEM2MS41NTg2IDUuNzI0OTMgNjEuMzMwNyA2LjIxOTQgNjEuMjQ0MSA2LjgzMDA4SDY1LjAyNDRaTTczLjY4NTUgMTFINzIuNTY0NVY3LjAwNzgxQzcyLjU2NDUgNS41MjIxNCA3Mi4wMjIxIDQuNzc5MyA3MC45Mzc1IDQuNzc5M0M3MC4zNzcgNC43NzkzIDY5LjkxMjEgNC45OTEyMSA2OS41NDMgNS40MTUwNEM2OS4xNzg0IDUuODM0MzEgNjguOTk2MSA2LjM2NTIzIDY4Ljk5NjEgNy4wMDc4MVYxMUg2Ny44NzVWNEg2OC45OTYxVjUuMTYyMTFINjkuMDIzNEM2OS41NTIxIDQuMjc3OTkgNzAuMzE3NyAzLjgzNTk0IDcxLjMyMDMgMy44MzU5NEM3Mi4wODU5IDMuODM1OTQgNzIuNjcxNSA0LjA4NDMxIDczLjA3NzEgNC41ODEwNUM3My40ODI3IDUuMDczMjQgNzMuNjg1NSA1Ljc4NjQ2IDczLjY4NTUgNi43MjA3VjExWk03OS4wNTE4IDEwLjkzMTZDNzguNzg3NCAxMS4wNzc1IDc4LjQzODggMTEuMTUwNCA3OC4wMDU5IDExLjE1MDRDNzYuNzc5OSAxMS4xNTA0IDc2LjE2NyAxMC40NjY4IDc2LjE2NyA5LjA5OTYxVjQuOTU3MDNINzQuOTYzOVY0SDc2LjE2N1YyLjI5MTAyTDc3LjI4ODEgMS45Mjg3MVY0SDc5LjA1MThWNC45NTcwM0g3Ny4yODgxVjguOTAxMzdDNzcuMjg4MSA5LjM3MDc3IDc3LjM2NzggOS43MDU3MyA3Ny41MjczIDkuOTA2MjVDNzcuNjg2OCAxMC4xMDY4IDc3Ljk1MTIgMTAuMjA3IDc4LjMyMDMgMTAuMjA3Qzc4LjYwMjkgMTAuMjA3IDc4Ljg0NjcgMTAuMTI5NiA3OS4wNTE4IDkuOTc0NjFWMTAuOTMxNloiIGZpbGw9IiMwMDdBRkYiLz4KCiAgICA8L2c+Cjwvc3ZnPg==");
            background-size: contain;
            background-repeat: no-repeat;
        }

        .dropzone.${SmallEmptyClass}:empty::after,
        .structure-dropzone.${SmallEmptyClass}.rock-:empty::after {
            background-image: url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTUiIGhlaWdodD0iMTUiIHZpZXdCb3g9IjAgMCAxNSAxNSIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzMwMDdfMzIzMzQpIj4KPHBhdGggZD0iTTcuNSAwLjcxODc1QzMuNzUzOTEgMC43MTg3NSAwLjcxODc1IDMuNzUzOTEgMC43MTg3NSA3LjVDMC43MTg3NSAxMS4yNDYxIDMuNzUzOTEgMTQuMjgxMiA3LjUgMTQuMjgxMkMxMS4yNDYxIDE0LjI4MTIgMTQuMjgxMiAxMS4yNDYxIDE0LjI4MTIgNy41QzE0LjI4MTIgMy43NTM5MSAxMS4yNDYxIDAuNzE4NzUgNy41IDAuNzE4NzVaTTExLjQzNzUgOC4yNjU2MkMxMS40Mzc1IDguNDQ2MDkgMTEuMjg5OCA4LjU5Mzc1IDExLjEwOTQgOC41OTM3NUg4LjU5Mzc1VjExLjEwOTRDOC41OTM3NSAxMS4yODk4IDguNDQ2MDkgMTEuNDM3NSA4LjI2NTYyIDExLjQzNzVINi43MzQzOEM2LjU1MzkxIDExLjQzNzUgNi40MDYyNSAxMS4yODk4IDYuNDA2MjUgMTEuMTA5NFY4LjU5Mzc1SDMuODkwNjJDMy43MTAxNiA4LjU5Mzc1IDMuNTYyNSA4LjQ0NjA5IDMuNTYyNSA4LjI2NTYyVjYuNzM0MzhDMy41NjI1IDYuNTUzOTEgMy43MTAxNiA2LjQwNjI1IDMuODkwNjIgNi40MDYyNUg2LjQwNjI1VjMuODkwNjJDNi40MDYyNSAzLjcxMDE2IDYuNTUzOTEgMy41NjI1IDYuNzM0MzggMy41NjI1SDguMjY1NjJDOC40NDYwOSAzLjU2MjUgOC41OTM3NSAzLjcxMDE2IDguNTkzNzUgMy44OTA2MlY2LjQwNjI1SDExLjEwOTRDMTEuMjg5OCA2LjQwNjI1IDExLjQzNzUgNi41NTM5MSAxMS40Mzc1IDYuNzM0MzhWOC4yNjU2MloiIGZpbGw9IiMwMDdBRkYiLz4KPC9nPgo8ZGVmcz4KPGNsaXBQYXRoIGlkPSJjbGlwMF8zMDA3XzMyMzM0Ij4KPHJlY3Qgd2lkdGg9IjE0IiBoZWlnaHQ9IjE0IiBmaWxsPSJ3aGl0ZSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC41IDAuNSkiLz4KPC9jbGlwUGF0aD4KPC9kZWZzPgo8L3N2Zz4K");
            width: 15px; /* Match SVG width */
        }

        [contenteditable=true]:focus {
            cursor: text;
        }

        /* Ensure the iframe wrapper style is reset properly */
        #email-iframe-wrapper {
            position: relative;
        }

        /* Use overflow hidden to include margins in the hover outline. */
        .rock-runtime-wrapper-element,
        .component {
            overflow: hidden;
            cursor: pointer;
        }

        /* Use position relative so hover labels can be absolutely positioned. */
        .rock-runtime-wrapper-element {
            position: relative;
        }

        /* Add outline to components when hovered or selected to help differentiate them from other components. */
        .rock-runtime-wrapper-element.${draggingCssClass},
        body:not(.${draggingCssClass}) .rock-runtime-wrapper-element.selected,
        body:not(.${draggingCssClass}) .rock-runtime-wrapper-element:not(.for-component-row):hover,
        body:not(.${draggingCssClass},.${nonRowHoveredClass}) .rock-runtime-wrapper-element.for-component-row:hover {
            /* Use outline so the box sizing isn't affected. */
            outline: 1px solid var(--color-info-strong);
            outline-offset: -1px;

            box-shadow: inset 0 0 0 1000px rgba(0, 0, 150, .2);
            transition: box-shadow 0.3s;
        }

        /* Hover labels to help individuals select the correct component. */
        .rock-runtime-wrapper-element.${draggingCssClass}::after,
        body:not(.${draggingCssClass}) .rock-runtime-wrapper-element.selected::after,
        body:not(.${draggingCssClass}) .rock-runtime-wrapper-element:not(.for-component-row):hover::after,
        body:not(.${draggingCssClass},.${nonRowHoveredClass}) .rock-runtime-wrapper-element.for-component-row:hover::after {
            /* Override this for each component. */
            content: '';

            /* Place component hover labels on the bottom right */
            position: absolute;
            right: 0;
            bottom: 0;
            background-color: var(--color-info-strong);
            padding: var(--spacing-tiny);
            color: white;
            font-family: sans-serif;
            font-size: var(--font-size-xsmall);

            border-radius: 4px 0 0 0;
            padding-left: 6px;
            padding-top: 6px;
        }

        .rock-runtime-wrapper-element.for-component-title.${draggingCssClass}::after,
        body:not(.${draggingCssClass}) .rock-runtime-wrapper-element.for-component-title.selected::after,
        body:not(.${draggingCssClass}) .rock-runtime-wrapper-element.for-component-title:hover::after {
            content: 'Title';
        }

        .rock-runtime-wrapper-element.for-component-text.${draggingCssClass}::after,
        body:not(.${draggingCssClass}) .rock-runtime-wrapper-element.for-component-text:hover::after,
        body:not(.${draggingCssClass}) .rock-runtime-wrapper-element.for-component-text.selected::after {
            content: 'Paragraph';
        }

        .rock-runtime-wrapper-element.for-component-image.${draggingCssClass}::after,
        body:not(.${draggingCssClass}) .rock-runtime-wrapper-element.for-component-image.selected::after,
        body:not(.${draggingCssClass}) .rock-runtime-wrapper-element.for-component-image:hover::after {
            content: 'Image';
        }

        .rock-runtime-wrapper-element.for-component-video.${draggingCssClass}::after,
        body:not(.${draggingCssClass}) .rock-runtime-wrapper-element.for-component-video.selected::after,
        body:not(.${draggingCssClass}) .rock-runtime-wrapper-element.for-component-video:hover::after {
            content: 'Video';
        }

        .rock-runtime-wrapper-element.for-component-divider.${draggingCssClass}::after,
        body:not(.${draggingCssClass}) .rock-runtime-wrapper-element.for-component-divider.selected::after,
        body:not(.${draggingCssClass}) .rock-runtime-wrapper-element.for-component-divider:hover::after {
            content: 'Divider';
        }

        .rock-runtime-wrapper-element.for-component-code.${draggingCssClass}::after,
        body:not(.${draggingCssClass}) .rock-runtime-wrapper-element.for-component-code.selected::after,
        body:not(.${draggingCssClass}) .rock-runtime-wrapper-element.for-component-code:hover::after {
            content: 'Lava';
        }

        .rock-runtime-wrapper-element.for-component-button.${draggingCssClass}::after,
        body:not(.${draggingCssClass}) .rock-runtime-wrapper-element.for-component-button.selected::after,
        body:not(.${draggingCssClass}) .rock-runtime-wrapper-element.for-component-button:hover::after {
            content: 'Button';
        }

        .rock-runtime-wrapper-element.for-component-message.${draggingCssClass}::after,
        body:not(.${draggingCssClass}) .rock-runtime-wrapper-element.for-component-message.selected::after,
        body:not(.${draggingCssClass}) .rock-runtime-wrapper-element.for-component-message:hover::after {
            content: 'Message';
        }

        .rock-runtime-wrapper-element.for-component-rsvp.${draggingCssClass}::after,
        body:not(.${draggingCssClass}) .rock-runtime-wrapper-element.for-component-rsvp.selected::after,
        body:not(.${draggingCssClass}) .rock-runtime-wrapper-element.for-component-rsvp:hover::after {
            content: 'RSVP';
        }

        .rock-runtime-wrapper-element.for-component-row.${draggingCssClass}::after,
        body:not(.${draggingCssClass}) .rock-runtime-wrapper-element.for-component-row.selected::after,
        body:not(.${draggingCssClass},.${nonRowHoveredClass}) .rock-runtime-wrapper-element.for-component-row:hover::after {
            content: 'Row';
        }

        .rock-runtime-wrapper-element.for-component-section.${draggingCssClass}::after,
        body:not(.${draggingCssClass}) .rock-runtime-wrapper-element.for-component-section.selected::after,
        body:not(.${draggingCssClass}) .rock-runtime-wrapper-element.for-component-section:not(.selected):hover::after {
    content: 'Layout';

    border-radius: 0 0 0 4px;

    /* Display section component hover label at the top. */
    top: 0;
    bottom: initial;
}

.component-placeholder-container {
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 2px 0;
}

.component-placeholder-line {
    flex-grow: 1;
    height: 3px;
    background-color: var(--color-info-strong);
}

.component-placeholder-pill {
    background-color: var(--color-info-strong);
    color: #ffffff;
    padding: 4px 18px;
    font-size: 10px;
    border-radius: 9999px;
    pointer-events: none;
    line-height: 1;
}
`;
        iFrameDocument.head.appendChild(style);

        // If the body does not contain a structure-dropzone, then add one automatically.
        if (!iFrameDocument.querySelector(".structure-dropzone")) {
            const dropzone = iFrameDocument.createElement("div");
            dropzone.classList.add("structure-dropzone");
            iFrameDocument.body.append(dropzone);
        }

        removeWhiteSpaceFromChildElements(iFrameDocument, ".structure-dropzone, .dropzone");

        await fixOldWizardElements(iFrameDocument);

        // Auto-select the first component with the "selected" CSS class.
        for (const [element, index] of Enumerable.from(iFrameDocument.querySelectorAll(".component.selected")).ofType(isHTMLElement).withIndex()) {
            if (index === 0) {
                selectComponent(element);
            }
            else {
                deselectComponentElement(element);
            }
        }

        applyDefaultGlobalStylesIfNeeded(iFrameDocument);

        emailDocument.value = iFrameDocument;

        // Create a MutationObserver to watch for changes inside each wrapper
        wrapperAutoRemovalObserver.value?.disconnect();
        wrapperAutoRemovalObserver.value = new MutationObserver((mutations) => {
            // Batch processing with requestAnimationFrame.
            requestAnimationFrame(() => {
                // Use a set to track which wrappers have already been checked in the current batch.
                const processedWrappers = new WeakSet();

                mutations.forEach((mutation) => {
                    const wrapper = mutation.target;

                    if (isElement(wrapper) && !processedWrappers.has(wrapper)) {
                        processedWrappers.add(wrapper);

                        // Check if there are any runtime children.
                        const hasRuntimeChildren = Enumerable.from(wrapper.children).any(
                            (child) => child.classList.contains(RockRuntimeElementCssClass)
                        );

                        // If there were no runtime children initially,
                        // and none were added, remove the wrapper.
                        if (!hasRuntimeChildren && wrapper.isConnected) {
                            wrapper.remove();
                        }
                    }
                });
            });
        });

        dropzoneEmptyResizeObserver.value?.disconnect();
        dropzoneEmptyResizeObserver.value = new ResizeObserver((entries) => {
            Enumerable.from(entries)
                .where(e => e.target.classList.contains("dropzone"))
                .forEach(e => {
                    checkDropzoneSize(e.contentRect, e.target);
                });
        });

        // Check dropzone sizes immediately.
        sectionComponentMutationObserver.value?.disconnect();
        sectionComponentMutationObserver.value = new MutationObserver((mutations) => {
            // Batch processing with requestAnimationFrame.
            requestAnimationFrame(() => {
                // Use a set to track which nodes have already been checked in the current batch.
                const newProcessedNodes = new WeakSet<Element>();
                const oldProcessedNodes = new WeakSet<Element>();

                mutations.forEach((mutation) => {
                    if (mutation.type === "childList") {
                        Enumerable.from(mutation.addedNodes)
                            .ofType(isElement)
                            .where(e => !newProcessedNodes.has(e))
                            .forEach(e => {
                                newProcessedNodes.add(e);

                                // Watch if the node itself is a dropzone.
                                if (e.classList.contains("dropzone")) {
                                    watchSectionComponentDropzoneSizeChanges(e);
                                }

                                // Check for descendant dropzones.
                                e.querySelectorAll(".dropzone").forEach(descendantDropzone => {
                                    if (!newProcessedNodes.has(descendantDropzone)) {
                                        newProcessedNodes.add(descendantDropzone);
                                        watchSectionComponentDropzoneSizeChanges(descendantDropzone);
                                    }
                                });
                            });

                        Enumerable.from(mutation.removedNodes)
                            .ofType(isElement)
                            .where(e => !oldProcessedNodes.has(e))
                            .forEach(e => {
                                oldProcessedNodes.add(e);

                                // Stop watching for size changes on the node itself.
                                if (e.classList.contains("dropzone")) {
                                    unwatchSectionComponentDropzoneSizeChanges(e);
                                }

                                // Stop watching for size changes on all descendant dropzones.
                                e.querySelectorAll(".dropzone").forEach(descendantDropzone => {
                                    if (!oldProcessedNodes.has(descendantDropzone)) {
                                        oldProcessedNodes.add(descendantDropzone);
                                        unwatchSectionComponentDropzoneSizeChanges(descendantDropzone);
                                    }
                                });
                            });
                    }
                });
            });
        });

        // Wrap component elements to give them runtime styling.
        wrapComponentElements(iFrameDocument);

        // Finally, let other components know the document was updated.
        emit("emailDocumentUpdated", iFrameDocument);
    }

    function generateCssRulesets(styles: Record<string, string>): string {
        // Generate the final CSS string
        return Object.entries(styles)
            .map(([selector, declarations]) => `${selector} { ${declarations} }`)
            .join("\n");
    }

    function getStyleBuilder(): { addStyle(key: string, value: string): void; readonly styles: Record<string, string>; } {
        const styles: Record<string, string> = {};

        function addStyle(key: string, value: string): void {
            styles[key] = (styles[key] || "") + value;
        }

        return {
            addStyle,
            get styles() {
                return styles;
            }
        };
    }

    function applyDefaultGlobalStylesIfNeeded(iFrameDocument: Document): void {
        // Add default style sheet if it doesn't exist.
        if (!iFrameDocument.querySelector(`style.${RockStylesCssClass}`)) {
            const styleElement = iFrameDocument.createElement("style");
            styleElement.classList.add(RockStylesCssClass);

            const globalStyles = getStyleBuilder();

            globalStyles.addStyle(GlobalStylesCssSelectors.bodyPadding, "padding: 24px;");
            globalStyles.addStyle(GlobalStylesCssSelectors.globalTextStyling,
                `font-family: Arial;
                font-size: 16px;
                color: #364153;

                /* Line Height "Normal" */
                line-height: 1.5;`);
            globalStyles.addStyle(GlobalStylesCssSelectors.heading1TextStyling,
                `font-family: Arial;
                font-size: 38px;
                font-weight: bold;
                color: #030712;

                /* Line Height "Tight" */
                line-height: 1.2;`);
            globalStyles.addStyle(GlobalStylesCssSelectors.heading1Margin, `margin: 0;`);
            globalStyles.addStyle(GlobalStylesCssSelectors.heading2TextStyling,
                `font-family: Arial;
                font-size: 30px;
                font-weight: bold;
                color: #030712;

                /* Line Height "Tight" */
                line-height: 1.2;`);
            globalStyles.addStyle(GlobalStylesCssSelectors.heading2Margin, `margin: 0;`);
            globalStyles.addStyle(GlobalStylesCssSelectors.heading3TextStyling,
                `font-family: Arial;
                font-size: 24px;
                font-weight: bold;
                color: #030712;

                /* Line Height "Tight" */
                line-height: 1.2;`);
            globalStyles.addStyle(GlobalStylesCssSelectors.heading3Margin, `margin: 0;`);
            globalStyles.addStyle(GlobalStylesCssSelectors.paragraphTextStyling,
                `font-family: Arial;
                font-size: 16px;
                color: #364153;

                /* Line Height "Tight" */
                line-height: 1.2;`);
            globalStyles.addStyle(GlobalStylesCssSelectors.paragraphMargin, `margin: 0;`);
            globalStyles.addStyle(GlobalStylesCssSelectors.buttonTextStyling,
                `font-family: Arial;
                font-weight: bold;
                text-decoration: none; border-bottom-width: 0; /* border-bottom-width is needed for MSO. */
                color: #ffffff;

                /* Line Height "Tight" */
                line-height: 1.2;`);
            globalStyles.addStyle(GlobalStylesCssSelectors.buttonCornerRadius, `border-radius: 4px;`);
            globalStyles.addStyle(GlobalStylesCssSelectors.buttonPadding, `padding: 15px;`);
            globalStyles.addStyle(GlobalStylesCssSelectors.dividerStyle, `border-style: solid none none;`);
            globalStyles.addStyle(GlobalStylesCssSelectors.dividerThickness, `border-width: 1px 0px 0px;`);
            globalStyles.addStyle(GlobalStylesCssSelectors.dividerColor, `border-color: #8b8ba7 transparent transparent;`);
            globalStyles.addStyle(GlobalStylesCssSelectors.dividerMargin, `padding: 12px 0;`);

            // Add non-editable global styles.
            globalStyles.addStyle(`html, body`,
                `/* Remove client-specific spacing around root elements. */
                margin: 0;
                padding: 0;
                height: 100%;`
            );

            globalStyles.addStyle(`.component-button .button-link`,
                `text-align: center;
                letter-spacing: normal;`
            );

            globalStyles.addStyle(`.email-wrapper`,
                `width: 100%;
                height: 100%;`
            );

            styleElement.textContent = generateCssRulesets(globalStyles.styles);

            // Insert as the first child. This style sheet will be removed when sent.
            iFrameDocument.body.insertBefore(styleElement, iFrameDocument.body.firstChild);

            const mediaStyleElement = iFrameDocument.createElement("style");
            mediaStyleElement.classList.add("rock-media-styles");

            const mediaStyles = getStyleBuilder();
            mediaStyles.addStyle(`@media screen and (max-width: 600px)`,
                `.email-wrapper { min-height: 100vh; }`
            );

            mediaStyleElement.textContent = generateCssRulesets(mediaStyles.styles);

            // Insert into the head since it shouldn't be removed.
            iFrameDocument.head.append(mediaStyleElement);
        }

        // Apply other defaults using providers.
        // These providers need to run as long as the editor is open regardless of side panel tab
        // so the matching element styles stay up-to-date.
        globalBodyWidthProvider.value?.dispose();
        globalBodyWidthProvider.value = createGlobalBodyWidthProvider(iFrameDocument);

        globalBodyWidthMediaQueryEffect.value?.[Symbol.dispose]();
        globalBodyWidthMediaQueryEffect.value = createMediaQueryEffect(
            iFrameDocument.head,
            "rock-media-styles",
            `.small-12 {
                display: inline-block !important;
                width: 100% !important;
            }

            .small-11 {
                display: inline-block !important;
                width: 91.66667% !important;
            }

            .small-10 {
                display: inline-block !important;
                width: 83.33333% !important;
            }

            .small-9 {
                display: inline-block !important;
                width: 75% !important;
            }

            .small-8 {
                display: inline-block !important;
                width: 66.66667% !important;
            }

            .small-7 {
                display: inline-block !important;
                width: 58.33333% !important;
            }

            .small-6 {
                display: inline-block !important;
                width: 50% !important;
            }

            .small-5 {
                display: inline-block !important;
                width: 41.66667% !important;
            }

            .small-4 {
                display: inline-block !important;
                width: 33.33333% !important;
            }

            .small-3 {
                display: inline-block !important;
                width: 25% !important;
            }

            .small-2 {
                display: inline-block !important;
                width: 16.66667% !important;
            }

            .small-1 {
                display: inline-block !important;
                width: 8.33333% !important;
            }

            .spacer {
                display: none !important;
                width: 0 !important;
            }`,
            "max-width",
            globalBodyWidthProvider.value,
            pixelConverter
        );

        globalBodyAlignmentProvider.value?.dispose();
        globalBodyAlignmentProvider.value = createGlobalBodyAlignmentProvider(iFrameDocument);

        globalBodyColorProvider.value?.dispose();
        globalBodyColorProvider.value = createGlobalBodyBackgroundColorProvider(iFrameDocument);

        globalBackgroundColorProvider.value?.dispose();
        globalBackgroundColorProvider.value = createGlobalBackgroundColorProvider(iFrameDocument);

        globalButtonWidthValuesProvider.value?.dispose();
        globalButtonWidthValuesProvider.value = createGlobalButtonWidthValuesProvider(iFrameDocument);

        globalButtonBackgroundColorProvider.value?.dispose();
        globalButtonBackgroundColorProvider.value = createGlobalButtonBackgroundColorProvider(iFrameDocument);

        globalDividerWidthProvider.value?.dispose();
        globalDividerWidthProvider.value = createGlobalDividerWidthProvider(iFrameDocument);

        globalDividerHorizontalAlignmentProvider.value?.dispose();
        globalDividerHorizontalAlignmentProvider.value = createGlobalDividerHorizontalAlignmentProvider(iFrameDocument);
    }

    function getComponentFromMouseEvent(event: MouseEvent): { componentElement: HTMLElement | null, componentWrapperElement: HTMLElement | null } {
        const targetElement = event.target as HTMLElement | null;

        const closestComponentElement = targetElement?.closest(".component[data-state='component']") as HTMLElement | null;
        const closestWrappedComponentElement = targetElement?.closest(".rock-runtime-wrapper-element")?.querySelector(".component[data-state='component']") as HTMLElement | null;

        let componentElement: HTMLElement | null = null;

        // Choose the most descendant component element.
        if (closestComponentElement && closestWrappedComponentElement) {
            if (closestComponentElement.contains(closestWrappedComponentElement)) {
                componentElement = closestWrappedComponentElement;
            }
            else if (closestWrappedComponentElement.contains(closestComponentElement)) {
                componentElement = closestComponentElement;
            }
        }

        if (!componentElement) {
            componentElement = closestComponentElement ?? closestWrappedComponentElement;
        }

        return {
            componentElement: componentElement,
            componentWrapperElement: componentElement?.parentElement?.classList.contains(RockRuntimeWrapperElementCssClass) ? componentElement.parentElement : null
        };
    }

    function onIFrameClick(event: MouseEvent): void {
        console.log(`"click" iframe`);

        // Prevent default browser behavior so links and buttons aren't executed.
        event.preventDefault();

        const { componentElement } = getComponentFromMouseEvent(event);

        if (componentElement) {
            // Select the new component.
            selectComponent(componentElement);
        }
        else {
            // Deselect the currently selected component when anything else in the iframe is clicked.
            internalSelectedComponentElement.value = null;
        }
    }

    /**
     * Checks if a component element or one of its descendants is being edited inline.
     * @param componentElement
     */
    function isComponentBeingEditedInline(componentElement: HTMLElement, activeElementOverride?: Element | null | undefined): boolean {
        const activeElement = activeElementOverride ?? componentElement.ownerDocument.activeElement;

        return (activeElement?.getAttribute("contenteditable") === "true" || componentElement.getAttribute("contenteditable") === "true" || !!activeElement?.closest("[contenteditable='true']"))
            && (activeElement === componentElement || componentElement.contains(activeElement));
    }

    function onIFrameKeyDownEscape(event: KeyboardEvent): void {
        if (event.key === "Escape") {
            console.debug("onIFrameKeyDownEscape");
            internalSelectedComponentElement.value = null;
        }
    }

    function onIFrameKeyDownDelete(event: KeyboardEvent): void {
        if (event.key === "Delete") {
            console.debug("onIFrameKeyDownDelete");
            // Do not delete if currently inline editing.
            if (internalSelectedComponentElement.value && !isComponentBeingEditedInline(internalSelectedComponentElement.value)) {
                deleteSelectedComponent();
            }
        }
    }

    function getComponentElement(element: HTMLElement): HTMLElement | null {
        if (element.classList.contains("component")) {
            return element;
        }
        else if (element.classList.contains(RockRuntimeWrapperElementCssClass)) {
            return element.children.item(0) as HTMLElement ?? null;
        }
        else {
            return null;
        }
    }

    /**
     * Handles the mouse being down within the editor iframe.
     *
     * This will enable dragging behavior
     */
    function onIFrameComponentMouseDown(event: MouseEvent): void {
        console.log(`"mousedown" iframe component`);

        if (event.button !== 0) {
            // Only handle left mouse button events.
            return;
        }

        if (!iFrameElement.value?.contentWindow || !iFrameElement.value.contentDocument) {
            throw new Error("iframe: Unable to handle component 'mousedown' event. The iframe document has not been initialized");
        }

        const { componentElement, componentWrapperElement } = getComponentFromMouseEvent(event);

        if (componentElement) {
            const activeElementOverride = isHTMLElement(event.target) ? event.target : null;

            if (isComponentBeingEditedInline(componentElement, activeElementOverride)) {
                // The individual is editing a content editable element, so stop processing.
                console.debug(`"mousedown" inline editing; stopping early`);
                return;
            }
            else {
                // The individual is dragging a component.
                console.debug(`"mousedown" on component; readying drag`);

                // Prevent the browser from selecting text as the individual holds the mouse button down.
                event.preventDefault();

                componentElement.focus();

                dragCursorX.value = event.clientX;
                dragCursorY.value = event.clientY;

                // Enable dragging for the component element.
                iFrameElement.value.contentWindow.removeEventListener("mousemove", onIFrameComponentMouseMove);
                iFrameElement.value.contentWindow.addEventListener("mousemove", onIFrameComponentMouseMove);
                iFrameElement.value.contentWindow.removeEventListener("mouseup", onIFrameComponentMouseUp);
                iFrameElement.value.contentWindow.addEventListener("mouseup", onIFrameComponentMouseUp);

                //componentElement.setAttribute("draggable", "true");
                console.log("dragging component", componentElement);

                if (componentWrapperElement) {
                    // The component element has a wrapper that should also be moved.
                    draggingElement.value = componentWrapperElement;
                }
                else {
                    // Just move the component element.
                    draggingElement.value = componentElement;
                }

                draggingComponentTypeName.value = getComponentTypeName(componentElement);
                draggingPlaceholderElement.value = createComponentElementPlaceholder(iFrameElement.value.contentDocument);
            }
        }
    }

    function onIFrameComponentMouseUp(_event: MouseEvent): void {
        console.log(`"mouseup" iframe component`);
        let oldParent: HTMLElement | null | undefined;

        if (draggingPlaceholderElement.value && draggingElement.value) {
            if (draggingPlaceholderElement.value.parentElement) {
                if (draggingElement.value.nextSibling === draggingPlaceholderElement.value) {
                    // The component is being dragged over itself. Instead of dropping it, just select it.
                    const componentElement = getComponentElement(draggingElement.value);
                    if (componentElement) {
                        selectComponent(componentElement);
                    }
                }
                else {
                    console.log(`"dragend" iframe component - placeholder replaced with component`, draggingElement.value);
                    oldParent = draggingElement.value.parentElement;

                    // Swap the placeholder element with the permanent element.
                    draggingPlaceholderElement.value.replaceWith(draggingElement.value);
                }
            }
            else if (emptySectionElementToBeAddedTo.value) {
                console.log(`"dragend" iframe component - component added to empty section`, draggingElement.value);
                oldParent = draggingElement.value.parentElement;

                // Put the permanent element in the empty section being dragged over.
                emptySectionElementToBeAddedTo.value.appendChild(draggingElement.value);
            }
        }

        // When dragging is finished, remove the "draggable" attribute from the
        // component so it isn't left draggable in the resulting email content.
        // Also remove drag event listeners on the component element.
        iFrameElement.value?.contentWindow?.removeEventListener("mousemove", onIFrameComponentMouseMove);
        iFrameElement.value?.contentWindow?.removeEventListener("mouseup", onIFrameComponentMouseUp);

        // Clean up.
        hidePlaceholderAndRemoveEmptySectionHighlight();
        draggingPlaceholderElement.value = null;
        draggingElement.value = null;
        draggingComponentTypeName.value = null;

        // Remove whitespace from old parent so the empty section styles get applied.
        if (oldParent) {
            removeWhiteSpaceFromElementAndChildElements(oldParent, ".structure-dropzone, .dropzone");
        }
    }

    function onIFrameComponentTypeDragStart(componentTypeName: EditorComponentTypeName, customHtml?: string | null | undefined): void {
        console.log(`"dragstart" iframe component type`);

        const iFrameDocument = iFrameElement.value?.contentDocument;
        if (!iFrameDocument) {
            throw new Error("iframe: Unable to handle 'dragstart' event. The iframe document has not been initialized.");
        }

        if (customHtml) {
            const tempElement = iFrameDocument.createElement("div");
            tempElement.innerHTML = customHtml;
            const customComponentElement = tempElement.querySelector(".component");
            if (customComponentElement) {
                const helper = getComponentHelper(getComponentTypeName(customComponentElement));
                if (helper && helper.isMigrationRequired(customComponentElement)) {
                    customComponentElement.replaceWith(helper.migrate(customComponentElement));
                }
            }
            draggingElement.value = tempElement.firstElementChild as HTMLElement;
        }
        else {
            draggingElement.value = createComponentElement(iFrameDocument, componentTypeName);
        }

        draggingComponentTypeName.value = componentTypeName;

        removeWhiteSpaceFromChildElements(draggingElement.value, ".structure-dropzone, .dropzone");

        // Wrap the component element for runtime styling.
        draggingElement.value = wrapComponentElement(iFrameDocument, draggingElement.value);

        // Wrap its children just in case a saved email section is dropped.
        wrapComponentElements(draggingElement.value);

        draggingPlaceholderElement.value = createComponentElementPlaceholder(iFrameDocument);
    }

    function onIFrameComponentMouseMove(e: MouseEvent): void {
        console.log(`"mousemove" iframe component`);

        if (!iFrameElement.value?.contentDocument) {
            throw new Error("iframe: Unable to handle component 'dragover' event. The iframe document has not been initialized");
        }

        if (!draggingElement.value || !draggingPlaceholderElement.value || !draggingComponentTypeName.value) {
            // Nothing is being dragged so return early.
            return;
        }

        // Auto-scroll the iframe if the cursor is within
        // the scroll trigger distance.
        const scrollTriggerDistance = 40;
        const iframeRect = iFrameElement.value.getBoundingClientRect();
        if (e.clientY < scrollTriggerDistance) {
            iFrameElement.value.contentWindow?.scrollBy({
                top: -scrollTriggerDistance,
                behavior: "smooth"
            });
        }
        else if (e.clientY > (iframeRect.height - scrollTriggerDistance)) {
            iFrameElement.value.contentWindow?.scrollBy({
                top: scrollTriggerDistance,
                behavior: "smooth"
            });
        }
        else if (dragCursorX.value === e.clientX && dragCursorY.value === e.clientY) {
            // The cursor is idle and not near the top or bottom edge of the iframe.
            return;
        }

        dragCursorX.value = e.clientX;
        dragCursorY.value = e.clientY;

        // This handler will place the current component element
        // either before or after the element being hovered over.

        const hostSelector = getComponentHostSelector(draggingComponentTypeName.value);

        function tryHandleDrag(placeholderElement: HTMLElement, draggedOverElement: HTMLElement): boolean {
            if (draggedOverElement === draggingElement.value) {
                // Skip if the component is being dragged over itself.
                hidePlaceholderAndRemoveEmptySectionHighlight();
                return true;
            }

            if (draggingElement.value?.contains(draggedOverElement)) {
                // Skip if the component is being dragged over it's own child element.
                hidePlaceholderAndRemoveEmptySectionHighlight();
                return true;
            }

            if (draggedOverElement.matches(hostSelector)) {
                for (const child of draggedOverElement.children) {
                    const childElement = child as HTMLElement;

                    if (childElement && e.clientY < childElement.getBoundingClientRect().top) {
                        const oldParentElement = placeholderElement.parentElement;

                        showPlaceholderBefore(childElement);
                        //draggedOverElement.insertBefore(draggingComponentElement.value, childElement);

                        if (oldParentElement && oldParentElement !== placeholderElement.parentElement) {
                            removeWhiteSpaceFromElement(oldParentElement);
                        }

                        return true;
                    }
                }

                if (!draggedOverElement.children.length) {
                    // The new component is being dragged over an empty section element,
                    // so highlight the section instead of moving the placeholder.
                    highlightEmptySection(draggedOverElement);
                    return true;
                }
                else {
                    // The new component is being dragged over a non-empty section and not over any
                    // other components, so move the placeholder to the end of the section.
                    showPlaceholderAsLastChildOf(draggedOverElement);
                    return true;
                }
            }
            else if (draggedOverElement.parentElement?.matches(hostSelector)) {
                const draggedOverElementTop = draggedOverElement.getBoundingClientRect().top;
                const draggedOverElementMidpointY = (draggedOverElement.offsetHeight / 2) + draggedOverElementTop;

                const oldParentElement = placeholderElement.parentElement;

                // If the current mouse position is less than this midpoint,
                // then the new element should be placed before it.
                if (e.clientY < draggedOverElementMidpointY) {
                    showPlaceholderBefore(draggedOverElement);
                    //draggedOverElement.parentElement.insertBefore(draggingComponentElement.value, draggedOverElement);
                }
                // ... otherwise, the new element should be placed after it.
                else {
                    showPlaceholderAfter(draggedOverElement);
                    //draggedOverElement.parentElement.insertBefore(draggingComponentElement.value, draggedOverElement.nextSibling);
                }

                if (oldParentElement && oldParentElement !== placeholderElement.parentElement) {
                    removeWhiteSpaceFromElement(oldParentElement);
                }

                return true;
            }
            else {
                // Leave the element alone.
            }

            return false;
        }

        const draggedOverElements = Enumerable
            .from(iFrameElement.value.contentDocument.elementsFromPoint(e.clientX, e.clientY) ?? [])
            .ofType(isHTMLElement);

        // Find the first hovered-over element whose parent is a dropzone,
        // and move the placeholder either before or after it.
        // FYI, elementsOver is sorted from descendant element to ancestor element.
        for (const draggedOverElement of draggedOverElements) {
            if (tryHandleDrag(draggingPlaceholderElement.value, draggedOverElement)) {
                // Stop once drag is handled.
                return;
            }
        }

        // If here, then the element is not being dragged over any dropzones.
        // Try to find the first dropzone directly beneath or above the current position.
        const { element: closestElement, isAbove, isBelow } = findNearestIFrameElementFromPoint(
            iFrameElement.value,
            e.clientX,
            e.clientY,
            ".dropzone",
            // Search vertically within 10 pixels of the current position.
            0,
            10
        );

        if (closestElement) {
            const ancestorDropzone = closestElement.parentElement?.closest(hostSelector);

            // Place before the closest dropzone.
            // This requires finding the ancestor dropzone first.
            if (isHTMLElement(ancestorDropzone)) {
                const ancestorDropzoneChild = findDirectChildContaining(ancestorDropzone, closestElement);

                if (ancestorDropzoneChild) {
                    if (isBelow) {
                        showPlaceholderBefore(ancestorDropzoneChild);
                    }
                    else if (isAbove) {
                        showPlaceholderAfter(ancestorDropzoneChild);
                    }
                }
            }
        }
    }

    function onIFrameComponentTypeDragOver(message: ComponentTypeDragOverMessage): void {
        console.log(`"dragover" iframe component type`);

        if (!iFrameElement.value?.contentDocument) {
            throw new Error("iframe: Unable to handle 'dragover' event. The iframe document has not been initialized.");
        }

        if (!draggingPlaceholderElement.value || !draggingComponentTypeName.value) {
            // Nothing is being dragged so return early.
            return;
        }

        // Auto-scroll the iframe if the cursor is within
        // the scroll trigger distance.
        const scrollTriggerDistance = 40;
        const iframeRect = iFrameElement.value.getBoundingClientRect();
        if (message.clientY < scrollTriggerDistance) {
            iFrameElement.value.contentWindow?.scrollBy({
                top: -scrollTriggerDistance,
                behavior: "smooth"
            });
        }
        else if (message.clientY > (iframeRect.height - scrollTriggerDistance)) {
            iFrameElement.value.contentWindow?.scrollBy({
                top: scrollTriggerDistance,
                behavior: "smooth"
            });
        }
        else if (dragCursorX.value === message.clientX && dragCursorY.value === message.clientY) {
            // The cursor is idle and not near the top or bottom edge of the iframe.
            return;
        }

        // Keep track of dragging coordinates so the 'dragover' event is only handled
        // when dragging the component (does not execute if the dragged component is stationary).
        dragCursorX.value = message.clientX;
        dragCursorY.value = message.clientY;

        // This handler will place the current component type's placeholder element
        // either before or after the element being hovered over.

        const elementsOver = (iFrameElement.value.contentDocument.elementsFromPoint(message.clientX, message.clientY) ?? []) as HTMLElement[];

        const hostSelector = getComponentHostSelector(draggingComponentTypeName.value);

        // Find the first hovered-over element whose parent is a dropzone,
        // and move the placeholder either before or after it.
        // FYI, elementsOver is sorted from descendant element to ancestor element.
        for (const elementOver of elementsOver) {
            if (elementOver.matches(hostSelector)) {
                for (const child of elementOver.children) {
                    const childElement = child as HTMLElement;

                    if (childElement && message.clientY < childElement.getBoundingClientRect().top) {
                        // The new component is being dragged above this element's center,
                        // so show the placeholder before it.
                        showPlaceholderBefore(childElement);
                        return;
                    }
                }

                if (!elementOver.children.length) {
                    // The new component is being dragged over an empty section element,
                    // so highlight the section instead of moving the placeholder.
                    highlightEmptySection(elementOver);
                    return;
                }
                else {
                    // The new component is being dragged over a non-empty section and not over any
                    // other components, so move the placeholder to the end of the section.
                    showPlaceholderAsLastChildOf(elementOver);
                    return;
                }
            }
            else if (elementOver.parentElement?.matches(hostSelector)) {
                const topOfHoveredElement = elementOver.getBoundingClientRect().top;
                const elementOverMidpointY = (elementOver.offsetHeight / 2) + topOfHoveredElement;

                // If the current mouse position is less than this midpoint,
                // then the new element should be placed before it.
                if (message.clientY < elementOverMidpointY) {
                    showPlaceholderBefore(elementOver);
                    return;
                }
                // ... otherwise, the new element should be placed after it.
                else {
                    showPlaceholderAfter(elementOver);
                    return;
                }
            }
        }

        // If here, then the element is not being dragged over any dropzones.
        // Try to find the first dropzone directly beneath or above the current position.
        const { element: closestElement, isAbove, isBelow } = findNearestIFrameElementFromPoint(
            iFrameElement.value,
            message.clientX,
            message.clientY,
            hostSelector,
            // Search vertically within 10 pixels of the current position.
            0,
            10);
        if (closestElement) {
            const ancestorDropzone = closestElement.parentElement?.closest(hostSelector);

            // Place before the closest dropzone.
            // This requires finding the ancestor dropzone first.
            if (isHTMLElement(ancestorDropzone)) {
                const ancestorDropzoneChild = findDirectChildContaining(ancestorDropzone, closestElement);

                if (ancestorDropzoneChild) {
                    if (isBelow) {
                        showPlaceholderBefore(ancestorDropzoneChild);
                        return;
                    }
                    else if (isAbove) {
                        showPlaceholderAfter(ancestorDropzoneChild);
                        return;
                    }
                }
            }
        }

        // The component isn't being dragged over a drop target,
        // so hide the place holder and remove empty section highlighting.
        hidePlaceholderAndRemoveEmptySectionHighlight();
    }

    function onIFrameComponentTypeDragEnd(): void {
        console.log(`"dragend" iframe component type`);

        // If "dragend" happens and there was never a "drop",
        // then remove the temporary dragging element from the DOM.
        if (draggingPlaceholderElement.value) {
            draggingPlaceholderElement.value.remove();
            draggingPlaceholderElement.value = null;
            draggingElement.value = null;
            draggingComponentTypeName.value = null;
        }
    }

    function onIFrameComponentTypeDragLeave(): void {
        console.log(`"dragleave" iframe component type`);

        // If "dragleave" happens then remove the temporary dragging element from the DOM.
        if (draggingPlaceholderElement.value) {
            draggingPlaceholderElement.value.remove();
        }
    }

    function onIFrameComponentTypeDragDrop(): void {
        console.log(`"drop" iframe component type`);

        const iFrameDocument = iFrameElement.value?.contentDocument;
        if (!iFrameDocument) {
            throw new Error("iframe: Unable to handle 'drop' event. The iframe document has not been initialized.");
        }

        if (draggingPlaceholderElement.value && draggingElement.value) {
            let elementToPlace = draggingElement.value;

            // Try to automatically migrate the component if it is old.
            // This is needed for email sections.
            const componentElement = getComponentElement(draggingElement.value) ?? draggingElement.value.querySelector(".component");
            const isComponentChild = draggingElement.value.contains(componentElement);
            if (componentElement) {
                const componentHelper = getComponentHelper(getComponentTypeName(componentElement));
                if (componentHelper && componentHelper.isMigrationRequired(componentElement)) {
                    const migratedComponentElement = componentHelper.migrate(componentElement);
                    if (migratedComponentElement !== componentElement) {
                        if (isComponentChild) {
                            componentElement.replaceWith(migratedComponentElement);
                        }
                        else {
                            elementToPlace = migratedComponentElement as HTMLElement;
                        }
                    }
                }
            }

            if (draggingPlaceholderElement.value.parentElement) {
                // Swap the placeholder element with the permanent element.
                draggingPlaceholderElement.value.replaceWith(elementToPlace);
            }
            else if (emptySectionElementToBeAddedTo.value) {
                // Put the permanent element in the empty section being dragged over.
                emptySectionElementToBeAddedTo.value.appendChild(elementToPlace);
            }
        }

        draggingElement.value = null;
        draggingComponentTypeName.value = null;

        // Clean up.

        if (draggingPlaceholderElement.value) {
            // Clear the placeholder element (it has already been removed from the DOM when it was replaced with the real component element).
            draggingPlaceholderElement.value = null;
        }

        if (emptySectionElementToBeAddedTo.value) {
            // Clear the empty section being dragged over.
            emptySectionElementToBeAddedTo.value.classList.remove("component-type-over");
            emptySectionElementToBeAddedTo.value = null;
        }
    }

    /**
     * Handles all messages communicated from the parent window to the editor iframe,
     * such as components or sections being dragged from the toolbox to the editor.
     */
    function onIFrameMessageReceived(event: MessageEvent<
        ComponentTypeDragStartMessage
        | ComponentTypeDragDropMessage
        | ComponentTypeDragOverMessage
        | ComponentTypeDragLeaveMessage
        | ComponentTypeDragEndMessage>): void {
        console.log(`"message" iframe`);

        switch (event.data.type) {
            case "COMPONENT_TYPE_DRAG_START":
                onIFrameComponentTypeDragStart(event.data.componentTypeName, event.data.customHtml);
                break;

            case "COMPONENT_TYPE_DRAG_OVER":
                onIFrameComponentTypeDragOver(event.data);
                break;

            case "COMPONENT_TYPE_DRAG_LEAVE":
                onIFrameComponentTypeDragLeave();
                break;

            case "COMPONENT_TYPE_DRAG_DROP":
                onIFrameComponentTypeDragDrop();
                break;

            case "COMPONENT_TYPE_DRAG_END":
                onIFrameComponentTypeDragEnd();
                break;
        }
    }

    // #endregion Event Handlers - Child IFrame

    // #region Watchers

    watch(iFrameElement, (newIFrame, oldIFrame) => {
        if (oldIFrame) {
            removeEventHandlers(oldIFrame);
        }

        if (newIFrame) {
            nextTick(() => {
                addEventHandlers(newIFrame);
            });
        }
    });

    // Side-effects from changing the selected component element.
    watch(internalSelectedComponentElement, (newSelectedComponentElement, oldSelectedComponentElement) => {
        if (oldSelectedComponentElement && newSelectedComponentElement !== oldSelectedComponentElement) {
            // Deselect the previously selected component.
            deselectComponentElement(oldSelectedComponentElement);
        }

        if (newSelectedComponentElement) {
            newSelectedComponentElement.classList.add("selected");

            if (newSelectedComponentElement.parentElement?.classList.contains("component-side-menu-wrapper")) {
                newSelectedComponentElement.parentElement.classList.add("selected");
            }
        }
    });

    watch(() => props.html, () => {
        // Whenever the HTML is changed externally,
        // a new iframe element must be created.
        // Do this by setting v-if="false" then v-if="true" (bound to isResetting)
        // while also updating the iframe's srcdoc.
        isResetting.value = true;

        nextTick(() => {
            internalSrcDoc.value = props.html;
            isResetting.value = false;
        });
    });

    watch(() => props.cloneComponentRequest, (newValue) => {
        if (newValue) {
            cloneSelectedComponent();
        }
    });

    watch(() => props.replaceComponentRequest, (newValue) => {
        if (newValue) {
            replaceSelectedComponent(newValue.newComponentElement);
        }
    });

    watch(() => props.completeComponentRequest, (newValue) => {
        if (newValue) {
            internalSelectedComponentElement.value = null;
        }
    });

    watch(() => props.deleteComponentRequest, (newValue) => {
        if (newValue) {
            deleteSelectedComponent();
        }
    });

    watch(() => props.componentTypeDragStartRequest, (newValue) => {
        if (newValue) {
            sendMessageToIFrame({
                type: "COMPONENT_TYPE_DRAG_START",
                componentTypeName: newValue.componentTypeName,
                customHtml: newValue.customHtml
            });
        }
    });

    watch(() => props.componentTypeDragLeaveRequest, (newValue) => {
        if (newValue) {
            sendMessageToIFrame({
                type: "COMPONENT_TYPE_DRAG_LEAVE"
            });
        }
    });

    watch(() => props.componentTypeDragOverRequest, (newValue) => {
        if (newValue) {
            sendMessageToIFrame({
                type: "COMPONENT_TYPE_DRAG_OVER",
                clientX: newValue.clientX,
                clientY: newValue.clientY
            });
        }
    });

    watch(() => props.componentTypeDragDropRequest, (newValue) => {
        if (newValue) {
            sendMessageToIFrame({
                type: "COMPONENT_TYPE_DRAG_DROP"
            });
        }
    });

    watch(() => props.componentTypeDragEndRequest, (newValue) => {
        if (newValue) {
            sendMessageToIFrame({
                type: "COMPONENT_TYPE_DRAG_END"
            });
        }
    });

    watch(() => props.getHtmlRequest, (newValue) => {
        if (newValue) {
            // We don't want to update the modelValue directly;
            // otherwise, the iframe would be reloaded with new HTML.
            // The parent component should decide whether the new HTML
            // should be passed back in as the modelValue.
            getHtml(newValue);
        }
    });

    watch([draggingElement, draggingPlaceholderElement], ([draggingEl, draggingPlaceholderEl], [oldDraggingEl]) => {
        if (draggingEl || draggingPlaceholderEl) {
            iFrameElement.value?.contentDocument?.body.classList.add(draggingCssClass);

            if (draggingEl) {
                draggingEl.classList.add(draggingCssClass);
            }
        }
        else {
            iFrameElement.value?.contentDocument?.body.classList.remove(draggingCssClass);

            if (oldDraggingEl) {
                oldDraggingEl.classList.remove(draggingCssClass);
            }
        }
    });

    // #endregion Watchers

    // #region Hooks

    onBeforeUnmount(() => {
        // Stop observers to avoid memory leaks.
        wrapperAutoRemovalObserver.value?.disconnect();
        dropzoneEmptyResizeObserver.value?.disconnect();
        sectionComponentMutationObserver.value?.disconnect();

        globalBodyWidthProvider.value?.dispose();
        globalBodyWidthMediaQueryEffect.value?.[Symbol.dispose]();
        globalBodyAlignmentProvider.value?.dispose();
        globalBodyColorProvider.value?.dispose();
        globalBackgroundColorProvider.value?.dispose();
        globalButtonWidthValuesProvider.value?.dispose();
        globalButtonBackgroundColorProvider.value?.dispose();
        globalDividerWidthProvider.value?.dispose();
        globalDividerHorizontalAlignmentProvider.value?.dispose();
    });

    // #endregion
</script>