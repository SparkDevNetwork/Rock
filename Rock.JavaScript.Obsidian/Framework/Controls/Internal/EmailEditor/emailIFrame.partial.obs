<!-- Copyright by the Spark Development Network; Licensed under the Rock Community License -->
<template>
    <iframe v-if="!isResetting"
            id="email-iframe-wrapper"
            ref="iFrameElement"
            frameborder="0"
            border="0"
            :srcdoc="internalSrcDoc"></iframe>
</template>

<style scoped>
iframe {
    position: absolute;
    border: 0;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    width: 100%;
    height: 100%;
}
</style>

<script setup lang="ts">
    import { nextTick, onBeforeUnmount, PropType, ref, watch } from "vue";
    import {
        copyShorthandInlineStyles,
        createComponentElement,
        createComponentElementPlaceholder,
        moveShorthandInlineStyles,
        moveStandaloneInlineStyles,
        removeTemporaryAttributes,
        removeTemporaryClasses,
        removeTemporaryElements,
        removeTemporaryWrappers,
        RockCssClassContentEditable,
        RockRuntimeElementCssClass,
        RockRuntimeWrapperElementCssClass,
        EmptyDropzoneSvgPixelWidth,
        SmallEmptyClass,
        checkDropzoneSize,
        createBodyWidthProvider,
        contentAlignmentProvider,
        applyDefaultValueToProvider,
        DefaultBodyWidth,
        DefaultBodyAlignment,
        RockStylesCssClass,
        RockRuntimeClassCssClassPrefix
    } from "./utils.partial";
    import {
        CssStyleDeclarationKebabKey,
        ComponentTypeDragDropMessage,
        ComponentTypeDragEndMessage,
        ComponentTypeDragLeaveMessage,
        ComponentTypeDragOverMessage,
        ComponentTypeDragStartMessage,
        EditorComponentTypeName,
        CloneComponentRequest,
        CompleteComponentRequest,
        ComponentTypeDragEndRequest,
        ComponentTypeDragStartRequest,
        DeleteComponentRequest,
        ComponentTypeDragOverRequest,
        ComponentTypeDragDropRequest,
        ComponentTypeDragLeaveRequest
    } from "./types.partial";
    import { GetHtmlRequest } from "./types";
    import { useVModelPassthrough } from "@Obsidian/Utility/component";
    import {
        findDirectChildContaining,
        findNearestIFrameElementFromPoint,
        isDocument,
        isHTMLElement,
        removeWhiteSpaceFromChildElements,
        removeWhiteSpaceFromElement
    } from "@Obsidian/Utility/dom";
    import { Enumerable } from "@Obsidian/Utility/linq";

    const props = defineProps({
        /** This is reactive. If it is changed, the inner HTML for the editor will be updated. */
        html: {
            type: String as PropType<string>,
            required: true
        },

        selectedComponentElement: {
            type: Object as PropType<HTMLElement | null | undefined>,
            required: true
        },

        cssVariables: {
            type: Object as PropType<Record<string, string>>,
            required: true
        },

        cloneComponentRequest: {
            type: Object as PropType<CloneComponentRequest | null | undefined>,
            required: true
        },

        completeComponentRequest: {
            type: Object as PropType<CompleteComponentRequest | null | undefined>,
            required: true
        },

        deleteComponentRequest: {
            type: Object as PropType<DeleteComponentRequest | null | undefined>,
            required: true
        },

        componentTypeDragStartRequest: {
            type: Object as PropType<ComponentTypeDragStartRequest | null | undefined>,
            required: true
        },

        componentTypeDragOverRequest: {
            type: Object as PropType<ComponentTypeDragOverRequest | null | undefined>,
            required: true
        },

        componentTypeDragDropRequest: {
            type: Object as PropType<ComponentTypeDragDropRequest | null | undefined>,
            required: true
        },

        componentTypeDragLeaveRequest: {
            type: Object as PropType<ComponentTypeDragLeaveRequest | null | undefined>,
            required: true
        },

        componentTypeDragEndRequest: {
            type: Object as PropType<ComponentTypeDragEndRequest | null | undefined>,
            required: true
        },

        getHtmlRequest: {
            type: Object as PropType<GetHtmlRequest | null | undefined>,
            required: true
        }
    });

    const emit = defineEmits<{
        (e: "update:selectedComponentElement", value: HTMLElement | null | undefined): void;
        (e: "emailDocumentUpdated", value: Document): void;
    }>();

    const draggingCssClass = `${RockRuntimeClassCssClassPrefix}-is-dragging` as const;

    // #region Values

    const isResetting = ref<boolean>(false);
    const internalSrcDoc = ref<string>(props.html);
    const iFrameElement = ref<HTMLIFrameElement | undefined>();
    const draggingElement = ref<HTMLElement | null | undefined>();
    const draggingPlaceholderElement = ref<HTMLElement | null | undefined>();
    const dragCursorX = ref<number | null | undefined>();
    const dragCursorY = ref<number | null | undefined>();
    const internalSelectedComponentElement = useVModelPassthrough(props, "selectedComponentElement", emit);
    const emptySectionElementToBeAddedTo = ref<HTMLElement | null | undefined>();
    const wrapperAutoRemovalObserver = ref<MutationObserver | null | undefined>();
    const sectionComponentMutationObserver = ref<MutationObserver | null | undefined>();
    const dropzoneEmptyResizeObserver = ref<ResizeObserver | null | undefined>();

    // #endregion

    // #region Computed Values

    const emailDocument = ref<Document | null | undefined>(iFrameElement.value?.contentDocument as Document);

    // #endregion

    // #region Functions

    /**
     * Adds event handlers to the iframe.
     */
    function addEventHandlers(iFrameElement: HTMLIFrameElement): void {
        iFrameElement.addEventListener("load", () => {
            const iFrameWindow = iFrameElement.contentWindow!;

            // Window Events
            // Add the handler that processes interwindow communication.
            iFrameWindow.removeEventListener("message", onIFrameMessageReceived);
            iFrameWindow.addEventListener("message", onIFrameMessageReceived);

            // Document Events
            // Add handler for dealing with dragging components within the editor.
            iFrameWindow.document.removeEventListener("mousedown", onIFrameComponentMouseDown);
            iFrameWindow.document.addEventListener("mousedown", onIFrameComponentMouseDown);

            // Add handler that selects components within the editor.
            iFrameWindow.document.removeEventListener("click", onIFrameClick);
            iFrameWindow.document.addEventListener("click", onIFrameClick);

            // Add handler for delete and escape keys being pressed.
            iFrameWindow.document.removeEventListener("keydown", onIFrameKeyDownDelete);
            iFrameWindow.document.addEventListener("keydown", onIFrameKeyDownDelete);
            iFrameWindow.document.removeEventListener("keydown", onIFrameKeyDownEscape);
            iFrameWindow.document.addEventListener("keydown", onIFrameKeyDownEscape);

            onIFrameLoaded();
        });
    }

    /**
     * Removes event handlers from the iframe.
     */
    function removeEventHandlers(iFrameElement: HTMLIFrameElement): void {
        const iFrameWindow = iFrameElement.contentWindow;

        if (iFrameWindow) {
            iFrameWindow.removeEventListener("load", onIFrameLoaded);
            iFrameWindow.removeEventListener("message", onIFrameMessageReceived);
            iFrameWindow.document.removeEventListener("mousedown", onIFrameComponentMouseDown);
            iFrameWindow.document.removeEventListener("click", onIFrameClick);
            iFrameWindow.document.removeEventListener("keydown", onIFrameKeyDownEscape);
            iFrameWindow.document.removeEventListener("keydown", onIFrameKeyDownDelete);
        }
    }

    /**
     * Sends a message to the iframe.
     *
     * This is used for forwarding events to the iframe
     * so they can be handled in the iframe's context.
     */
    function sendMessageToIFrame(message:
        ComponentTypeDragStartMessage
        | ComponentTypeDragDropMessage
        | ComponentTypeDragOverMessage
        | ComponentTypeDragLeaveMessage
        | ComponentTypeDragEndMessage): void {
        if (!iFrameElement.value?.contentWindow) {
            throw "Unable to post message. The iframe is not initialized.";
        }

        // FYI, if the message is an object, it cannot contain methods.
        // When postMessage is called, the message is serialized.
        // When the iframe handles the message event, the message is deserialized.
        // The message references will not be the same!
        iFrameElement.value.contentWindow.postMessage(message, "/");
    }

    /**
     * Gets a component's descendant elements that are allowed to be edited in-line.
     *
     * This does not mean that inline editing is enabled yet on those elements, but that it *can be* enabled.
     */
    function getInlineEditableElements(componentElement: HTMLElement): Enumerable<HTMLElement> {
        const generator = function* (): Generator<HTMLElement, void, unknown> {
            if (componentElement.classList.contains(RockCssClassContentEditable)) {
                yield componentElement;
            }

            for (const element of componentElement.querySelectorAll(`.${RockCssClassContentEditable}`)) {
                if (isHTMLElement(element)) {
                    yield element;
                }
            }
        };
        return Enumerable.from(generator);
    }

    /**
     * Selects a component.
     *
     * This should handle all things about selecting a component.
     */
    function selectComponent(componentElement: HTMLElement): void {
        // IMPORTANT! This needs to be able to be called multiple times.
        // The first selection will highlight the component and show its properties.
        // Subsequent selections will enable inline editing.
        if (internalSelectedComponentElement.value === componentElement) {
            // The component is already selected. Make editable regions editable.
            getInlineEditableElements(componentElement)
                .forEach(element => {
                    element.setAttribute("contenteditable", "true");
                    element.addEventListener("blur", () => {
                        element.removeAttribute("contenteditable");
                    }, { once: true });
                });
            return;
        }
        else {
            internalSelectedComponentElement.value = componentElement;
        }
    }

    /**
     * Deselects a component.
     *
     * This should handle all things about deselecting a component.
     */
    function deselectComponentElement(componentElement: HTMLElement): void {
        componentElement.classList.remove("selected");

        // Removed the selected class from the wrapper too, if needed.
        if (componentElement.parentElement?.classList.contains("component-side-menu-wrapper")) {
            componentElement.parentElement.classList.remove("selected");
        }

        // Disable in-line editing for in-line editable elements.
        getInlineEditableElements(componentElement)
            .forEach(element => {
                element.removeAttribute("contenteditable");
            });

        // Remove selected ranges for elements that were being edited inline.
        const { selection, ranges } = getRangesWithinElement(componentElement);
        if (selection && ranges.length) {
            ranges.forEach(range => {
                selection.removeRange(range);
            });
        }
    }

    function getRangesWithinElement(element: HTMLElement): { selection: Selection | null | undefined, ranges: Range[] } {
        const selection = element.ownerDocument.defaultView?.getSelection();
        const ranges: Range[] = [];
        if (selection) {
            if ((selection.rangeCount ?? 0) > 0) {
                for (let i = 0; i < selection.rangeCount; i++) {
                    const range = selection.getRangeAt(i);

                    // Check if the range is within or intersects with the element
                    if (element.contains(range.startContainer) || element.contains(range.endContainer)) {
                        ranges.push(range);
                    }
                }
            }
        }

        return { selection, ranges };
    }

    function cloneSelectedComponent(): void {
        if (internalSelectedComponentElement.value) {
            let clonableElement: HTMLElement | null = null;

            if (internalSelectedComponentElement.value.parentElement?.classList.contains(RockRuntimeWrapperElementCssClass)) {
                clonableElement = internalSelectedComponentElement.value.parentElement;
            }
            else {
                clonableElement = internalSelectedComponentElement.value;
            }

            // Clone element.
            const clone = clonableElement.cloneNode(true) as HTMLElement;

            // Add the clone after the current component.
            const isRootDropzone = internalSelectedComponentElement.value.matches(".component-section") &&
                !internalSelectedComponentElement.value.closest(".dropzone");

            if (isRootDropzone) {
                const ancestorStructureDropzone = clonableElement.parentElement?.closest(".structure-dropzone");

                if (isHTMLElement(ancestorStructureDropzone)) {
                    const ancestorStructureDropzoneChild = findDirectChildContaining(ancestorStructureDropzone, clonableElement);

                    if (isHTMLElement(ancestorStructureDropzoneChild)) {
                        ancestorStructureDropzone.insertBefore(clone, ancestorStructureDropzoneChild.nextElementSibling);
                    }
                    else {
                        // Do not clone, otherwise the section component will be placed outside of a structure dropzone.
                        console.error("Unable to clone section. The section and is no longer a descendant of a structure dropzone.");
                    }
                }
                else {
                    // Do not clone, otherwise the section component will be placed outside of a structure dropzone.
                    console.error("Unable to clone section. There is no structure dropzone to place it in.");
                }
            }
            else {
                clonableElement.parentElement?.insertBefore(clone, clonableElement.nextSibling);
            }

            // Select the new component.
            internalSelectedComponentElement.value = clone.classList.contains("component") ? clone : clone.querySelector(".component") as HTMLElement;
        }
    }

    function deleteSelectedComponent(): void {
        if (internalSelectedComponentElement.value) {
            let parentElement: HTMLElement | null = null;

            if (internalSelectedComponentElement.value.parentElement?.classList.contains(RockRuntimeWrapperElementCssClass)) {
                parentElement = internalSelectedComponentElement.value.parentElement.parentElement;
                internalSelectedComponentElement.value.parentElement.remove();
            }
            else {
                parentElement = internalSelectedComponentElement.value.parentElement;
                internalSelectedComponentElement.value.remove();
            }

            if (parentElement?.children.length === 0 && [...parentElement.childNodes].every(n => !n.nodeValue?.trim())) {
                // Clear all inner HTML if there are no children nor non-empty text elements.
                parentElement.innerHTML = "";
            }

            internalSelectedComponentElement.value = null;
        }
    }

    /**
     * Gets the processed HTML for this email iframe.
     */
    function getHtml(options: GetHtmlRequest): void {
        try {
            const clone = document.createElement("iframe");

            // Hide the clone.
            clone.style.display = "none";

            // Append the cloned iframe to the body to get access to the clone's contentDocument.
            document.body.appendChild(clone);

            const cloneDocument = clone.contentDocument ?? clone.contentWindow?.document;

            if (cloneDocument) {
                cloneDocument.open();
                cloneDocument.writeln(iFrameElement.value?.contentWindow?.document.documentElement.outerHTML ?? "");
                cloneDocument.close();

                removeTemporaryElements(cloneDocument);
                removeTemporaryAttributes(cloneDocument);
                removeTemporaryWrappers(cloneDocument);
                removeTemporaryClasses(cloneDocument);

                const html = cloneDocument.documentElement.outerHTML ?? "";

                // Remove the cloned iframe element before returning the HTML.
                clone.remove();

                options.onSuccess(html);
            }
            else {
                throw new Error("An error occurred while preparing HTML.");
            }
        }
        catch (e) {
            if (options.onError) {
                options.onError(e?.["message"] ?? "An unknown error occurred while preparing HTML.");
            }

            throw e;
        }
    }

    function isComponentElement(element: HTMLElement): element is HTMLElement {
        return element.classList.contains("component") && element.dataset.state === "component";
    }

    function wrapComponentElements(element: Document | Element): void {
        const document = isDocument(element) ? element : element.ownerDocument;
        element.querySelectorAll(`.component[data-state="component"]`)
            .forEach(componentElement => {
                if (isHTMLElement(componentElement)) {
                    wrapComponentElement(document, componentElement);
                }
            });
    }

    /**
     * Adds a wrapper to a component element.
     */
    function wrapComponentElement(document: Document, componentElement: HTMLElement): HTMLElement {
        // Do not wrap if the element is not a component element.
        if (!isComponentElement(componentElement)) {
            return componentElement;
        }

        // Do not wrap if a wrapper already exists.
        if (componentElement.parentElement?.classList.contains("component-side-menu-wrapper")) {
            return componentElement;
        }

        const componentTypeNameCssClass = [...componentElement.classList].find(cssClass => cssClass.startsWith("component-"));

        // Create the wrapper element.
        const wrapper = document.createElement("div");
        wrapper.classList.add(RockRuntimeWrapperElementCssClass, "component-side-menu-wrapper");
        if (componentTypeNameCssClass) {
            wrapper.classList.add(`for-${componentTypeNameCssClass}`);
        }

        // Insert wrapper before the component and move the component inside it.
        componentElement.parentNode?.insertBefore(wrapper, componentElement);
        wrapper.appendChild(componentElement);

        // Automatically remove the wrapper if all of its children elements are removed.
        wrapperAutoRemovalObserver.value?.observe(wrapper, { childList: true });

        // Add a resize observer if a section component.
        if (componentElement.classList.contains("component-section")) {
            watchSectionComponentSizeChanges(componentElement);
        }

        return wrapper;
    }

    function watchSectionComponentSizeChanges(componentElement: HTMLElement): void {
        // Check dropzones now.
        Enumerable.from(componentElement.querySelectorAll(".dropzone"))
            .ofType(isHTMLElement)
            .forEach(dropzone => {
                watchSectionComponentDropzoneSizeChanges(dropzone);
            });

        // Keep watching for new/removed dropzones.
        sectionComponentMutationObserver.value?.observe(componentElement, { childList: true, subtree: true });
    }

    function watchSectionComponentDropzoneSizeChanges(dropzone: HTMLElement): void {
        // Check size now.
        checkDropzoneSize(dropzone.getBoundingClientRect(), dropzone);

        // Keep checking size.
        dropzoneEmptyResizeObserver.value?.observe(dropzone);
    }

    function fixOldWizardElements(document: Document): void {
        // RSVP Component Fixes

        // The old wizard set some font styles and padding on the content elements instead of the button elements.
        const propertiesToMove: CssStyleDeclarationKebabKey[] = [
            "font-family",
            "font-size"
        ];
        Enumerable.from(document.querySelectorAll(".accept-button-shell"))
            .ofType(isHTMLElement)
            .forEach(buttonShellElement => {
                const buttonContentElement = buttonShellElement.querySelector(".rsvp-accept-content");

                if (isHTMLElement(buttonContentElement)) {
                    const buttonElement = buttonContentElement.querySelector(".rsvp-accept-link");

                    if (isHTMLElement(buttonElement)) {
                        moveStandaloneInlineStyles(
                            buttonContentElement,
                            buttonElement,
                            propertiesToMove);

                        moveShorthandInlineStyles(
                            buttonContentElement,
                            buttonElement,
                            "padding",
                            ["padding-top", "padding-bottom", "padding-right", "padding-left"]);

                        // The old wizard was missing "display" inline style on the button elements.
                        buttonElement.style.display = "inline-block";

                        // Copy the button shell padding to the button element for the Corner Radius property.
                        copyShorthandInlineStyles(
                            buttonShellElement,
                            buttonElement,
                            "border-radius",
                            ["border-top-left-radius", "border-top-right-radius", "border-bottom-right-radius", "border-bottom-left-radius"]
                        );
                    }
                }
            });
        Enumerable.from(document.querySelectorAll(".decline-button-shell"))
            .ofType(isHTMLElement)
            .forEach(buttonShellElement => {
                const buttonContentElement = buttonShellElement.querySelector(".rsvp-decline-content");

                if (isHTMLElement(buttonContentElement)) {
                    const buttonElement = buttonContentElement.querySelector(".rsvp-decline-link");

                    if (isHTMLElement(buttonElement)) {
                        moveStandaloneInlineStyles(
                            buttonContentElement,
                            buttonElement,
                            propertiesToMove);

                        moveShorthandInlineStyles(
                            buttonContentElement,
                            buttonElement,
                            "padding",
                            ["padding-top", "padding-bottom", "padding-right", "padding-left"]);

                        // The old wizard was missing "display" inline style on the button elements.
                        buttonElement.style.display = "inline-block";

                        // Copy the button shell padding to the button element for the Corner Radius property.
                        copyShorthandInlineStyles(
                            buttonShellElement,
                            buttonElement,
                            "border-radius",
                            ["border-top-left-radius", "border-top-right-radius", "border-bottom-right-radius", "border-bottom-left-radius"]
                        );

                        // The old wizard was missing the "rel" attribute on the decline button element.
                        buttonElement.setAttribute("rel", "noopener noreferrer");
                    }
                }
            });
    }

    function hidePlaceholderAndRemoveEmptySectionHighlight(): void {
        draggingPlaceholderElement.value?.remove();
        emptySectionElementToBeAddedTo.value?.classList.remove("component-type-over");
        emptySectionElementToBeAddedTo.value = null;
    }

    function showPlaceholderBefore(element: HTMLElement): void {
        // Clear the section component that was potentially being dragged over.
        if (emptySectionElementToBeAddedTo.value) {
            emptySectionElementToBeAddedTo.value.classList.remove("component-type-over");
            emptySectionElementToBeAddedTo.value = null;
        }

        // Move the placeholder element before the element.
        if (draggingPlaceholderElement.value) {
            const parentElement = element.parentElement;

            if (parentElement) {
                parentElement.insertBefore(draggingPlaceholderElement.value, element);
            }
        }
    }

    function showPlaceholderAfter(element: HTMLElement): void {
        // Clear the section component that was potentially being dragged over.
        if (emptySectionElementToBeAddedTo.value) {
            emptySectionElementToBeAddedTo.value.classList.remove("component-type-over");
            emptySectionElementToBeAddedTo.value = null;
        }

        // Move the placeholder element after the element.
        if (draggingPlaceholderElement.value) {
            const parentElement = element.parentElement;

            if (parentElement) {
                parentElement.insertBefore(draggingPlaceholderElement.value, element.nextSibling);
            }
        }
    }

    function showPlaceholderAsLastChildOf(element: HTMLElement): void {
        // Clear the section component that was potentially being dragged over.
        if (emptySectionElementToBeAddedTo.value) {
            emptySectionElementToBeAddedTo.value.classList.remove("component-type-over");
            emptySectionElementToBeAddedTo.value = null;
        }

        if (draggingPlaceholderElement.value) {
            element.appendChild(draggingPlaceholderElement.value);
        }
    }

    function highlightEmptySection(element: HTMLElement): void {
        // Remove the placeholder element if there is one but don't clear it out.
        draggingPlaceholderElement.value?.remove();

        if (element !== emptySectionElementToBeAddedTo.value) {
            // Remove the highlighting from the previous section if highlighted.
            if (emptySectionElementToBeAddedTo.value) {
                emptySectionElementToBeAddedTo.value.classList.remove("component-type-over");
            }

            // Highlight the new section.
            emptySectionElementToBeAddedTo.value = element;
            emptySectionElementToBeAddedTo.value.classList.add("component-type-over");
        }
    }

    // #endregion Functions

    // #region Event Handlers

    /**
     * Handles the editor iframe being loaded.
     *
     * This is a good time to add initial, temporary elements
     * to the editor, like CSS, fonts, etc., but they should
     * be removed before saving the email communication message.
     */
    function onIFrameLoaded(): void {
        console.log(`"loaded" iframe`);

        const iFrameDocument = iFrameElement.value?.contentDocument;

        if (!iFrameDocument) {
            throw "iframe: Unable to handle 'load' event. The iframe document has not been initialized.";
        }

        // Only include styles needed for editing the email, such as drag effects.
        // Styles for individual components in the HTML email should be styled by
        // CSS defined in the Communication Template as these will be stripped out.
        var style = iFrameDocument.createElement("style");
        style.className = RockRuntimeElementCssClass;
        function createCssRuleset(selector, declarations): string {
            // Start with the selector
            let cssString = `${selector} {\n`;

            // Add each declaration
            for (const [property, value] of Object.entries(declarations)) {
                cssString += `  ${property}: ${value};\n`;
            }

            // Close the ruleset
            cssString += `}`;
            return cssString;
        }

        style.textContent = `
${createCssRuleset(":root", props.cssVariables)}

body.${draggingCssClass}, body.${draggingCssClass} * {
    cursor: grabbing;
}

html ::-webkit-scrollbar {
    width: 8px;
    height: 8px;
    background-color: rgba(0,0,0,0.03);
    border-radius: 4px
}

html ::-webkit-scrollbar-thumb {
    width: 8px;
    background-color: rgba(0,0,0,0.2);
    border-radius: 4px
}

html ::-webkit-scrollbar-thumb:hover {
    background-color: rgba(0,0,0,0.3)
}

.dropzone:empty,
.structure-dropzone:empty {
    position: relative;
    padding: var(--spacing-large) var(--spacing-medium);
    outline: 1px dashed var(--color-interface-medium);
    outline-offset: -1px;
    background-color: var(--color-interface-softer);
    min-height: 22px;
}

.component-type-over.dropzone:empty,
.component-type-over.structure-dropzone:empty {
    background-color: var(--color-info-soft);
}

.dropzone:empty::after,
.structure-dropzone:empty::after {
    font-family: 'FontAwesome';
    font-weight: 900;
    /*content: "\\f055 \\00A0 Add Content";*/
    content: "";
    color: var(--color-info-strong);
    display: block;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: ${EmptyDropzoneSvgPixelWidth}px; /* Match SVG width */
    height: 15px; /* Match SVG height */
    background-image: url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAzIiBoZWlnaHQ9IjE1IiB2aWV3Qm94PSIwIDAgMTAzIDE1IiAKICAgIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLCAwKSI+CiAgICAgICAgCjxnIGNsaXAtcGF0aD0idXJsKCNjbGlwMF8zMDA3XzMyMzM0KSI+CjxwYXRoIGQ9Ik03LjUgMC43MTg3NUMzLjc1MzkxIDAuNzE4NzUgMC43MTg3NSAzLjc1MzkxIDAuNzE4NzUgNy41QzAuNzE4NzUgMTEuMjQ2MSAzLjc1MzkxIDE0LjI4MTIgNy41IDE0LjI4MTJDMTEuMjQ2MSAxNC4yODEyIDE0LjI4MTIgMTEuMjQ2MSAxNC4yODEyIDcuNUMxNC4yODEyIDMuNzUzOTEgMTEuMjQ2MSAwLjcxODc1IDcuNSAwLjcxODc1Wk0xMS40Mzc1IDguMjY1NjJDMTEuNDM3NSA4LjQ0NjA5IDExLjI4OTggOC41OTM3NSAxMS4xMDk0IDguNTkzNzVIOC41OTM3NVYxMS4xMDk0QzguNTkzNzUgMTEuMjg5OCA4LjQ0NjA5IDExLjQzNzUgOC4yNjU2MiAxMS40Mzc1SDYuNzM0MzhDNi41NTM5MSAxMS40Mzc1IDYuNDA2MjUgMTEuMjg5OCA2LjQwNjI1IDExLjEwOTRWOC41OTM3NUgzLjg5MDYyQzMuNzEwMTYgOC41OTM3NSAzLjU2MjUgOC40NDYwOSAzLjU2MjUgOC4yNjU2MlY2LjczNDM4QzMuNTYyNSA2LjU1MzkxIDMuNzEwMTYgNi40MDYyNSAzLjg5MDYyIDYuNDA2MjVINi40MDYyNVYzLjg5MDYyQzYuNDA2MjUgMy43MTAxNiA2LjU1MzkxIDMuNTYyNSA2LjczNDM4IDMuNTYyNUg4LjI2NTYyQzguNDQ2MDkgMy41NjI1IDguNTkzNzUgMy43MTAxNiA4LjU5Mzc1IDMuODkwNjJWNi40MDYyNUgxMS4xMDk0QzExLjI4OTggNi40MDYyNSAxMS40Mzc1IDYuNTUzOTEgMTEuNDM3NSA2LjczNDM4VjguMjY1NjJaIiBmaWxsPSIjMDA3QUZGIi8+CjwvZz4KPGRlZnM+CjxjbGlwUGF0aCBpZD0iY2xpcDBfMzAwN18zMjMzNCI+CjxyZWN0IHdpZHRoPSIxNCIgaGVpZ2h0PSIxNCIgZmlsbD0id2hpdGUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAuNSAwLjUpIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KCiAgICA8L2c+CiAgICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyMywgMSkiPgogICAgICAgIAo8cGF0aCBkPSJNOS4zNzMwNSAxMUg4LjEwMTU2TDcuMDYyNSA4LjI1MTk1SDIuOTA2MjVMMS45Mjg3MSAxMUgwLjY1MDM5MUw0LjQxMDE2IDEuMTk3MjdINS41OTk2MUw5LjM3MzA1IDExWk02LjY4NjUyIDcuMjE5NzNMNS4xNDg0NCAzLjA0Mjk3QzUuMDk4MzEgMi45MDYyNSA1LjA0ODE4IDIuNjg3NSA0Ljk5ODA1IDIuMzg2NzJINC45NzA3QzQuOTI1MTMgMi42NjQ3MSA0Ljg3MjcyIDIuODgzNDYgNC44MTM0OCAzLjA0Mjk3TDMuMjg5MDYgNy4yMTk3M0g2LjY4NjUyWk0xNi42NDY1IDExSDE1LjUyNTRWOS44MTA1NUgxNS40OThDMTQuOTc4NSAxMC43MTI5IDE0LjE3NjQgMTEuMTY0MSAxMy4wOTE4IDExLjE2NDFDMTIuMjEyMiAxMS4xNjQxIDExLjUwODEgMTAuODUxOSAxMC45Nzk1IDEwLjIyNzVDMTAuNDU1NCA5LjU5ODYzIDEwLjE5MzQgOC43NDQxNCAxMC4xOTM0IDcuNjY0MDZDMTAuMTkzNCA2LjUwNjUxIDEwLjQ4NSA1LjU3OTEgMTEuMDY4NCA0Ljg4MTg0QzExLjY1MTcgNC4xODQ1NyAxMi40Mjg3IDMuODM1OTQgMTMuMzk5NCAzLjgzNTk0QzE0LjM2MSAzLjgzNTk0IDE1LjA2MDUgNC4yMTQxOSAxNS40OTggNC45NzA3SDE1LjUyNTRWMC42MzY3MTlIMTYuNjQ2NVYxMVpNMTUuNTI1NCA3LjgzNDk2VjYuODAyNzNDMTUuNTI1NCA2LjIzNzYzIDE1LjMzODUgNS43NTkxMSAxNC45NjQ4IDUuMzY3MTlDMTQuNTkxMSA0Ljk3NTI2IDE0LjExNzIgNC43NzkzIDEzLjU0MyA0Ljc3OTNDMTIuODU5NCA0Ljc3OTMgMTIuMzIxNiA1LjAyOTk1IDExLjkyOTcgNS41MzEyNUMxMS41Mzc4IDYuMDMyNTUgMTEuMzQxOCA2LjcyNTI2IDExLjM0MTggNy42MDkzOEMxMS4zNDE4IDguNDE2MDIgMTEuNTI4NiA5LjA1NDA0IDExLjkwMjMgOS41MjM0NEMxMi4yODA2IDkuOTg4MjggMTIuNzg2NSAxMC4yMjA3IDEzLjQxOTkgMTAuMjIwN0MxNC4wNDQzIDEwLjIyMDcgMTQuNTUwMSA5Ljk5NTEyIDE0LjkzNzUgOS41NDM5NUMxNS4zMjk0IDkuMDkyNzcgMTUuNTI1NCA4LjUyMzExIDE1LjUyNTQgNy44MzQ5NlpNMjQuODkwNiAxMUgyMy43Njk1VjkuODEwNTVIMjMuNzQyMkMyMy4yMjI3IDEwLjcxMjkgMjIuNDIwNiAxMS4xNjQxIDIxLjMzNTkgMTEuMTY0MUMyMC40NTY0IDExLjE2NDEgMTkuNzUyMyAxMC44NTE5IDE5LjIyMzYgMTAuMjI3NUMxOC42OTk1IDkuNTk4NjMgMTguNDM3NSA4Ljc0NDE0IDE4LjQzNzUgNy42NjQwNkMxOC40Mzc1IDYuNTA2NTEgMTguNzI5MiA1LjU3OTEgMTkuMzEyNSA0Ljg4MTg0QzE5Ljg5NTggNC4xODQ1NyAyMC42NzI5IDMuODM1OTQgMjEuNjQzNiAzLjgzNTk0QzIyLjYwNTEgMy44MzU5NCAyMy4zMDQ3IDQuMjE0MTkgMjMuNzQyMiA0Ljk3MDdIMjMuNzY5NVYwLjYzNjcxOUgyNC44OTA2VjExWk0yMy43Njk1IDcuODM0OTZWNi44MDI3M0MyMy43Njk1IDYuMjM3NjMgMjMuNTgyNyA1Ljc1OTExIDIzLjIwOSA1LjM2NzE5QzIyLjgzNTMgNC45NzUyNiAyMi4zNjEzIDQuNzc5MyAyMS43ODcxIDQuNzc5M0MyMS4xMDM1IDQuNzc5MyAyMC41NjU4IDUuMDI5OTUgMjAuMTczOCA1LjUzMTI1QzE5Ljc4MTkgNi4wMzI1NSAxOS41ODU5IDYuNzI1MjYgMTkuNTg1OSA3LjYwOTM4QzE5LjU4NTkgOC40MTYwMiAxOS43NzI4IDkuMDU0MDQgMjAuMTQ2NSA5LjUyMzQ0QzIwLjUyNDcgOS45ODgyOCAyMS4wMzA2IDEwLjIyMDcgMjEuNjY0MSAxMC4yMjA3QzIyLjI4ODQgMTAuMjIwNyAyMi43OTQzIDkuOTk1MTIgMjMuMTgxNiA5LjU0Mzk1QzIzLjU3MzYgOS4wOTI3NyAyMy43Njk1IDguNTIzMTEgMjMuNzY5NSA3LjgzNDk2Wk0zNy44MjQyIDEwLjU4OThDMzcuMDk5NiAxMC45NzI3IDM2LjE5NzMgMTEuMTY0MSAzNS4xMTcyIDExLjE2NDFDMzMuNzIyNyAxMS4xNjQxIDMyLjYwNjEgMTAuNzE1MiAzMS43Njc2IDkuODE3MzhDMzAuOTI5IDguOTE5NiAzMC41MDk4IDcuNzQxNTQgMzAuNTA5OCA2LjI4MzJDMzAuNTA5OCA0LjcxNTQ5IDMwLjk4MTQgMy40NDg1NyAzMS45MjQ4IDIuNDgyNDJDMzIuODY4MiAxLjUxNjI4IDM0LjA2NDUgMS4wMzMyIDM1LjUxMzcgMS4wMzMyQzM2LjQ0MzQgMS4wMzMyIDM3LjIxMzUgMS4xNjc2NCAzNy44MjQyIDEuNDM2NTJWMi42NjAxNkMzNy4xMjI0IDIuMjY4MjMgMzYuMzQ3NyAyLjA3MjI3IDM1LjUgMi4wNzIyN0MzNC4zNzQzIDIuMDcyMjcgMzMuNDYwNiAyLjQ0ODI0IDMyLjc1ODggMy4yMDAyQzMyLjA2MTUgMy45NTIxNSAzMS43MTI5IDQuOTU3MDMgMzEuNzEyOSA2LjIxNDg0QzMxLjcxMjkgNy40MDg4NSAzMi4wMzg3IDguMzYxMzMgMzIuNjkwNCA5LjA3MjI3QzMzLjM0NjcgOS43Nzg2NSAzNC4yMDU3IDEwLjEzMTggMzUuMjY3NiAxMC4xMzE4QzM2LjI1MiAxMC4xMzE4IDM3LjEwNDIgOS45MTMwOSAzNy44MjQyIDkuNDc1NTlWMTAuNTg5OFpNNDIuNTk1NyAxMS4xNjQxQzQxLjU2MTIgMTEuMTY0MSA0MC43MzQgMTAuODM4MiA0MC4xMTQzIDEwLjE4NjVDMzkuNDk5IDkuNTMwMjcgMzkuMTkxNCA4LjY2MjExIDM5LjE5MTQgNy41ODIwM0MzOS4xOTE0IDYuNDA2MjUgMzkuNTEyNyA1LjQ4Nzk2IDQwLjE1NTMgNC44MjcxNUM0MC43OTc5IDQuMTY2MzQgNDEuNjY2IDMuODM1OTQgNDIuNzU5OCAzLjgzNTk0QzQzLjgwMzQgMy44MzU5NCA0NC42MTY5IDQuMTU3MjMgNDUuMjAwMiA0Ljc5OThDNDUuNzg4MSA1LjQ0MjM4IDQ2LjA4MiA2LjMzMzMzIDQ2LjA4MiA3LjQ3MjY2QzQ2LjA4MiA4LjU4OTE5IDQ1Ljc2NTMgOS40ODQ3IDQ1LjEzMTggMTAuMTU5MkM0NC41MDI5IDEwLjgyOTEgNDMuNjU3NiAxMS4xNjQxIDQyLjU5NTcgMTEuMTY0MVpNNDIuNjc3NyA0Ljc3OTNDNDEuOTU3NyA0Ljc3OTMgNDEuMzg4IDUuMDI1MzkgNDAuOTY4OCA1LjUxNzU4QzQwLjU0OTUgNi4wMDUyMSA0MC4zMzk4IDYuNjc5NjkgNDAuMzM5OCA3LjU0MTAyQzQwLjMzOTggOC4zNzA0NCA0MC41NTE4IDkuMDI0NDEgNDAuOTc1NiA5LjUwMjkzQzQxLjM5OTQgOS45ODE0NSA0MS45NjY4IDEwLjIyMDcgNDIuNjc3NyAxMC4yMjA3QzQzLjQwMjMgMTAuMjIwNyA0My45NTgzIDkuOTg2IDQ0LjM0NTcgOS41MTY2QzQ0LjczNzYgOS4wNDcyIDQ0LjkzMzYgOC4zNzk1NiA0NC45MzM2IDcuNTEzNjdDNDQuOTMzNiA2LjYzODY3IDQ0LjczNzYgNS45NjQxOSA0NC4zNDU3IDUuNDkwMjNDNDMuOTU4MyA1LjAxNjI4IDQzLjQwMjMgNC43NzkzIDQyLjY3NzcgNC43NzkzWk01My42ODM2IDExSDUyLjU2MjVWNy4wMDc4MUM1Mi41NjI1IDUuNTIyMTQgNTIuMDIwMiA0Ljc3OTMgNTAuOTM1NSA0Ljc3OTNDNTAuMzc1IDQuNzc5MyA0OS45MTAyIDQuOTkxMjEgNDkuNTQxIDUuNDE1MDRDNDkuMTc2NCA1LjgzNDMxIDQ4Ljk5NDEgNi4zNjUyMyA0OC45OTQxIDcuMDA3ODFWMTFINDcuODczVjRINDguOTk0MVY1LjE2MjExSDQ5LjAyMTVDNDkuNTUwMSA0LjI3Nzk5IDUwLjMxNTggMy44MzU5NCA1MS4zMTg0IDMuODM1OTRDNTIuMDg0IDMuODM1OTQgNTIuNjY5NiA0LjA4NDMxIDUzLjA3NTIgNC41ODEwNUM1My40ODA4IDUuMDczMjQgNTMuNjgzNiA1Ljc4NjQ2IDUzLjY4MzYgNi43MjA3VjExWk01OS4wNDk4IDEwLjkzMTZDNTguNzg1NSAxMS4wNzc1IDU4LjQzNjggMTEuMTUwNCA1OC4wMDM5IDExLjE1MDRDNTYuNzc4IDExLjE1MDQgNTYuMTY1IDEwLjQ2NjggNTYuMTY1IDkuMDk5NjFWNC45NTcwM0g1NC45NjE5VjRINTYuMTY1VjIuMjkxMDJMNTcuMjg2MSAxLjkyODcxVjRINTkuMDQ5OFY0Ljk1NzAzSDU3LjI4NjFWOC45MDEzN0M1Ny4yODYxIDkuMzcwNzcgNTcuMzY1OSA5LjcwNTczIDU3LjUyNTQgOS45MDYyNUM1Ny42ODQ5IDEwLjEwNjggNTcuOTQ5MiAxMC4yMDcgNTguMzE4NCAxMC4yMDdDNTguNjAwOSAxMC4yMDcgNTguODQ0NyAxMC4xMjk2IDU5LjA0OTggOS45NzQ2MVYxMC45MzE2Wk02Ni4xNzI5IDcuNzgwMjdINjEuMjMwNUM2MS4yNDg3IDguNTU5NTcgNjEuNDU4MyA5LjE2MTEzIDYxLjg1OTQgOS41ODQ5NkM2Mi4yNjA0IDEwLjAwODggNjIuODExOCAxMC4yMjA3IDYzLjUxMzcgMTAuMjIwN0M2NC4zMDIxIDEwLjIyMDcgNjUuMDI2NyA5Ljk2MDk0IDY1LjY4NzUgOS40NDE0MVYxMC40OTQxQzY1LjA3MjMgMTAuOTQwOCA2NC4yNTg4IDExLjE2NDEgNjMuMjQ3MSAxMS4xNjQxQzYyLjI1ODEgMTEuMTY0MSA2MS40ODExIDEwLjg0NzMgNjAuOTE2IDEwLjIxMzlDNjAuMzUwOSA5LjU3NTg1IDYwLjA2ODQgOC42ODAzNCA2MC4wNjg0IDcuNTI3MzRDNjAuMDY4NCA2LjQzODE1IDYwLjM3NiA1LjU1MTc2IDYwLjk5MTIgNC44NjgxNkM2MS42MTEgNC4xODAwMSA2Mi4zNzg5IDMuODM1OTQgNjMuMjk0OSAzLjgzNTk0QzY0LjIxMDkgMy44MzU5NCA2NC45MTk2IDQuMTMyMTYgNjUuNDIwOSA0LjcyNDYxQzY1LjkyMjIgNS4zMTcwNiA2Ni4xNzI5IDYuMTM5NjUgNjYuMTcyOSA3LjE5MjM4VjcuNzgwMjdaTTY1LjAyNDQgNi44MzAwOEM2NS4wMTk5IDYuMTgyOTQgNjQuODYyNiA1LjY3OTM2IDY0LjU1MjcgNS4zMTkzNEM2NC4yNDc0IDQuOTU5MzEgNjMuODIxMyA0Ljc3OTMgNjMuMjc0NCA0Ljc3OTNDNjIuNzQ1OCA0Ljc3OTMgNjIuMjk2OSA0Ljk2ODQyIDYxLjkyNzcgNS4zNDY2OEM2MS41NTg2IDUuNzI0OTMgNjEuMzMwNyA2LjIxOTQgNjEuMjQ0MSA2LjgzMDA4SDY1LjAyNDRaTTczLjY4NTUgMTFINzIuNTY0NVY3LjAwNzgxQzcyLjU2NDUgNS41MjIxNCA3Mi4wMjIxIDQuNzc5MyA3MC45Mzc1IDQuNzc5M0M3MC4zNzcgNC43NzkzIDY5LjkxMjEgNC45OTEyMSA2OS41NDMgNS40MTUwNEM2OS4xNzg0IDUuODM0MzEgNjguOTk2MSA2LjM2NTIzIDY4Ljk5NjEgNy4wMDc4MVYxMUg2Ny44NzVWNEg2OC45OTYxVjUuMTYyMTFINjkuMDIzNEM2OS41NTIxIDQuMjc3OTkgNzAuMzE3NyAzLjgzNTk0IDcxLjMyMDMgMy44MzU5NEM3Mi4wODU5IDMuODM1OTQgNzIuNjcxNSA0LjA4NDMxIDczLjA3NzEgNC41ODEwNUM3My40ODI3IDUuMDczMjQgNzMuNjg1NSA1Ljc4NjQ2IDczLjY4NTUgNi43MjA3VjExWk03OS4wNTE4IDEwLjkzMTZDNzguNzg3NCAxMS4wNzc1IDc4LjQzODggMTEuMTUwNCA3OC4wMDU5IDExLjE1MDRDNzYuNzc5OSAxMS4xNTA0IDc2LjE2NyAxMC40NjY4IDc2LjE2NyA5LjA5OTYxVjQuOTU3MDNINzQuOTYzOVY0SDc2LjE2N1YyLjI5MTAyTDc3LjI4ODEgMS45Mjg3MVY0SDc5LjA1MThWNC45NTcwM0g3Ny4yODgxVjguOTAxMzdDNzcuMjg4MSA5LjM3MDc3IDc3LjM2NzggOS43MDU3MyA3Ny41MjczIDkuOTA2MjVDNzcuNjg2OCAxMC4xMDY4IDc3Ljk1MTIgMTAuMjA3IDc4LjMyMDMgMTAuMjA3Qzc4LjYwMjkgMTAuMjA3IDc4Ljg0NjcgMTAuMTI5NiA3OS4wNTE4IDkuOTc0NjFWMTAuOTMxNloiIGZpbGw9IiMwMDdBRkYiLz4KCiAgICA8L2c+Cjwvc3ZnPg==");
    background-size: contain;
    background-repeat: no-repeat;
}

.dropzone.${SmallEmptyClass}:empty::after,
.structure-dropzone.${SmallEmptyClass}.rock-:empty::after {
    background-image: url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTUiIGhlaWdodD0iMTUiIHZpZXdCb3g9IjAgMCAxNSAxNSIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzMwMDdfMzIzMzQpIj4KPHBhdGggZD0iTTcuNSAwLjcxODc1QzMuNzUzOTEgMC43MTg3NSAwLjcxODc1IDMuNzUzOTEgMC43MTg3NSA3LjVDMC43MTg3NSAxMS4yNDYxIDMuNzUzOTEgMTQuMjgxMiA3LjUgMTQuMjgxMkMxMS4yNDYxIDE0LjI4MTIgMTQuMjgxMiAxMS4yNDYxIDE0LjI4MTIgNy41QzE0LjI4MTIgMy43NTM5MSAxMS4yNDYxIDAuNzE4NzUgNy41IDAuNzE4NzVaTTExLjQzNzUgOC4yNjU2MkMxMS40Mzc1IDguNDQ2MDkgMTEuMjg5OCA4LjU5Mzc1IDExLjEwOTQgOC41OTM3NUg4LjU5Mzc1VjExLjEwOTRDOC41OTM3NSAxMS4yODk4IDguNDQ2MDkgMTEuNDM3NSA4LjI2NTYyIDExLjQzNzVINi43MzQzOEM2LjU1MzkxIDExLjQzNzUgNi40MDYyNSAxMS4yODk4IDYuNDA2MjUgMTEuMTA5NFY4LjU5Mzc1SDMuODkwNjJDMy43MTAxNiA4LjU5Mzc1IDMuNTYyNSA4LjQ0NjA5IDMuNTYyNSA4LjI2NTYyVjYuNzM0MzhDMy41NjI1IDYuNTUzOTEgMy43MTAxNiA2LjQwNjI1IDMuODkwNjIgNi40MDYyNUg2LjQwNjI1VjMuODkwNjJDNi40MDYyNSAzLjcxMDE2IDYuNTUzOTEgMy41NjI1IDYuNzM0MzggMy41NjI1SDguMjY1NjJDOC40NDYwOSAzLjU2MjUgOC41OTM3NSAzLjcxMDE2IDguNTkzNzUgMy44OTA2MlY2LjQwNjI1SDExLjEwOTRDMTEuMjg5OCA2LjQwNjI1IDExLjQzNzUgNi41NTM5MSAxMS40Mzc1IDYuNzM0MzhWOC4yNjU2MloiIGZpbGw9IiMwMDdBRkYiLz4KPC9nPgo8ZGVmcz4KPGNsaXBQYXRoIGlkPSJjbGlwMF8zMDA3XzMyMzM0Ij4KPHJlY3Qgd2lkdGg9IjE0IiBoZWlnaHQ9IjE0IiBmaWxsPSJ3aGl0ZSIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC41IDAuNSkiLz4KPC9jbGlwUGF0aD4KPC9kZWZzPgo8L3N2Zz4K");
    width: 15px; /* Match SVG width */
}

[contenteditable=true]:focus {
    cursor: text;
}

/* Ensure the iframe wrapper style is reset properly */
#email-iframe-wrapper {
    position: relative;
}

/* Use overflow hidden to include margins in the hover outline. */
.rock-runtime-wrapper-element,
.component {
    overflow: hidden;
    cursor: pointer;
}

/* Use position relative so hover labels can be absolutely positioned. */
.rock-runtime-wrapper-element {
    position: relative;
}

/* Add outline to components when hovered or selected to help differentiate them from other components. */
body:not(.${draggingCssClass}) .rock-runtime-wrapper-element.selected,
body:not(.${draggingCssClass}) .rock-runtime-wrapper-element:hover {
    /* Use outline so the box sizing isn't affected. */
    outline: 1px solid var(--color-info-strong);
    outline-offset: -1px;

    box-shadow: inset 0 0 0 1000px rgba(0, 0, 150, .2);
    transition: box-shadow 0.3s;
}

/* Hover labels to help individuals select the correct component. */
body:not(.${draggingCssClass}) .rock-runtime-wrapper-element:hover::after,
body:not(.${draggingCssClass}) .rock-runtime-wrapper-element.selected::after {
    /* Override this for each component. */
    content: '';

    /* Place component hover labels on the bottom right */
    position: absolute;
    right: 0;
    bottom: 0;
    background-color: var(--color-info-strong);
    padding: var(--spacing-tiny);
    color: white;
    font-family: sans-serif;
    font-size: var(--font-size-xsmall);

    border-radius: 4px 0 0 0;
    padding-left: 6px;
    padding-top: 6px;
}

body:not(.${draggingCssClass}) .rock-runtime-wrapper-element.for-component-title:hover::after,
body:not(.${draggingCssClass}) .rock-runtime-wrapper-element.for-component-title.selected::after {
    content: 'Title';
}

body:not(.${draggingCssClass}) .rock-runtime-wrapper-element.for-component-text:hover::after,
body:not(.${draggingCssClass}) .rock-runtime-wrapper-element.for-component-text.selected::after {
    content: 'Paragraph';
}

body:not(.${draggingCssClass}) .rock-runtime-wrapper-element.for-component-image:hover::after,
body:not(.${draggingCssClass}) .rock-runtime-wrapper-element.for-component-image.selected::after {
    content: 'Image';
}

body:not(.${draggingCssClass}) .rock-runtime-wrapper-element.for-component-video:hover::after,
body:not(.${draggingCssClass}) .rock-runtime-wrapper-element.for-component-video.selected::after {
    content: 'Video';
}

body:not(.${draggingCssClass}) .rock-runtime-wrapper-element.for-component-divider:hover::after,
body:not(.${draggingCssClass}) .rock-runtime-wrapper-element.for-component-divider.selected::after {
    content: 'Divider';
}

body:not(.${draggingCssClass}) .rock-runtime-wrapper-element.for-component-code:hover::after,
body:not(.${draggingCssClass}) .rock-runtime-wrapper-element.for-component-code.selected::after {
    content: 'Lava';
}

body:not(.${draggingCssClass}) .rock-runtime-wrapper-element.for-component-button:hover::after,
body:not(.${draggingCssClass}) .rock-runtime-wrapper-element.for-component-button.selected::after {
    content: 'Button';
}

body:not(.${draggingCssClass}) .rock-runtime-wrapper-element.for-component-message:hover::after,
body:not(.${draggingCssClass}) .rock-runtime-wrapper-element.for-component-message.selected::after {
    content: 'Message';
}

body:not(.${draggingCssClass}) .rock-runtime-wrapper-element.for-component-rsvp:hover::after,
body:not(.${draggingCssClass}) .rock-runtime-wrapper-element.for-component-rsvp.selected::after {
    content: 'RSVP';
}

body:not(.${draggingCssClass}) .rock-runtime-wrapper-element.for-component-section:not(.selected):hover::after,
body:not(.${draggingCssClass}) .rock-runtime-wrapper-element.for-component-section.selected::after {
    content: 'Layout';

    border-radius: 0 0 0 4px;

    /* Display section component hover label at the top. */
    top: 0;
    bottom: initial;
}

.component-placeholder-container {
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 2px 0;
}

.component-placeholder-line {
    flex-grow: 1;
    height: 3px;
    background-color: var(--color-info-strong);
}

.component-placeholder-pill {
    background-color: var(--color-info-strong);
    color: #ffffff;
    padding: 4px 18px;
    font-size: 10px;
    border-radius: 9999px;
    pointer-events: none;
    line-height: 1;
}
`;
        iFrameDocument.head.appendChild(style);

        // If the body does not contain a structure-dropzone, then add one automatically.
        if (!iFrameDocument.querySelector(".structure-dropzone")) {
            const dropzone = iFrameDocument.createElement("div");
            dropzone.classList.add("structure-dropzone");
            iFrameDocument.body.append(dropzone);
        }

        // Auto-select the first component with the "selected" CSS class.
        for (const [element, index] of Enumerable.from(iFrameDocument.querySelectorAll(".component.selected")).ofType(isHTMLElement).withIndex()) {
            if (index === 0) {
                selectComponent(element);
            }
            else {
                deselectComponentElement(element);
            }
        }

        removeWhiteSpaceFromChildElements(iFrameDocument, ".structure-dropzone, .dropzone");

        fixOldWizardElements(iFrameDocument);

        applyDefaultGlobalStylesIfNeeded(iFrameDocument);

        emailDocument.value = iFrameDocument;

        // Create a MutationObserver to watch for changes inside each wrapper
        wrapperAutoRemovalObserver.value?.disconnect();
        wrapperAutoRemovalObserver.value = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
                const wrapper = mutation.target as HTMLElement;

                // If the wrapper has no more (non-runtime) children, remove it.
                if (wrapper) {
                    const childrenWithoutRuntime = Array.from(wrapper.children).filter(
                        (child) => !child.classList.contains(RockRuntimeElementCssClass)
                    );

                    if (childrenWithoutRuntime.length === 0) {
                        wrapper.remove();
                    }
                }
            });
        });

        dropzoneEmptyResizeObserver.value?.disconnect();
        dropzoneEmptyResizeObserver.value = new ResizeObserver((entries) => {
            Enumerable.from(entries)
                .select(entry => entry.target)
                .ofType(isHTMLElement)
                .where(e => e.classList.contains("dropzone"))
                .forEach(dropzone => {
                    checkDropzoneSize(dropzone.getBoundingClientRect(), dropzone);
                });
        });

        // Check dropzone sizes immediately.
        sectionComponentMutationObserver.value?.disconnect();
        sectionComponentMutationObserver.value = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
                if (mutation.type === "childList") {
                    Enumerable.from(mutation.addedNodes)
                        .ofType(isHTMLElement)
                        .where(e => e.classList.contains("dropzone"))
                        .forEach(dropzone => {
                            watchSectionComponentDropzoneSizeChanges(dropzone);
                        });

                    Enumerable.from(mutation.removedNodes)
                        .ofType(isHTMLElement)
                        .where(e => e.classList.contains("dropzone"))
                        .forEach(e => {
                            // Stop watching for size changes.
                            dropzoneEmptyResizeObserver.value?.unobserve(e);
                        });
                }
            });
        });

        // Wrap component elements to give them runtime styling.
        wrapComponentElements(iFrameDocument);

        // Finally, let other components know the document was updated.
        emit("emailDocumentUpdated", iFrameDocument);
    }



    function applyDefaultGlobalStylesIfNeeded(iFrameDocument: Document): void {
        // Add default style sheet if it doesn't exist.
        if (!iFrameDocument.querySelector(`style.${RockStylesCssClass}`)) {
            const styleElement = iFrameDocument.createElement("style");
            styleElement.classList.add(RockStylesCssClass);

            // Notes:
            //  - Only global styles should be added here.
            //  - Only add non-editable styles as necessary.
            //  - The ruleset selectors AND properties must match the editable properties in the Global property panel.
            //  - Component-level style defaults are maintained in the utils.partial.obs file.
            styleElement.textContent = `
/* Non-editable global styles */
html, body {
    /* Remove client-specific spacing around root elements. */
    margin: 0;
    padding: 0;
}

/* Global Styles - Body Settings */
.rock-body-inner-container {
    /* Body Width */
    max-width: ${DefaultBodyWidth}px;

    /* Body Color */
    background-color: #ffffff;

    /* Padding */
    padding: 24px;
}

/* Global Styles - Background Settings */
html {
    /* Background Color */
    background-color: #e7e7e7;
}

/* Global Styles - Text Styling - Global */
body {
    font-family: Arial;
    font-size: 16px;
    color: #364153;

    /* Line Height "Normal" */
    line-height: 1.5;
}

/* Global Styles - Text Styling - Heading 1 */
.component-title h1 {
    font-family: Arial;
    font-size: 38px;
    color: #030712;
    font-weight: bold;

    /* Line Height "Tight" */
    line-height: 1.2;

    margin: 0;
}

/* Global Styles - Text Styling - Heading 2 */
.component-title h2 {
    font-family: Arial;
    font-size: 30px;
    color: #030712;
    font-weight: bold;

    /* Line Height "Tight" */
    line-height: 1.2;

    margin: 0;
}

/* Global Styles - Text Styling - Heading 3 */
.component-title h3 {
    font-family: Arial;
    font-size: 24px;
    color: #030712;
    font-weight: bold;

    /* Line Height "Tight" */
    line-height: 1.2;

    margin: 0;
}

/* Global Styles - Text Styling - Paragraph */
.component-text {
    font-family: Arial;
    font-size: 16px;
    color: #364153;
    font-weight: bold;

    /* Line Height "Tight" */
    line-height: 1.2;

    margin: 0;
}

/* Global Styles - Button Styling */
.component-button .button-link {
    /* Non-editable properties */
    text-align: center;
    letter-spacing: normal;
    box-sizing: border-box;

    /* Background Color */
    background-color: #3976f6;

    font-family: Arial;
    font-weight: bold;
    text-decoration: none;

    /* Line Height "Tight" */
    line-height: 1.2;

    /* Text Color */
    color: #ffffff;

    /* Padding */
    padding: 15px;
}
.component-button .button-content,
.component-button .button-link {
    /* Corner Radius */
    border-radius: 4px;
}

/* Global Styles - Divider Styling */
.component-divider hr {
    /* Style */
    border-style: solid none none;

    /* Thickness */
    border-width: 1px 0px 0px;

    /* Color */
    border-color: #8b8ba7 transparent transparent;

    /* Divider Width */
    width: 100%;

    /* Padding */
    margin: 12px 0;
}`;
            iFrameDocument.body.append(styleElement);
        }

        // Apply other defaults.
        const bodyWidthProvider = applyDefaultValueToProvider(
            createBodyWidthProvider(iFrameDocument.body as HTMLBodyElement),
            DefaultBodyWidth
        );

        const bodyAlignmentProvider = applyDefaultValueToProvider(
            contentAlignmentProvider(iFrameDocument.body),
            DefaultBodyAlignment
        );

        // Allow the providers to respond to the default value changes, then dispose.
        nextTick(() => {
            bodyWidthProvider.dispose();
            bodyAlignmentProvider.dispose();
        });
    }

    function getComponentFromMouseEvent(event: MouseEvent): { componentElement: HTMLElement | null, componentWrapperElement: HTMLElement | null } {
        const targetElement = event.target as HTMLElement | null;

        const closestComponentElement = targetElement?.closest(".component[data-state='component']") as HTMLElement | null;
        const closestWrappedComponentElement = targetElement?.closest(".rock-runtime-wrapper-element")?.querySelector(".component[data-state='component']") as HTMLElement | null;

        let componentElement: HTMLElement | null = null;

        // Choose the most descendant component element.
        if (closestComponentElement && closestWrappedComponentElement) {
            if (closestComponentElement.contains(closestWrappedComponentElement)) {
                componentElement = closestWrappedComponentElement;
            }
            else if (closestWrappedComponentElement.contains(closestComponentElement)) {
                componentElement = closestComponentElement;
            }
        }

        if (!componentElement) {
            componentElement = closestComponentElement ?? closestWrappedComponentElement;
        }

        return {
            componentElement: componentElement,
            componentWrapperElement: componentElement?.parentElement?.classList.contains(RockRuntimeWrapperElementCssClass) ? componentElement.parentElement : null
        };
    }

    function onIFrameClick(event: MouseEvent): void {
        console.log(`"click" iframe`);

        // Prevent default browser behavior so links and buttons aren't executed.
        event.preventDefault();

        const { componentElement } = getComponentFromMouseEvent(event);

        if (componentElement) {
            // Select the new component.
            selectComponent(componentElement);
        }
        else {
            // Deselect the currently selected component when anything else in the iframe is clicked.
            internalSelectedComponentElement.value = null;
        }
    }

    /**
     * Checks if a component element or one of its descendants is being edited inline.
     * @param componentElement
     */
    function isComponentBeingEditedInline(componentElement: HTMLElement, activeElementOverride?: Element | null | undefined): boolean {
        const activeElement = activeElementOverride ?? componentElement.ownerDocument.activeElement;

        return (activeElement?.getAttribute("contenteditable") === "true" || componentElement.getAttribute("contenteditable") === "true")
            && (activeElement === componentElement || componentElement.contains(activeElement));
    }

    function onIFrameKeyDownEscape(event: KeyboardEvent): void {
        if (event.key === "Escape") {
            console.debug("onIFrameKeyDownEscape");
            internalSelectedComponentElement.value = null;
        }
    }

    function onIFrameKeyDownDelete(event: KeyboardEvent): void {
        if (event.key === "Delete") {
            console.debug("onIFrameKeyDownDelete");
            // Do not delete if currently inline editing.
            if (internalSelectedComponentElement.value && !isComponentBeingEditedInline(internalSelectedComponentElement.value)) {
                deleteSelectedComponent();
            }
        }
    }

    function getComponentElement(element: HTMLElement): HTMLElement | null {
        if (element.classList.contains("component")) {
            return element;
        }
        else if (element.classList.contains(RockRuntimeWrapperElementCssClass)) {
            return element.children.item(0) as HTMLElement ?? null;
        }
        else {
            return null;
        }
    }

    /**
     * Handles the mouse being down within the editor iframe.
     *
     * This will enable dragging behavior
     */
    function onIFrameComponentMouseDown(event: MouseEvent): void {
        console.log(`"mousedown" iframe component`);

        if (event.button !== 0) {
            // Only handle left mouse button events.
            return;
        }

        if (!iFrameElement.value?.contentWindow || !iFrameElement.value.contentDocument) {
            throw new Error("iframe: Unable to handle component 'mousedown' event. The iframe document has not been initialized");
        }

        const { componentElement, componentWrapperElement } = getComponentFromMouseEvent(event);

        if (componentElement) {
            const activeElementOverride = isHTMLElement(event.target) ? event.target : null;

            if (isComponentBeingEditedInline(componentElement, activeElementOverride)) {
                // The individual is editing a content editable element, so stop processing.
                console.debug(`"mousedown" inline editing; stopping early`);
                return;
            }
            else {
                // The individual is dragging a component.
                console.debug(`"mousedown" on component; readying drag`);

                // Prevent the browser from selecting text as the individual holds the mouse button down.
                event.preventDefault();

                componentElement.focus();

                dragCursorX.value = event.clientX;
                dragCursorY.value = event.clientY;

                // Enable dragging for the component element.
                iFrameElement.value.contentWindow.removeEventListener("mousemove", onIFrameComponentMouseMove);
                iFrameElement.value.contentWindow.addEventListener("mousemove", onIFrameComponentMouseMove);
                iFrameElement.value.contentWindow.removeEventListener("mouseup", onIFrameComponentMouseUp);
                iFrameElement.value.contentWindow.addEventListener("mouseup", onIFrameComponentMouseUp);

                //componentElement.setAttribute("draggable", "true");
                console.log("dragging component", componentElement);

                if (componentWrapperElement) {
                    // The component element has a wrapper that should also be moved.
                    draggingElement.value = componentWrapperElement;
                }
                else {
                    // Just move the component element.
                    draggingElement.value = componentElement;
                }

                draggingPlaceholderElement.value = createComponentElementPlaceholder(iFrameElement.value.contentDocument);
            }
        }
    }

    function onIFrameComponentMouseUp(_event: MouseEvent): void {
        console.log(`"mouseup" iframe component`);

        if (draggingPlaceholderElement.value && draggingElement.value) {
            if (draggingPlaceholderElement.value.parentElement) {
                if (draggingElement.value.nextSibling === draggingPlaceholderElement.value) {
                    // The component is being dragged over itself. Instead of dropping it, just select it.
                    const componentElement = getComponentElement(draggingElement.value);
                    if (componentElement) {
                        selectComponent(componentElement);
                    }
                }
                else {
                    console.log(`"dragend" iframe component - placeholder replaced with component`, draggingElement.value);
                    // Swap the placeholder element with the permanent element.
                    draggingPlaceholderElement.value.replaceWith(draggingElement.value);
                }
            }
            else if (emptySectionElementToBeAddedTo.value) {
                console.log(`"dragend" iframe component - component added to empty section`, draggingElement.value);
                // Put the permanent element in the empty section being dragged over.
                emptySectionElementToBeAddedTo.value.appendChild(draggingElement.value);
            }
        }

        // When dragging is finished, remove the "draggable" attribute from the
        // component so it isn't left draggable in the resulting email content.
        // Also remove drag event listeners on the component element.
        iFrameElement.value?.contentWindow?.removeEventListener("mousemove", onIFrameComponentMouseMove);
        iFrameElement.value?.contentWindow?.removeEventListener("mouseup", onIFrameComponentMouseUp);

        // Clean up.
        hidePlaceholderAndRemoveEmptySectionHighlight();
        draggingPlaceholderElement.value = null;
        draggingElement.value = null;
    }

    function onIFrameComponentTypeDragStart(componentTypeName: EditorComponentTypeName, customHtml?: string | null | undefined): void {
        console.log(`"dragstart" iframe component type`);

        const iFrameDocument = iFrameElement.value?.contentDocument;
        if (!iFrameDocument) {
            throw "iframe: Unable to handle 'dragstart' event. The iframe document has not been initialized.";
        }

        if (customHtml) {
            const tempElement = iFrameDocument.createElement("div");
            tempElement.innerHTML = customHtml;
            draggingElement.value = tempElement.firstElementChild as HTMLElement;
        }
        else {
            draggingElement.value = createComponentElement(iFrameDocument, componentTypeName);
        }

        removeWhiteSpaceFromChildElements(draggingElement.value, ".structure-dropzone, .dropzone");

        // Wrap the component element for runtime styling.
        draggingElement.value = wrapComponentElement(iFrameDocument, draggingElement.value);

        // Wrap its children just in case a saved email section is dropped.
        wrapComponentElements(draggingElement.value);

        draggingPlaceholderElement.value = createComponentElementPlaceholder(iFrameDocument);
    }

    function onIFrameComponentMouseMove(e: MouseEvent): void {
        console.log(`"mousemove" iframe component`);

        if (!iFrameElement.value?.contentDocument) {
            throw "iframe: Unable to handle component 'dragover' event. The iframe document has not been initialized";
        }

        if (!draggingElement.value || !draggingPlaceholderElement.value) {
            // Nothing is being dragged so return early.
            return;
        }

        // Auto-scroll the iframe if the cursor is within
        // the scroll trigger distance.
        const scrollTriggerDistance = 40;
        const iframeRect = iFrameElement.value.getBoundingClientRect();
        if (e.clientY < scrollTriggerDistance) {
            iFrameElement.value.contentWindow?.scrollBy({
                top: -scrollTriggerDistance,
                behavior: "smooth"
            });
        }
        else if (e.clientY > (iframeRect.height - scrollTriggerDistance)) {
            iFrameElement.value.contentWindow?.scrollBy({
                top: scrollTriggerDistance,
                behavior: "smooth"
            });
        }
        else if (dragCursorX.value === e.clientX && dragCursorY.value === e.clientY) {
            // The cursor is idle and not near the top or bottom edge of the iframe.
            return;
        }

        dragCursorX.value = e.clientX;
        dragCursorY.value = e.clientY;

        // This handler will place the current component element
        // either before or after the element being hovered over.

        function tryHandleDrag(placeholderElement: HTMLElement, draggedOverElement: HTMLElement): boolean {
            if (draggedOverElement === draggingElement.value) {
                // Skip if the component is being dragged over itself.
                hidePlaceholderAndRemoveEmptySectionHighlight();
                return true;
            }

            if (draggingElement.value?.contains(draggedOverElement)) {
                // Skip if the component is being dragged over it's own child element.
                hidePlaceholderAndRemoveEmptySectionHighlight();
                return true;
            }

            if (draggedOverElement.matches(".dropzone, .structure-dropzone")) {
                for (const child of draggedOverElement.children) {
                    const childElement = child as HTMLElement;

                    if (childElement && e.clientY < childElement.getBoundingClientRect().top) {
                        const oldParentElement = placeholderElement.parentElement;

                        showPlaceholderBefore(childElement);
                        //draggedOverElement.insertBefore(draggingComponentElement.value, childElement);

                        if (oldParentElement && oldParentElement !== placeholderElement.parentElement) {
                            removeWhiteSpaceFromElement(oldParentElement);
                        }

                        return true;
                    }
                }

                if (!draggedOverElement.children.length) {
                    // The new component is being dragged over an empty section element,
                    // so highlight the section instead of moving the placeholder.
                    highlightEmptySection(draggedOverElement);
                    return true;
                }
                else {
                    // The new component is being dragged over a non-empty section and not over any
                    // other components, so move the placeholder to the end of the section.
                    showPlaceholderAsLastChildOf(draggedOverElement);
                    return true;
                }
            }
            else if (draggedOverElement.parentElement?.matches(".dropzone, .structure-dropzone")) {
                const draggedOverElementTop = draggedOverElement.getBoundingClientRect().top;
                const draggedOverElementMidpointY = (draggedOverElement.offsetHeight / 2) + draggedOverElementTop;

                const oldParentElement = placeholderElement.parentElement;

                // If the current mouse position is less than this midpoint,
                // then the new element should be placed before it.
                if (e.clientY < draggedOverElementMidpointY) {
                    showPlaceholderBefore(draggedOverElement);
                    //draggedOverElement.parentElement.insertBefore(draggingComponentElement.value, draggedOverElement);
                }
                // ... otherwise, the new element should be placed after it.
                else {
                    showPlaceholderAfter(draggedOverElement);
                    //draggedOverElement.parentElement.insertBefore(draggingComponentElement.value, draggedOverElement.nextSibling);
                }

                if (oldParentElement && oldParentElement !== placeholderElement.parentElement) {
                    removeWhiteSpaceFromElement(oldParentElement);
                }

                return true;
            }
            else {
                // Leave the element alone.
            }

            return false;
        }

        const draggedOverElements = Enumerable
            .from(iFrameElement.value.contentDocument.elementsFromPoint(e.clientX, e.clientY) ?? [])
            .ofType(isHTMLElement);

        // Find the first hovered-over element whose parent is a dropzone,
        // and move the placeholder either before or after it.
        // FYI, elementsOver is sorted from descendant element to ancestor element.
        for (const draggedOverElement of draggedOverElements) {
            if (tryHandleDrag(draggingPlaceholderElement.value, draggedOverElement)) {
                // Stop once drag is handled.
                return;
            }
        }

        // If here, then the element is not being dragged over any dropzones.
        // Try to find the first dropzone directly beneath or above the current position.
        const { element: closestElement, isAbove, isBelow } = findNearestIFrameElementFromPoint(
            iFrameElement.value,
            e.clientX,
            e.clientY,
            ".dropzone",
            // Search vertically within 10 pixels of the current position.
            0,
            10
        );

        if (closestElement) {
            const ancestorDropzone = closestElement.parentElement?.closest(".dropzone, .structure-dropzone");

            // Place before the closest dropzone.
            // This requires finding the ancestor dropzone first.
            if (isHTMLElement(ancestorDropzone)) {
                const ancestorDropzoneChild = findDirectChildContaining(ancestorDropzone, closestElement);

                if (ancestorDropzoneChild) {
                    if (isBelow) {
                        showPlaceholderBefore(ancestorDropzoneChild);
                    }
                    else if (isAbove) {
                        showPlaceholderAfter(ancestorDropzoneChild);
                    }
                }
            }
        }
    }

    function onIFrameComponentTypeDragOver(message: ComponentTypeDragOverMessage): void {
        console.log(`"dragover" iframe component type`);

        if (!iFrameElement.value?.contentDocument) {
            throw "iframe: Unable to handle 'dragover' event. The iframe document has not been initialized.";
        }

        if (!draggingPlaceholderElement.value) {
            // Nothing is being dragged so return early.
            return;
        }

        // Auto-scroll the iframe if the cursor is within
        // the scroll trigger distance.
        const scrollTriggerDistance = 40;
        const iframeRect = iFrameElement.value.getBoundingClientRect();
        if (message.clientY < scrollTriggerDistance) {
            iFrameElement.value.contentWindow?.scrollBy({
                top: -scrollTriggerDistance,
                behavior: "smooth"
            });
        }
        else if (message.clientY > (iframeRect.height - scrollTriggerDistance)) {
            iFrameElement.value.contentWindow?.scrollBy({
                top: scrollTriggerDistance,
                behavior: "smooth"
            });
        }
        else if (dragCursorX.value === message.clientX && dragCursorY.value === message.clientY) {
            // The cursor is idle and not near the top or bottom edge of the iframe.
            return;
        }

        // Keep track of dragging coordinates so the 'dragover' event is only handled
        // when dragging the component (does not execute if the dragged component is stationary).
        dragCursorX.value = message.clientX;
        dragCursorY.value = message.clientY;

        // This handler will place the current component type's placeholder element
        // either before or after the element being hovered over.

        const elementsOver = (iFrameElement.value.contentDocument.elementsFromPoint(message.clientX, message.clientY) ?? []) as HTMLElement[];

        // Find the first hovered-over element whose parent is a dropzone,
        // and move the placeholder either before or after it.
        // FYI, elementsOver is sorted from descendant element to ancestor element.
        for (const elementOver of elementsOver) {
            if (elementOver.matches(".dropzone, .structure-dropzone")) {
                for (const child of elementOver.children) {
                    const childElement = child as HTMLElement;

                    if (childElement && message.clientY < childElement.getBoundingClientRect().top) {
                        // The new component is being dragged above this element's center,
                        // so show the placeholder before it.
                        showPlaceholderBefore(childElement);
                        return;
                    }
                }

                if (!elementOver.children.length) {
                    // The new component is being dragged over an empty section element,
                    // so highlight the section instead of moving the placeholder.
                    highlightEmptySection(elementOver);
                    return;
                }
                else {
                    // The new component is being dragged over a non-empty section and not over any
                    // other components, so move the placeholder to the end of the section.
                    showPlaceholderAsLastChildOf(elementOver);
                    return;
                }
            }
            else if (elementOver.parentElement?.matches(".dropzone, .structure-dropzone")) {
                const topOfHoveredElement = elementOver.getBoundingClientRect().top;
                const elementOverMidpointY = (elementOver.offsetHeight / 2) + topOfHoveredElement;

                // If the current mouse position is less than this midpoint,
                // then the new element should be placed before it.
                if (message.clientY < elementOverMidpointY) {
                    showPlaceholderBefore(elementOver);
                    return;
                }
                // ... otherwise, the new element should be placed after it.
                else {
                    showPlaceholderAfter(elementOver);
                    return;
                }
            }
        }

        // If here, then the element is not being dragged over any dropzones.
        // Try to find the first dropzone directly beneath or above the current position.
        const { element: closestElement, isAbove, isBelow } = findNearestIFrameElementFromPoint(
            iFrameElement.value,
            message.clientX,
            message.clientY,
            ".dropzone",
            // Search vertically within 10 pixels of the current position.
            0,
            10);
        if (closestElement) {
            const ancestorDropzone = closestElement.parentElement?.closest(".dropzone, .structure-dropzone");

            // Place before the closest dropzone.
            // This requires finding the ancestor dropzone first.
            if (isHTMLElement(ancestorDropzone)) {
                const ancestorDropzoneChild = findDirectChildContaining(ancestorDropzone, closestElement);

                if (ancestorDropzoneChild) {
                    if (isBelow) {
                        showPlaceholderBefore(ancestorDropzoneChild);
                        return;
                    }
                    else if (isAbove) {
                        showPlaceholderAfter(ancestorDropzoneChild);
                        return;
                    }
                }
            }
        }

        // The component isn't being dragged over a drop target,
        // so hide the place holder and remove empty section highlighting.
        hidePlaceholderAndRemoveEmptySectionHighlight();
    }

    function onIFrameComponentTypeDragEnd(): void {
        console.log(`"dragend" iframe component type`);

        // If "dragend" happens and there was never a "drop",
        // then remove the temporary dragging element from the DOM.
        if (draggingPlaceholderElement.value) {
            draggingPlaceholderElement.value.remove();
            draggingPlaceholderElement.value = null;
        }
    }

    function onIFrameComponentTypeDragLeave(): void {
        console.log(`"dragleave" iframe component type`);

        // If "dragleave" happens then remove the temporary dragging element from the DOM.
        if (draggingPlaceholderElement.value) {
            draggingPlaceholderElement.value.remove();
        }
    }

    function onIFrameComponentTypeDragDrop(): void {
        console.log(`"drop" iframe component type`);

        const iFrameDocument = iFrameElement.value?.contentDocument;
        if (!iFrameDocument) {
            throw "iframe: Unable to handle 'drop' event. The iframe document has not been initialized.";
        }

        if (draggingPlaceholderElement.value && draggingElement.value) {
            if (draggingPlaceholderElement.value.parentElement) {
                // Swap the placeholder element with the permanent element.
                draggingPlaceholderElement.value.replaceWith(draggingElement.value);
            }
            else if (emptySectionElementToBeAddedTo.value) {
                // Put the permanent element in the empty section being dragged over.
                emptySectionElementToBeAddedTo.value.appendChild(draggingElement.value);
            }
        }

        draggingElement.value = null;

        // Clean up.

        if (draggingPlaceholderElement.value) {
            // Clear the placeholder element (it has already been removed from the DOM when it was replaced with the real component element).
            draggingPlaceholderElement.value = null;
        }

        if (emptySectionElementToBeAddedTo.value) {
            // Clear the empty section being dragged over.
            emptySectionElementToBeAddedTo.value.classList.remove("component-type-over");
            emptySectionElementToBeAddedTo.value = null;
        }
    }

    /**
     * Handles all messages communicated from the parent window to the editor iframe,
     * such as components or sections being dragged from the toolbox to the editor.
     */
    function onIFrameMessageReceived(event: MessageEvent<
        ComponentTypeDragStartMessage
        | ComponentTypeDragDropMessage
        | ComponentTypeDragOverMessage
        | ComponentTypeDragLeaveMessage
        | ComponentTypeDragEndMessage>): void {
        console.log(`"message" iframe`);

        switch (event.data.type) {
            case "COMPONENT_TYPE_DRAG_START":
                onIFrameComponentTypeDragStart(event.data.componentTypeName, event.data.customHtml);
                break;

            case "COMPONENT_TYPE_DRAG_OVER":
                onIFrameComponentTypeDragOver(event.data);
                break;

            case "COMPONENT_TYPE_DRAG_LEAVE":
                onIFrameComponentTypeDragLeave();
                break;

            case "COMPONENT_TYPE_DRAG_DROP":
                onIFrameComponentTypeDragDrop();
                break;

            case "COMPONENT_TYPE_DRAG_END":
                onIFrameComponentTypeDragEnd();
                break;
        }
    }

    // #endregion Event Handlers - Child IFrame

    // #region Watchers

    watch(iFrameElement, (newIFrame, oldIFrame) => {
        if (oldIFrame) {
            removeEventHandlers(oldIFrame);
        }

        if (newIFrame) {
            nextTick(() => {
                addEventHandlers(newIFrame);
            });
        }
    });

    // Side-effects from changing the selected component element.
    watch(internalSelectedComponentElement, (newSelectedComponentElement, oldSelectedComponentElement) => {
        if (oldSelectedComponentElement && newSelectedComponentElement !== oldSelectedComponentElement) {
            // Deselect the previously selected component.
            deselectComponentElement(oldSelectedComponentElement);
        }

        if (newSelectedComponentElement) {
            newSelectedComponentElement.classList.add("selected");

            if (newSelectedComponentElement.parentElement?.classList.contains("component-side-menu-wrapper")) {
                newSelectedComponentElement.parentElement.classList.add("selected");
            }
        }
    });

    watch(() => props.html, () => {
        // Whenever the HTML is changed externally,
        // a new iframe element must be created.
        // Do this by setting v-if="false" then v-if="true" (bound to isResetting)
        // while also updating the iframe's srcdoc.
        isResetting.value = true;

        nextTick(() => {
            internalSrcDoc.value = props.html;
            isResetting.value = false;
        });
    });

    watch(() => props.cloneComponentRequest, (newValue) => {
        if (newValue) {
            cloneSelectedComponent();
        }
    });

    watch(() => props.completeComponentRequest, (newValue) => {
        if (newValue) {
            internalSelectedComponentElement.value = null;
        }
    });

    watch(() => props.deleteComponentRequest, (newValue) => {
        if (newValue) {
            deleteSelectedComponent();
        }
    });

    watch(() => props.componentTypeDragStartRequest, (newValue) => {
        if (newValue) {
            sendMessageToIFrame({
                type: "COMPONENT_TYPE_DRAG_START",
                componentTypeName: newValue.componentTypeName,
                customHtml: newValue.customHtml
            });
        }
    });

    watch(() => props.componentTypeDragLeaveRequest, (newValue) => {
        if (newValue) {
            sendMessageToIFrame({
                type: "COMPONENT_TYPE_DRAG_LEAVE"
            });
        }
    });

    watch(() => props.componentTypeDragOverRequest, (newValue) => {
        if (newValue) {
            sendMessageToIFrame({
                type: "COMPONENT_TYPE_DRAG_OVER",
                clientX: newValue.clientX,
                clientY: newValue.clientY
            });
        }
    });

    watch(() => props.componentTypeDragDropRequest, (newValue) => {
        if (newValue) {
            sendMessageToIFrame({
                type: "COMPONENT_TYPE_DRAG_DROP"
            });
        }
    });

    watch(() => props.componentTypeDragEndRequest, (newValue) => {
        if (newValue) {
            sendMessageToIFrame({
                type: "COMPONENT_TYPE_DRAG_END"
            });
        }
    });

    watch(() => props.getHtmlRequest, (newValue) => {
        if (newValue) {
            // We don't want to update the modelValue directly;
            // otherwise, the iframe would be reloaded with new HTML.
            // The parent component should decide whether the new HTML
            // should be passed back in as the modelValue.
            getHtml(newValue);
        }
    });

    watch([draggingElement, draggingPlaceholderElement], ([draggingEl, draggingPlaceholderEl]) => {
        if (draggingEl || draggingPlaceholderEl) {
            iFrameElement.value?.contentDocument?.body.classList.add(draggingCssClass);
        }
        else {
            iFrameElement.value?.contentDocument?.body.classList.remove(draggingCssClass);
        }
    });

    // #endregion Watchers

    // #region Hooks

    onBeforeUnmount(() => {
        // Stop observers to avoid memory leaks.
        wrapperAutoRemovalObserver.value?.disconnect();
        dropzoneEmptyResizeObserver.value?.disconnect();
        sectionComponentMutationObserver.value?.disconnect();
    });

    // #endregion
</script>