<!-- Copyright by the Spark Development Network; Licensed under the Rock Community License -->
<template>
    <div class="d-flex align-items-center">
        <div class="form-control-static mr-1">
            <span class="">Trigger when</span>
        </div>

        <Toggle v-model="triggerWhenAll"
                trueText="All"
                falseText="Any"
                btnSize="xs" />

        <div class="form-control-static">
            <span class="ml-1">of the rules are true:</span>
        </div>
    </div>

    <Grid :data="criteriaGridData"
          keyField="guid"
          liveUpdates
          light
          @addItem="onAddCriteriaRuleClick">
        <Column name="filterType"
                title="Filter Type">
            <template #format="{ row }">
                {{ getFilterType(row) }}
            </template>
        </Column>

        <Column name="filterDescription"
                title="Filter Description">
            <template #format="{ row }">
                {{ getFilterDescription(row) }}
            </template>
        </Column>

        <EditColumn name="edit" @click="onEditCriteriaRuleClick" />
        <DeleteColumn name="delete" disableConfirmation @click="onDeleteCriteriaRuleClick" />
    </Grid>

    <Modal v-model="showCriteriaModal"
           title="Trigger Criteria"
           saveText="Save"
           @save="onSaveCriteriaRuleClick">
        <EditRule v-model="editCriteriaBag"
                  :groupTypeGuids="groupTypeGuids" />
    </Modal>
</template>

<script setup lang="ts">
    import { computed, PropType, ref, watch } from "vue";
    import EditRule from "./editRule.partial.obs";
    import Grid, { Column, DeleteColumn, EditColumn } from "@Obsidian/Controls/grid";
    import Modal from "@Obsidian/Controls/modal.obs";
    import Toggle from "@Obsidian/Controls/toggle.obs";
    import { ChatMessageCriteriaRuleTypeDescription } from "@Obsidian/Enums/Core/Automation/Triggers/chatMessageCriteriaRuleType";
    import { Guid } from "@Obsidian/Types";
    import { updateRefValue } from "@Obsidian/Utility/component";
    import { safeParseJson } from "@Obsidian/Utility/stringUtils";
    import { ChatMessageCriteriaBag } from "@Obsidian/ViewModels/Core/Automation/Triggers/chatMessageCriteriaBag";
    import { ChatMessageCriteriaRuleBag } from "@Obsidian/ViewModels/Core/Automation/Triggers/chatMessageCriteriaRuleBag";
    import { GridDataBag } from "@Obsidian/ViewModels/Core/Grid/gridDataBag";

    const props = defineProps({
        /**
         * The JSON string that contains the criteria for the trigger.
         */
        modelValue: {
            type: String as PropType<string>,
            required: true
        },

        /**
         * The list of group type Guids that can be used in the rule.
         */
        groupTypeGuids: {
            type: Array as PropType<Guid[]>,
            required: true
        }
    });

    const emit = defineEmits<{
        (e: "update:modelValue", value: string): void
    }>();

    // #region Values

    const triggerWhenAll = ref(true);
    const criteriaData = ref<ChatMessageCriteriaRuleBag[]>([]);

    const showCriteriaModal = ref(false);
    const editCriteriaBag = ref<ChatMessageCriteriaRuleBag | null>(null);

    // #endregion Values

    // #region Computed Values

    const criteriaGridData = computed((): GridDataBag => {
        return { rows: criteriaData.value };
    });

    // #endregion

    // #region Functions

    /**
     * Sets the values of the trigger based on the model value.
     */
    function setValues(): void {
        const criteria = safeParseJson<ChatMessageCriteriaBag>(props.modelValue);

        updateRefValue(triggerWhenAll, criteria?.areAllRulesRequired ?? true);
        updateRefValue(criteriaData, criteria?.rules ?? []);
    }

    /**
     * Gets the content of the filter type column for the grid.
     *
     * @param row The grid row to get the filter type for.
     *
     * @returns The friendly type of the filter.
     */
    function getFilterType(row: ChatMessageCriteriaRuleBag): string {
        return ChatMessageCriteriaRuleTypeDescription[row.ruleType];
    }

    /**
     * Gets the content of the filter description column for the grid.
     *
     * @param row The grid row to get the filter description for.
     *
     * @returns The friendly description of the filter.
     */
    function getFilterDescription(row: ChatMessageCriteriaRuleBag): string {
        return row.friendlyCriteriaValue ?? "No filter set";
    }

    // #endregion

    // #region Event Handlers

    /**
     * Called when the individual cliks the button at add a new crtieria rule.
     */
    async function onAddCriteriaRuleClick(): Promise<void> {
        editCriteriaBag.value = null;
        showCriteriaModal.value = true;
    }

    /**
     * Called when the individual is ready to save the criteria rule currently
     * being edited in the modal.
     */
    function onSaveCriteriaRuleClick(): void {
        if (!editCriteriaBag.value) {
            return;
        }

        const newData = [...criteriaData.value];
        const index = newData.findIndex(r => r.guid === editCriteriaBag.value?.guid);

        if (index === -1) {
            newData.push(editCriteriaBag.value);
        }
        else {
            newData.splice(index, 1, editCriteriaBag.value);
        }

        criteriaData.value = newData;
        showCriteriaModal.value = false;
        editCriteriaBag.value = null;
    }

    /**
     * Called when the individual clicks the edit button for a criteria rule.
     *
     * @param key The key of the criteria rule to edit.
     */
    async function onEditCriteriaRuleClick(key: string): Promise<void> {
        const item = criteriaData.value.find(r => r.guid === key);

        if (!item) {
            return;
        }

        editCriteriaBag.value = { ...item };
        showCriteriaModal.value = true;
    }

    /**
     * Called when the individual clicks the delete button for a criteria rule.
     *
     * @param key The key of the criteria rule to delete.
     */
    function onDeleteCriteriaRuleClick(key: string): void {
        const newData = [...criteriaData.value];
        const index = newData.findIndex(r => r.guid === key);

        if (index >= 0) {
            newData.splice(index, 1);
        }

        criteriaData.value = newData;
    }

    // #endregion

    watch(() => props.modelValue, () => {
        setValues();
    });

    watch([triggerWhenAll, criteriaData], () => {
        const newValue: ChatMessageCriteriaBag = {
            areAllRulesRequired: triggerWhenAll.value,
            rules: criteriaData.value
        };

        emit("update:modelValue", JSON.stringify(newValue));
    });

    setValues();
</script>
