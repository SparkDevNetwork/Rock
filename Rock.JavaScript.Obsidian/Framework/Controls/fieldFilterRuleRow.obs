<!-- Copyright by the Spark Development Network; Licensed under the Rock Community License -->
<template>
    <div class="filter-rule">
        <div class="filter-rule-fields row form-row">
            <div class="filter-rule-comparefield col-xs-12 col-md-4">
                <DropDownList v-model="selectedFieldKey"
                              :items="fieldList"
                              :grouped="groupSources"
                              :showBlankItem="false"
                              :enhanceForLongLists="enhanceForLongSourceLists" />
            </div>
            <div class="filter-rule-fieldfilter col-xs-12 col-md-8">
                <RockAttributeFilter v-if="currentAttribute"
                                     v-model="comparisonValue"
                                     :attribute="currentAttribute"
                                     :filterMode="FilterMode.Advanced"
                                     required />

                <component v-if="currentProperty"
                           :is="fieldComponent"
                           v-model="comparisonValue"
                           :configurationValues="currentProperty.configurationValues ?? {}"
                           :filterMode="FilterMode.Advanced"
                           required />
            </div>
        </div>
        <div class="filter-rule-remove">
            <button class="btn btn-danger btn-square" @click.prevent="onRemoveRuleClick">
                <i class="fa fa-times"></i>
            </button>
        </div>
    </div>
</template>

<script setup lang="ts">
    import { Component as VueComponent, computed, PropType, ref, watch } from "vue";
    import DropDownList from "./dropDownList.obs";
    import { ComparisonValue } from "@Obsidian/Types/Reporting/comparisonValue";
    import { areEqual, emptyGuid, toGuidOrNull } from "@Obsidian/Utility/guid";
    import { updateRefValue } from "@Obsidian/Utility/component";
    import { ListItemBag } from "@Obsidian/ViewModels/Utility/listItemBag";
    import { PublicAttributeBag } from "@Obsidian/ViewModels/Utility/publicAttributeBag";
    import { FieldFilterRuleBag } from "@Obsidian/ViewModels/Reporting/fieldFilterRuleBag";
    import { FieldFilterSourceBag } from "@Obsidian/ViewModels/Reporting/fieldFilterSourceBag";
    import RockAttributeFilter from "./rockAttributeFilter.obs";
    import { FieldFilterSourceType } from "@Obsidian/Enums/Reporting/fieldFilterSourceType";
    import { FieldFilterPropertyBag } from "@Obsidian/ViewModels/Reporting/fieldFilterPropertyBag";
    import { FilterMode } from "@Obsidian/Core/Reporting/filterMode";
    import { getFieldType } from "@Obsidian/Utility/fieldTypes";

    const props = defineProps({
        modelValue: {
            type: Object as PropType<FieldFilterRuleBag>,
            required: true
        },
        sources: {
            type: Array as PropType<FieldFilterSourceBag[]>,
            required: true
        },

        /** Enables grouping of the field sources picker. */
        groupSources: {
            type: Boolean as PropType<boolean>,
            default: false
        },

        /** Uses an enhanced picker that allows searching in the source list. */
        enhanceForLongSourceLists: {
            type: Boolean as PropType<boolean>,
            default: false
        },
    });

    const emit = defineEmits<{
        (e: "update:modelValue", value: FieldFilterRuleBag): void;
        (e: "removeRule", value: FieldFilterRuleBag): void;
    }>();

    let internalUpdate = false;

    const selectedFieldKey = ref(props.modelValue.attributeGuid ?? props.modelValue.propertyName ?? "");
    const comparisonValue = ref<ComparisonValue>({
        comparisonType: props.modelValue.comparisonType,
        value: props.modelValue.value ?? ""
    });

    /** The currently selected attribute, if any. */
    const currentAttribute = computed((): PublicAttributeBag | undefined => {
        // Force get the value so the computed tracks it even if we don't
        // have any sources just yet.
        const key = selectedFieldKey.value;

        const source = props.sources.find(source => {
            return areEqual(key, source.attribute?.attributeGuid ?? "");
        });

        if (!source || source.type !== FieldFilterSourceType.Attribute || !source.attribute) {
            return undefined;
        }

        return source.attribute;
    });

    /** The currently selected property, if any. */
    const currentProperty = computed((): FieldFilterPropertyBag | undefined => {
        // Force get the value so the computed tracks it even if we don't
        // have any sources just yet.
        const key = selectedFieldKey.value;

        const source = props.sources.find(source => {
            return key === source.property?.name;
        });

        if (!source || source.type !== FieldFilterSourceType.Property || !source.property) {
            return undefined;
        }

        return source.property;
    });

    /** The filter component to use to display and edit the property value. */
    const fieldComponent = computed((): VueComponent | null | undefined => {
        if (!currentProperty.value) {
            return undefined;
        }

        const field = getFieldType(toGuidOrNull(currentProperty.value.fieldTypeGuid) ?? emptyGuid);

        return field?.getFilterComponent(currentProperty.value?.configurationValues ?? {});
    });

    // Convert the list of sources into the options you can choose from the
    const fieldList = computed((): ListItemBag[] => {
        return props.sources.map(source => {
            return {
                text: source.attribute?.name ?? source.property?.title,
                value: source.attribute?.attributeGuid ?? source.property?.name,
                category: source.category
            };
        });
    });

    function onRemoveRuleClick(): void {
        emit("removeRule", props.modelValue);
    }

    // Watch for changes to the model value and update our internal values.
    watch(() => props.modelValue, () => {
        // Prevent a value reset.
        internalUpdate = true;

        updateRefValue(selectedFieldKey, props.modelValue.attributeGuid ?? props.modelValue.propertyName ?? "");
        updateRefValue(comparisonValue, {
            comparisonType: props.modelValue.comparisonType,
            value: props.modelValue.value ?? ""
        });

        internalUpdate = false;
    });

    // Watch for changes to our internal values and update the model value.
    watch([selectedFieldKey, comparisonValue], () => {
        const isAttribute = props.sources.some(s => areEqual(s.attribute?.attributeGuid, selectedFieldKey.value));

        const newValue: FieldFilterRuleBag = {
            ...props.modelValue,
            attributeGuid: isAttribute ? toGuidOrNull(selectedFieldKey.value) : null,
            propertyName: !isAttribute ? selectedFieldKey.value : null,
            sourceType: isAttribute ? FieldFilterSourceType.Attribute : FieldFilterSourceType.Property,
            comparisonType: comparisonValue.value.comparisonType ?? 0,
            value: comparisonValue.value.value
        };

        emit("update:modelValue", newValue);
    });

    // Reset the rule after a new attribute is chosen
    watch(selectedFieldKey, () => {
        if (!internalUpdate) {
            comparisonValue.value = {
                comparisonType: 0,
                value: ""
            };
        }
    });
</script>
