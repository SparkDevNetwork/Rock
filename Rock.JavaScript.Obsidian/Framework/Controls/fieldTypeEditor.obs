<!-- Copyright by the Spark Development Network; Licensed under the Rock Community License -->
<template>
    <div>
        <template v-if="isFieldTypesReady && !showConfigOnly">
            <StaticFormControl v-if="isFieldTypeReadOnly" label="Field Type" v-model="fieldTypeName" />
            <DropDownList v-else label="Field Type" v-model="fieldTypeValueGuidOrEmptyString" :items="fieldTypeOptions" rules="required" enhanceForLongLists />
        </template>
        <NotificationBox v-if="fieldErrorMessage" alertType="warning">
            {{ fieldErrorMessage }}
        </NotificationBox>
        <component v-if="showConfigurationComponent" :is="configurationComponent" v-model="configurationValues" :configurationProperties="configurationProperties" @updateConfiguration="onUpdateConfiguration" @updateConfigurationValue="onUpdateConfigurationValue" />
        <RockField v-if="hasDefaultValue && !showConfigOnly" :modelValue="defaultValue" :attribute="defaultValueAttribute" @update:modelValue="onDefaultValueUpdate" isEditMode dataEntryMode="defaultValue" />
    </div>
</template>

<script setup lang="ts">
    import { Component, computed, PropType, ref, watch } from "vue";
    import RockField from "./rockField.obs";
    import NotificationBox from "./notificationBox.obs";
    import DropDownList from "./dropDownList.obs";
    import StaticFormControl from "./staticFormControl.obs";
    import { getFieldType } from "@Obsidian/Utility/fieldTypes";
    import { useHttp } from "@Obsidian/Utility/http";
    import { areEqual, emptyGuid, newGuid, toGuidOrNull } from "@Obsidian/Utility/guid";
    import { ListItemBag } from "@Obsidian/ViewModels/Utility/listItemBag";
    import { PublicAttributeBag } from "@Obsidian/ViewModels/Utility/publicAttributeBag";
    import { FieldTypeEditorUpdateAttributeConfigurationOptionsBag } from "@Obsidian/ViewModels/Controls/fieldTypeEditorUpdateAttributeConfigurationOptionsBag";
    import { FieldTypeEditorUpdateAttributeConfigurationResultBag } from "@Obsidian/ViewModels/Controls/fieldTypeEditorUpdateAttributeConfigurationResultBag";
    import { FieldTypeEditorGetAvailableFieldTypesOptionsBag } from "@Obsidian/ViewModels/Controls/fieldTypeEditorGetAvailableFieldTypesOptionsBag";
    import { updateRefValue } from "@Obsidian/Utility/component";
    import { deepEqual } from "@Obsidian/Utility/util";
    import { IFieldType } from "@Obsidian/Types/fieldType";

    const props = defineProps({
        modelValue: {
            type: Object as PropType<FieldTypeEditorUpdateAttributeConfigurationOptionsBag | null>,
            default: null
        },

        isFieldTypeReadOnly: {
            type: Boolean,
            default: false
        },

        showConfigOnly: {
            type: Boolean,
            default: false
        }
    });

    const emit = defineEmits<{
        (e: "update:modelValue", value: FieldTypeEditorUpdateAttributeConfigurationOptionsBag | null): void;
    }>();

    const http = useHttp();
    const internalValue = ref(props.modelValue);

    /** The selected field type in the drop down list. */
    const fieldTypeValueGuidOrEmptyString = ref<string>(props.modelValue?.fieldTypeGuid ?? "");

    // Tracks a pending resetToDefaults() call.
    let resetToDefaultsTimer: number | null = null;

    /** The details about the default value used for the field. */
    const defaultValue = ref("");

    /** The current configuration properties that describe the field type options. */
    const configurationProperties = ref<Record<string, string>>({});

    /** The current values selected in the configuration properties. */
    const configurationValues = ref<Record<string, string>>(props.modelValue?.configurationValues ?? {});
    const editConfigurationValues = ref<Record<string, string>>({});

    const fieldType = computed((): IFieldType | null => {
        if (!fieldTypeValueGuidOrEmptyString.value) {
            return null;
        }

        const option = fieldTypeOptions.value
            .find(o => areEqual(o.value, fieldTypeValueGuidOrEmptyString.value) || areEqual(o.category, fieldTypeValueGuidOrEmptyString.value));

        if (!option || (!option.value && !option.category)) {
            return null;
        }

        return getFieldType(option.category || option.value || "");
    });

    /** True if the default value component should be shown. */
    const hasDefaultValue = computed((): boolean => {
        // Verify the configuration component is visible and we have a
        // default value.
        if (!showConfigurationComponent.value || defaultValue.value === null) {
            return false;
        }

        // Field type has final say if a default value should be shown.
        return fieldType.value?.hasDefaultComponent(configurationValues.value) ?? false;
    });

    /** True if the field types options are ready for display. */
    const isFieldTypesReady = ref(false);

    /** True if the configuration data has been retrieved and is ready for display. */
    const isConfigurationReady = ref(false);

    /** True if everything is loaded and ready for display. */
    const isReady = computed(() => isFieldTypesReady.value && isConfigurationReady.value);

    /** Contains any error message to be displayed to the user about the operation. */
    const fieldErrorMessage = ref("");

    /** The options to be shown in the field type drop down control. */
    const fieldTypeOptions = ref<ListItemBag[]>([]);

    /** The UI component that will handle the configuration of the field type. */
    const configurationComponent = computed((): Component | null => {
        if (fieldType.value) {
            return fieldType.value.getConfigurationComponent();
        }
        return null;
    });

    /** True if the configuration component is ready to be displayed. */
    const showConfigurationComponent = computed((): boolean => {
        return configurationComponent.value !== null && isReady.value;
    });

    /** The name of the currently selected field type. */
    const fieldTypeName = computed((): string => {
        if (!fieldTypeValueGuidOrEmptyString.value) {
            return "";
        }

        const option = fieldTypeOptions.value
            .find(o => areEqual(o.value, fieldTypeValueGuidOrEmptyString.value) || areEqual(o.category, fieldTypeValueGuidOrEmptyString.value));

        return option?.text ?? "";
    });

    const defaultValueAttribute = computed((): PublicAttributeBag => {
        const option = fieldTypeOptions.value
            .find(o => areEqual(o.value, fieldTypeValueGuidOrEmptyString.value) || areEqual(o.category, fieldTypeValueGuidOrEmptyString.value));

        return {
            fieldTypeGuid: option?.category || fieldTypeValueGuidOrEmptyString.value || emptyGuid,
            attributeGuid: newGuid(),
            configurationValues: editConfigurationValues.value,
            name: "Default Value",
            key: "DefaultValue",
            description: "",
            isRequired: false,
            order: 0,
            categories: []
        };
    });

    /**
     * True if an update request has been caused by an internal value change.
     * In this case, the update is not emitted to the parent.
     */
    let isInternalUpdate = false;

    /**
     * Called when the modelValue needs to be updated from any change
     * that was made.
     */
    function updateModelValue(): void {
        if (isInternalUpdate) {
            return;
        }

        const newValue: FieldTypeEditorUpdateAttributeConfigurationOptionsBag = {
            fieldTypeGuid: fieldTypeValueGuidOrEmptyString.value || emptyGuid,
            configurationValues: configurationValues.value,
            defaultValue: defaultValue.value ?? ""
        };

        // This only updates if the value has actually changed, which removes
        // some false dirty state.
        updateRefValue(internalValue, newValue);
    }

    /**
     * Resets all configuration details as if the user selected a blank
     * field type.
     */
    function resetToDefaults(): void {
        if (resetToDefaultsTimer !== null) {
            clearTimeout(resetToDefaultsTimer);
            resetToDefaultsTimer = null;
        }

        isConfigurationReady.value = false;
        isInternalUpdate = true;
        configurationProperties.value = {};
        configurationValues.value = {};
        defaultValue.value = "";
        isInternalUpdate = false;

        updateModelValue();
    }

    /** Updates the field configuration from new data on the server. */
    function updateFieldConfiguration(currentDefaultValue: string): void {
        const fieldTypeGuid = toGuidOrNull(fieldTypeValueGuidOrEmptyString.value);

        if (!fieldTypeGuid || areEqual(fieldTypeGuid, emptyGuid)) {
            resetToDefaults();

            return;
        }

        const update: FieldTypeEditorUpdateAttributeConfigurationOptionsBag = {
            fieldTypeGuid,
            configurationValues: configurationValues.value,
            defaultValue: currentDefaultValue
        };

        http.post<FieldTypeEditorUpdateAttributeConfigurationResultBag>("/api/v2/Controls/FieldTypeEditorUpdateAttributeConfiguration", null, update)
            .then(result => {
                resetToDefaults();

                if (result.isSuccess && result.data && result.data.configurationProperties && result.data.adminConfigurationValues && result.data.editConfigurationValues) {
                    fieldErrorMessage.value = "";
                    isConfigurationReady.value = true;

                    isInternalUpdate = true;
                    configurationProperties.value = result.data.configurationProperties;
                    configurationValues.value = result.data.adminConfigurationValues;
                    editConfigurationValues.value = result.data.editConfigurationValues;
                    defaultValue.value = result.data.defaultValue ?? "";
                    isInternalUpdate = false;

                    updateModelValue();
                }
                else {
                    fieldErrorMessage.value = result.errorMessage ?? "Encountered unknown error communicating with server.";
                }
            });
    }

    /** Called when the default value has been changed by the screen control. */
    function onDefaultValueUpdate(value: string): void {
        defaultValue.value = value;
        updateModelValue();
    }

    /**
     * Called when the field type configuration control requests that the
     * configuration properties be updated from the server.
     */
    function onUpdateConfiguration(): void {
        updateFieldConfiguration(defaultValue.value ?? "");
    }

    /**
     * Called when the field type configuration control has updated one of
     * the configuration values that does not require a full reload.
     *
     * @param key The key of the configuration value that was changed.
     * @param value The new value of the configuration value.
     */
    function onUpdateConfigurationValue(_key: string, _value: string): void {
        updateModelValue();
    }

    // Called when the field type drop down value is changed.
    watch(fieldTypeValueGuidOrEmptyString, () => {
        if (resetToDefaultsTimer === null) {
            resetToDefaultsTimer = window.setTimeout(resetToDefaults, 250);
        }

        updateFieldConfiguration("");
    });

    // Watch for changes to our internal value and update the model value.
    watch(internalValue, () => {
        // Normally, this deepEqual wouldn't be needed. But there are times
        // where the internalValue is changed twice. For example, we will
        // reset the value to blank and then set the proper value. In that
        // case this watch will be triggered because it detects the value
        // did indeed change, but we need to check if it was just a toggle
        // to a blank value and then back to the model value.
        if (!deepEqual(internalValue.value, props.modelValue, true)) {
            emit("update:modelValue", internalValue.value);
        }
    });

    // Get all the available field types that the user is allowed to edit.
    const options: FieldTypeEditorGetAvailableFieldTypesOptionsBag = {};
    http.post<ListItemBag[]>("/api/v2/Controls/FieldTypeEditorGetAvailableFieldTypes", undefined, options)
        .then(result => {
            if (result.isSuccess && result.data) {
                fieldTypeOptions.value = result.data;
                isFieldTypesReady.value = true;

                // If the field type is already selected then begin to load
                // all the field configuration.
                if (fieldTypeValueGuidOrEmptyString.value !== "") {
                    updateFieldConfiguration(props.modelValue?.defaultValue ?? "");
                }
            }
        });
</script>
