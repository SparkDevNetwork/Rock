<!-- Copyright by the Spark Development Network; Licensed under the Rock Community License -->
<template>
    <RockFormField
                   v-model="internalValue"
                   formGroupClasses="rock-text-box"
                   name="textbox"
                   :rules="computedRules">
        <template #default="{ uniqueId, field }">
            <div class="control-wrapper">
                <div class="input-group">
                    <span class="input-group-addon">
                        <i class="fa fa-envelope"></i>
                    </span>
                    <input v-model="internalValue" :id="uniqueId" class="form-control" v-bind="field" :type="computedType" />
                </div>
            </div>
        </template>
    </RockFormField>
</template>

<script setup lang="ts">
    import { computed, PropType } from "vue";
    import { normalizeRules, rulesPropType, ValidationRule, ValidationRuleFunction } from "@Obsidian/ValidationRules";
    import RockFormField from "./rockFormField.obs";
    import { useVModelPassthrough } from "@Obsidian/Utility/component";

    const props = defineProps({
        modelValue: {
            type: String as PropType<string>,
            required: true
        },
        allowLava: {
            type: Boolean as PropType<boolean>,
            default: false
        },
        allowMultiple: {
            type: Boolean as PropType<boolean>,
            default: false
        },
        rules: rulesPropType
    });

    const emit = defineEmits<{
        (e: "update:modelValue", value: string): void;
    }>();

    // #region Values

    const internalValue = useVModelPassthrough(props, "modelValue", emit);

    // #endregion Values

    // #region Computed Values

    const computedRules = computed((): ValidationRule[] => {
        const rules = normalizeRules(props.rules);

        if (props.allowMultiple) {
            if (props.allowLava) {
                // Multiple Lava email addresses are allowed.
                rules.push(validateMultipleWithLava);
            }
            else {
                // Multiple non-Lava email addresses are allowed.
                rules.push(validateMultipleNoLava);
            }
        }
        else if (props.allowLava) {
            // Only a single Lava email address is allowed.
            rules.push(validateSingleWithLava);
        }
        else if (rules.indexOf("email") === -1) {
            // Only a single non-Lava email address is allowed.
            rules.push("email");
        }

        return rules;
    });

    const computedType = computed((): string => {
        return props.allowLava || props.allowMultiple ? "text" : "email";
    });

    // #endregion Computed Values

    // #region Functions

    // Validation regex patterns
    // eslint-disable-next-line no-control-regex
    const emailAddressRegex = /\s*(?:[A-Za-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[A-Za-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?\.)+[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?|\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\.){3}(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[A-Za-z0-9-]*[A-Za-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])\s*/;
    const lavaVariableRegex = /({{\s*[^}}]+\s*}})/;
    const lavaTagRegex = /({%\s*[^%}]+\s*%})/;
    const lavaBlockRegex = /(({%\s*(\w+)\s*).*%}).*({%\s*end\3\s*%})/;
    const lavaShortcodeRegex = /({\[\s*[^\]}]+\s*\]})/;

    // Zero or more repeating groups of Lava tags, or email addresses separated by whitespace or commas.
    const validateMultipleWithLavaRegex = new RegExp(`(${lavaBlockRegex.source}|${lavaTagRegex.source}|${lavaShortcodeRegex.source}|${lavaVariableRegex.source}|${emailAddressRegex.source}|[\\s,]*)*`);
    const validateMultipleWithLava: ValidationRuleFunction = (value: unknown): boolean | string => {
        if (value && typeof value === "string") {
            if (!validateMultipleWithLavaRegex.test(value)) {
                return "is not valid";
            }
        }

        return true;
    };

    // One or more email addresses, separated by whitespace or commas.
    const validateMultipleNoLavaRegex = new RegExp(`((${emailAddressRegex.source}|[\\s,]*)*)`);
    const validateMultipleNoLava: ValidationRuleFunction = (value: unknown): boolean | string => {
        if (value && typeof value === "string") {
            if (!validateMultipleNoLavaRegex.test(value)) {
                return "is not valid";
            }
        }

        return true;
    };

    // Zero or more repeating groups of Lava tags, or an email address.
    const validateSingleWithLavaRegex = new RegExp(`^\\s*(${lavaBlockRegex.source}|${lavaTagRegex.source}|${lavaShortcodeRegex.source}|${lavaVariableRegex.source}|${emailAddressRegex.source})*\\s*$`);
    const validateSingleWithLava: ValidationRuleFunction = (value: unknown): boolean | string => {
        if (value && typeof value === "string") {
            if (!validateSingleWithLavaRegex.test(value)) {
                return "is not valid";
            }
        }

        return true;
    };
</script>
