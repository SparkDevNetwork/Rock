// <copyright>
// Copyright by the Spark Development Network
//
// Licensed under the Rock Community License (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.rockrms.com/license
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// </copyright>
//
using System;
using Rock.Data;

using static Rock.Web.UI.Controls.SlidingDateRangePicker;

namespace Rock
{
    /// <summary>
    /// Helper methods for working with dates in Rock.
    /// </summary>
    public class RockDateTimeHelper
    {
        /// <summary>
        /// CodeGens the SQL and updates the [dbo].[ufnUtility_GetSundayDate] database function after the FirstDayOfWeek setting is modified
        /// </summary>
        private static void CodeGen_ufnUtility_GetSundayDate()
        {
            var alterFunctionSQL = $@"
/*
<doc>
	<summary>
 		This function returns the Sunday date of a given date.
	</summary>

	<returns>
		The Sunday of the date given with Sunday being the SundayDate that is associated with the specified date, depending on the FirstDayOfWeek that is configured in Rock
	</returns>
	<code>
		SELECT [dbo].[ufnUtility_GetSundayDate](getdate())
	</code>
</doc>
*/
/* This is code generated by RockDateTime.CodeGen_ufnUtility_GetSundayDate() */
ALTER FUNCTION [dbo].[ufnUtility_GetSundayDate] (@InputDate DATETIME)
RETURNS DATE
AS
BEGIN
	DECLARE @InputDOW INT
	DECLARE @sundayDiff INT
	DECLARE @lastDayOfWeek INT
	DECLARE @sundayDate DATE

	-- Configured StartDOW where (using .NET DOW standard)  0 = Sunday and 6 = Saturday. Default is 1 (Monday)
    -- NOTE: This function ([ufnUtility_GetSundayDate]) is code generated so that @FirstDayOfWeek matches what is configured in Rock
	DECLARE @FirstDayOfWeek INT = {( int ) RockDateTime.FirstDayOfWeek}

	-- Sql DOW is 1 based (1 = Sunday, 7 = Saturday )
	-- So, lets convert it to the .NET standard of 0 = Sunday 
	-- from http://stackoverflow.com/a/5109557/1755417 to get the day of week deterministically, but convert to .NET DOW
	SET @InputDOW = ((datediff(day, convert(DATETIME, '18991231', 112), @inputDate) % 7))
	
    -- Get the number of days until the next Sunday date
	SET @sundayDiff = 7 - @InputDOW;
	
    -- Figure out which DayOfWeek would be the lastDayOfWeek
	-- which would be the DayOfWeek before the startDayOfWeek
	-- If the First DOW is Sunday, then the Last DOW is Saturday. Otherwise, the Last DOW is the First DOW - 1
	SET @lastDayOfWeek = CASE 
			WHEN @FirstDayOfWeek = 0
				THEN 6
			ELSE @FirstDayOfWeek - 1
			END
	
    -- There are 3 cases to deal with, and it can get confusing if Sunday isn't the last day of the week
	-- 1) The input date's DOW is Sunday. Today is the Sunday, so the Sunday Date is today
	-- 2) The input date's DOW is after the Last DOW (Today is Thursday, and the week ends next week on Tuesday).
	-- 3) The input date's DOW is before the Last DOW (Today is Monday, but the week ends this week on Tuesday)
	SET @sundayDate = CASE 
			WHEN (@InputDOW = 0)
				THEN @InputDate
			WHEN (@lastDayOfWeek < @InputDOW)
				THEN dateadd(day, @sundayDiff, @InputDate)
			ELSE dateadd(day, @sundayDiff - 7, @InputDate)
			END

	RETURN @sundayDate
END";

            // Do a safe Create or Alter (see https://stackoverflow.com/a/27970943/1755417 )
            string createFunctionIfNotExists = @"IF OBJECT_ID('[dbo].[ufnUtility_GetSundayDate]') IS NULL
    EXEC('CREATE FUNCTION [dbo].[ufnUtility_GetSundayDate] AS SET NOCOUNT ON;')";

            DbService.ExecuteCommand( createFunctionIfNotExists, System.Data.CommandType.Text );

            DbService.ExecuteCommand( alterFunctionSQL, System.Data.CommandType.Text );
        }

        /// <summary>
        /// Updates the Sunday date data.
        /// </summary>
        public static void UpdateSundayDateData()
        {
            CodeGen_ufnUtility_GetSundayDate();

            // set timeout to 2 hours, just in case it takes a long time
            int commandTimeoutSeconds = ( int ) new TimeSpan( 2, 0, 0 ).TotalSeconds;

            using ( var rockContext = new Rock.Data.RockContext() )
            {
                rockContext.Database.CommandTimeout = commandTimeoutSeconds;
                rockContext.Database.ExecuteSqlCommand( @"
UPDATE FinancialTransaction
SET SundayDate = dbo.ufnUtility_GetSundayDate(TransactionDateTime)
WHERE SundayDate IS NULL
	OR SundayDate != dbo.ufnUtility_GetSundayDate(TransactionDateTime)
" );

                rockContext.Database.ExecuteSqlCommand( @"
UPDATE AttendanceOccurrence
SET SundayDate = dbo.ufnUtility_GetSundayDate(OccurrenceDate)
WHERE SundayDate IS NULL
	OR SundayDate != dbo.ufnUtility_GetSundayDate(OccurrenceDate)
" );

                //// NOTE:
                ////  - [spAnalytics_ETL_Attendance] will take care of updating existing SundayDate data in the [AnalyticsSourceAttendance] table
                ////  - [AnalyticsSourceFinancialTransaction determines] SundayDate from looking up [SundayDate] in [AnalyticsSourceDate] using [AnalyticsSourceFinancialTransaction].[TransactionDateKey]

                // Rebuild the data in the [AnalyticsSourceDate] table
                var analyticsStartDate = new DateTime( RockDateTime.Today.AddYears( -150 ).Year, 1, 1 );
                var analyticsEndDate = new DateTime( RockDateTime.Today.AddYears( 101 ).Year, 1, 1 ).AddDays( -1 );
                Rock.Model.AnalyticsSourceDate.GenerateAnalyticsSourceDateData( 1, false, analyticsStartDate, analyticsEndDate );
            }
        }

        /// <summary>
        /// Calculates the date range from delimited values in format SlidingDateRangeType|Number|TimeUnitType|StartDate|EndDate
        /// </summary>
        /// <param name="value">The value string to be parsed.</param>
        /// <param name="currentDateTime">If set then this value will be used for any calculations based on the current date and time; otherwise RockDateTime.Now will be used.</param>
        /// <returns>A <see cref="DateRange"/> object that contains the start and end dates.</returns>
        internal static DateRange CalculateDateRangeFromDelimitedValues( string value, DateTime? currentDateTime = null )
        {
            string[] splitValues = ( value ?? "1||4||" ).Split( '|' );
            DateRange result = new DateRange();
            if ( splitValues.Length == 5 )
            {
                var slidingDateRangeMode = splitValues[0].ConvertToEnum<SlidingDateRangeType>();
                var numberOfTimeUnits = splitValues[1].AsIntegerOrNull() ?? 1;
                TimeUnitType? timeUnit = splitValues[2].ConvertToEnumOrNull<TimeUnitType>();
                currentDateTime = currentDateTime ?? RockDateTime.Now;

                if ( slidingDateRangeMode == SlidingDateRangeType.Current )
                {
                    switch ( timeUnit )
                    {
                        case TimeUnitType.Hour:
                            result.Start = new DateTime( currentDateTime.Value.Year, currentDateTime.Value.Month, currentDateTime.Value.Day, currentDateTime.Value.Hour, 0, 0 );
                            result.End = result.Start.Value.AddHours( 1 );
                            break;

                        case TimeUnitType.Day:
                            result.Start = currentDateTime.Value.Date;
                            result.End = result.Start.Value.AddDays( 1 );
                            break;

                        case TimeUnitType.Week:

                            // from http://stackoverflow.com/a/38064/1755417
                            int diff = currentDateTime.Value.DayOfWeek - RockDateTime.FirstDayOfWeek;
                            if ( diff < 0 )
                            {
                                diff += 7;
                            }

                            result.Start = currentDateTime.Value.AddDays( -1 * diff ).Date;
                            result.End = result.Start.Value.AddDays( 7 );
                            break;

                        case TimeUnitType.Month:
                            result.Start = new DateTime( currentDateTime.Value.Year, currentDateTime.Value.Month, 1 );
                            result.End = result.Start.Value.AddMonths( 1 );
                            break;

                        case TimeUnitType.Year:
                            result.Start = new DateTime( currentDateTime.Value.Year, 1, 1 );
                            result.End = new DateTime( currentDateTime.Value.Year + 1, 1, 1 );
                            break;
                    }
                }
                else if ( ( SlidingDateRangeType.Last | SlidingDateRangeType.Previous ).HasFlag( slidingDateRangeMode ) )
                {
                    // Last X Days/Hours. NOTE: addCount is the number of X that it go back (it'll actually subtract)
                    int addCount = numberOfTimeUnits;

                    // if we are getting "Last" round up to include the current day/week/month/year
                    int roundUpCount = slidingDateRangeMode == SlidingDateRangeType.Last ? 1 : 0;

                    switch ( timeUnit )
                    {
                        case TimeUnitType.Hour:
                            result.End = new DateTime( currentDateTime.Value.Year, currentDateTime.Value.Month, currentDateTime.Value.Day, currentDateTime.Value.Hour, 0, 0 ).AddHours( roundUpCount );
                            result.Start = result.End.Value.AddHours( -addCount );
                            break;

                        case TimeUnitType.Day:
                            result.End = currentDateTime.Value.Date.AddDays( roundUpCount );
                            result.Start = result.End.Value.AddDays( -addCount );
                            break;

                        case TimeUnitType.Week:
                            // from http://stackoverflow.com/a/38064/1755417
                            int diff = currentDateTime.Value.DayOfWeek - RockDateTime.FirstDayOfWeek;
                            if ( diff < 0 )
                            {
                                diff += 7;
                            }

                            result.End = currentDateTime.Value.AddDays( -1 * diff ).Date.AddDays( 7 * roundUpCount );
                            result.Start = result.End.Value.AddDays( -addCount * 7 );
                            break;

                        case TimeUnitType.Month:
                            result.End = new DateTime( currentDateTime.Value.Year, currentDateTime.Value.Month, 1 ).AddMonths( roundUpCount );
                            result.Start = result.End.Value.AddMonths( -addCount );
                            break;

                        case TimeUnitType.Year:
                            result.End = new DateTime( currentDateTime.Value.Year, 1, 1 ).AddYears( roundUpCount );
                            result.Start = result.End.Value.AddYears( -addCount );
                            break;
                    }

                    // don't let Last,Previous have any future dates
                    var cutoffDate = currentDateTime.Value.Date.AddDays( 1 );
                    if ( result.End.Value.Date > cutoffDate )
                    {
                        result.End = cutoffDate;
                    }
                }
                else if ( ( SlidingDateRangeType.Next | SlidingDateRangeType.Upcoming ).HasFlag( slidingDateRangeMode ) )
                {
                    // Next X Days,Hours,etc
                    int addCount = numberOfTimeUnits;

                    // if we are getting "Upcoming", round up to exclude the current day/week/month/year
                    int roundUpCount = slidingDateRangeMode == SlidingDateRangeType.Upcoming ? 1 : 0;

                    switch ( timeUnit )
                    {
                        case TimeUnitType.Hour:
                            result.Start = new DateTime( currentDateTime.Value.Year, currentDateTime.Value.Month, currentDateTime.Value.Day, currentDateTime.Value.Hour, 0, 0 ).AddHours( roundUpCount );
                            result.End = result.Start.Value.AddHours( addCount );
                            break;

                        case TimeUnitType.Day:
                            result.Start = currentDateTime.Value.Date.AddDays( roundUpCount );
                            result.End = result.Start.Value.AddDays( addCount );
                            break;

                        case TimeUnitType.Week:
                            // from http://stackoverflow.com/a/38064/1755417
                            int diff = currentDateTime.Value.DayOfWeek - RockDateTime.FirstDayOfWeek;
                            if ( diff < 0 )
                            {
                                diff += 7;
                            }

                            result.Start = currentDateTime.Value.AddDays( -1 * diff ).Date.AddDays( 7 * roundUpCount );
                            result.End = result.Start.Value.AddDays( addCount * 7 );
                            break;

                        case TimeUnitType.Month:
                            result.Start = new DateTime( currentDateTime.Value.Year, currentDateTime.Value.Month, 1 ).AddMonths( roundUpCount );
                            result.End = result.Start.Value.AddMonths( addCount );
                            break;

                        case TimeUnitType.Year:
                            result.Start = new DateTime( currentDateTime.Value.Year, 1, 1 ).AddYears( roundUpCount );
                            result.End = result.Start.Value.AddYears( addCount );
                            break;
                    }

                    // don't let Next,Upcoming have any past dates
                    if ( result.Start.Value.Date < currentDateTime.Value.Date )
                    {
                        result.Start = currentDateTime.Value.Date;
                    }
                }
                else if ( slidingDateRangeMode == SlidingDateRangeType.DateRange )
                {
                    result.Start = splitValues[3].AsDateTime();
                    DateTime? endDateTime = splitValues[4].AsDateTime();
                    if ( endDateTime.HasValue )
                    {
                        // add a day to the end since the compare will be "< EndDateTime"
                        result.End = endDateTime.Value.AddDays( 1 );
                    }
                    else
                    {
                        result.End = null;
                    }
                }

                // To avoid confusion about the day or hour of the end of the date range, subtract a microsecond off our 'less than' end date
                // for example, if our end date is 2019-11-7, we actually want all the data less than 2019-11-8, but if a developer does EndDate.DayOfWeek, they would want 2019-11-7 and not 2019-11-8
                // So, to make sure we include all the data for 2019-11-7, but avoid the confusion about what DayOfWeek of the end, we'll compromise by subtracting a millisecond from the end date
                if ( result.End.HasValue && timeUnit != TimeUnitType.Hour )
                {
                    result.End = result.End.Value.AddMilliseconds( -1 );
                }

            }

            return result;
        }

        internal static string ConvertDateRangeDelimitedValueToRoundTripFormat( string value )
        {
            if ( value.IsNotNullOrWhiteSpace() )
            {
                string[] splitValues = value.Split( '|' );
                if ( splitValues.Length == 5 )
                {
                    var slidingDateRangeMode = splitValues[0].ConvertToEnum<SlidingDateRangeType>();

                    if ( slidingDateRangeMode == SlidingDateRangeType.DateRange )
                    {
                        var startDateTime = splitValues[3].AsDateTime();
                        var endDateTime = splitValues[4].AsDateTime();

                        var startDateTimeString = startDateTime.HasValue ? startDateTime.Value.ToString( "o" ) : splitValues[3];
                        var endDateTimeString = endDateTime.HasValue ? endDateTime.Value.ToString( "o" ) : splitValues[4];

                        return $"{slidingDateRangeMode}|{splitValues[1]}|{splitValues[2]}|{startDateTimeString}|{endDateTimeString}";
                    }
                }
            }

            return value;
        }
    }
}
