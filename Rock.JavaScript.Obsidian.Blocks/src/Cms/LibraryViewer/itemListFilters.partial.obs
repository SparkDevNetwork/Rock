<!-- Copyright by the Spark Development Network; Licensed under the Rock Community License -->
<template>
    <div class="library-viewer-item-list-filters">
        <DropDownContent v-model="internalModelValue">
            <template #anchor>
                <RockButton btnType="tool" btnSize="xs"><i class="fa fa-filter" /> {{ appliedFilterOptions.filterButtonText }}</RockButton>
            </template>

            <div class="library-viewer-item-list-filters-container p-3">
                <DropDownList v-model="internalTopics"
                            :enhanceForLongLists="true"
                            :grouped="false"
                            :items="topicOptions"
                            label="Topics"
                            :multiple="true"
                            :showBlankItem="true" />

                <DropDownList v-model="internalOrganizations"
                            :enhanceForLongLists="true"
                            :grouped="false"
                            :items="organizationOptions"
                            label="Organizations"
                            :multiple="true"
                            :showBlankItem="true" />

                <CheckBoxList v-model="internalDownloads"
                            :horizontal="true"
                            :items="downloadOptions"
                            label="Downloads" />

                <CheckBoxList v-model="internalLicenseTypes"
                            :horizontal="true"
                            :items="licenseTypeOptions"
                            label="License Type" />

                <CheckBoxList v-model="internalExperienceLevels"
                            :horizontal="true"
                            :items="experienceLevelOptions"
                            label="Experience Level" />

                <SlidingDateRangePicker v-model="internalPublishedDate"
                                        label="Publish Date"
                                        previewLocation="Top" />

                <RockButton v-if="!areFiltersAppliedOnClose" @click="onApplyClicked" btnSize="xs" class="mr-1">Apply Filters</RockButton>
                <RockButton @click="onClearAllClicked" btnSize="xs">Clear All</RockButton>
            </div>
        </DropDownContent>
    </div>
</template>

<style>

.library-viewer-item-list-filters-container {
    width: 410px;
    max-width: 100%;
    overflow: hidden;
}

.library-viewer-item-list-filters-container .rc-virtual-list-holder {
    max-height: 200px;
    overflow-y: hidden;
}

.library-viewer-item-list-filters-container .ant-select-loading {
    display: none;
}

.ant-select {
    position: relative !important;
}
</style>

<script setup lang="ts">
    import { computed, onMounted, PropType, ref, watch } from "vue";
    import { PersonPreferenceKey } from "./types.partial";
    import { compareStrings, getPersonPreference, setPersonPreference } from "./utils.partial";
    import CheckBoxList from "@Obsidian/Controls/checkBoxList.obs";
    import DropDownContent from "@Obsidian/Controls/dropDownContent.obs";
    import DropDownList from "@Obsidian/Controls/dropDownList.obs";
    import RockButton from "@Obsidian/Controls/rockButton.obs";
    import SlidingDateRangePicker from "@Obsidian/Controls/slidingDateRangePicker.obs";
    import { ContentLibraryItemExperienceLevel, ContentLibraryItemExperienceLevelDescription } from "@Obsidian/Enums/Cms/contentLibraryItemExperienceLevel";
    import { DefinedValue } from "@Obsidian/SystemGuids/definedValue";
    import { usePersonPreferences } from "@Obsidian/Utility/block";
    import { useVModelPassthrough } from "@Obsidian/Utility/component";
    import { RockDateTime } from "@Obsidian/Utility/rockDateTime";
    import { SlidingDateRange, RangeType, calculateSlidingDateRange, parseSlidingDateRangeString, slidingDateRangeToString } from "@Obsidian/Utility/slidingDateRange";
    import { LibraryViewerItemBag } from "@Obsidian/ViewModels/Blocks/Cms/LibraryViewer/libraryViewerItemBag";
    import { LibraryViewerItemFiltersBag } from "@Obsidian/ViewModels/Blocks/Cms/LibraryViewer/libraryViewerItemFiltersBag";
    import { ListItemBag } from "@Obsidian/ViewModels/Utility/listItemBag";

    type FilterOptions = {
        filterButtonText: string;
        filter(item: LibraryViewerItemBag): boolean;
    };

    enum DownloadItem {
        Trending = "Trending",
        Popular = "Popular"
    }

    const props = defineProps({
        modelValue: {
            type: Boolean as PropType<boolean>,
            default: false,
            required: false
        },
        items: {
            type: Object as PropType<LibraryViewerItemBag[]>,
            required: true
        },
        areFiltersAppliedOnClose: {
            type: Boolean as PropType<boolean>,
            default: true,
            required: false
        },
        contentChannelIdKey: {
            type: String as PropType<string | null | undefined>,
            required: false
        }
    });

    const emit = defineEmits<{
        (e: "update:modelValue", value: boolean): void,
        (e: "filteredItems", value: LibraryViewerItemBag[]): void
    }>();

    const preferences = usePersonPreferences().blockPreferences;

    const downloadOptions: ListItemBag[] = [
        {
            text: "Trending",
            value: DownloadItem.Trending
        },
        {
            text: "Popular",
            value: DownloadItem.Popular
        },
    ];

    const noFilter: FilterOptions = {
        filterButtonText: "Filter",
        filter: (_) => true
    };

    //#region Values

    const internalModelValue = useVModelPassthrough(props, "modelValue", emit);
    const pendingFilters = ref<LibraryViewerItemFiltersBag>(getFiltersPersonPreference());
    const appliedFilterOptions = ref<FilterOptions>(noFilter);

    //#endregion

    //#region Computed Values

    const licenseTypeOptions = computed<ListItemBag[]>(() => {
        const distinctLicenseTypes: Record<string, ListItemBag> = {};

        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        for (let licenseType of props.items.filter(item => !!item.licenseType).map(item => item.licenseType!)) {
            if (licenseType.value && !distinctLicenseTypes[licenseType.value]) {
                distinctLicenseTypes[licenseType.value] = licenseType;
            }
        }

        // Sort by: Open, Author Attribution, Organization Attribution, then alphabetically by text.
        const licenseTypePreferredOrder: string[] = [
            DefinedValue.LibraryLicenseTypeOpen.toLowerCase(),
            DefinedValue.LibraryLicenseTypeAuthorAttribution.toLowerCase(),
            DefinedValue.LibraryLicenseTypeOrganizationAttribution.toLowerCase()
        ];
        return Object.values(distinctLicenseTypes).sort((licenseType1, licenseType2) => {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const index1 = licenseTypePreferredOrder.indexOf(licenseType1.value!);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const index2 = licenseTypePreferredOrder.indexOf(licenseType2.value!);

            if (index1 === -1 && index2 === -1) {
                // If the preferred order is not defined for either license type,
                // then sort them by text alphabetically.
                return compareStrings(licenseType1.text, licenseType2.text);
            }

            if (index1 === -1) {
                // If the first license type is not in the preferred order list,
                // then the second license type should be displayed first.
                return 1;
            }

            if (index2 === -1) {
                // If the second license type is not in the preferred order list,
                // then the first license type should be displayed first.
                return -1;
            }

            if (index1 < index2) {
                return -1;
            }
            else if (index1 > index2) {
                return 1;
            }
            else {
                return 0;
            }
        });
    });

    const experienceLevelOptions = computed<ListItemBag[]>(() => {
        const distinctExperienceLevels: Record<string, ListItemBag> = {};

        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        for (let experienceLevel of props.items.filter(item => !!item.experienceLevel).map(item => item.experienceLevel!)) {
            if (experienceLevel.value && !distinctExperienceLevels[experienceLevel.value]) {
                distinctExperienceLevels[experienceLevel.value] = experienceLevel;
            }
        }

        // Sort the experience levels by value (which are the stringified enum values)
        return Object.values(distinctExperienceLevels).sort((a, b) => compareStrings(a.value, b.value));
    });

    const topicOptions = computed<ListItemBag[]>(() => {
        const distinctTopics: Record<string, ListItemBag> = {};

        for (let topic of props.items.filter(item => !!item.topic).map(item => item.topic)) {
            if (topic?.value && !distinctTopics[topic.value]) {
                distinctTopics[topic.value] = topic;
            }
        }

        return Object.values(distinctTopics).sort((topic1, topic2) => compareStrings(topic1.text, topic2.text));
    });

    const organizationOptions = computed<ListItemBag[]>(() => {
        const distinctOrganizations: Record<string, ListItemBag> = {};

        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        for (let organizationName of props.items.filter(item => !!item.sourcePublisherName).map(item => item.sourcePublisherName!)) {
            if (!distinctOrganizations[organizationName]) {
                distinctOrganizations[organizationName] = {
                    text: organizationName,
                    value: organizationName
                };
            }
        }

        return Object.values(distinctOrganizations).sort((organization1, organization2) => compareStrings(organization1.text, organization2.text));
    });

    const internalDownloads = computed<string[]>({
        get() {
            const downloads: string[] = [];

            if (pendingFilters.value.mustBeTrending) {
                downloads.push(DownloadItem.Trending);
            }

            if (pendingFilters.value.mustBePopular) {
                downloads.push(DownloadItem.Popular);
            }

            return downloads;
        },
        set(newValue: string[]) {
            pendingFilters.value.mustBePopular = newValue.some(v => v === DownloadItem.Popular);
            pendingFilters.value.mustBeTrending = newValue.some(v => v === DownloadItem.Trending);
        }
    });

    const internalOrganizations = computed<string[]>({
        get() {
            return pendingFilters.value.organizations ?? [];
        },
        set(newValue: string[]) {
            pendingFilters.value.organizations = newValue;
        }
    });

    const internalPublishedDate = computed<SlidingDateRange>({
        get(): SlidingDateRange {
            if (pendingFilters.value.publishedDate) {
                const slidingDateRange = parseSlidingDateRangeString(pendingFilters.value.publishedDate);

                if (slidingDateRange) {
                    return slidingDateRange;
                }
            }

            return {
                rangeType: RangeType.All,
            };
        },
        set(newValue: SlidingDateRange) {
            if (newValue) {
                pendingFilters.value.publishedDate = slidingDateRangeToString(newValue);
            }
            else {
                pendingFilters.value.publishedDate = null;
            }
        }
    });

    const internalTopics = computed<string[]>({
        get() {
            return pendingFilters.value.topics ?? [];
        },
        set(newValue: string[]) {
            pendingFilters.value.topics = newValue;
        }
    });

    const internalLicenseTypes = computed<string[]>({
        get() {
            return pendingFilters.value.licenseTypes ?? [];
        },
        set(newValue: string[]) {
            pendingFilters.value.licenseTypes = newValue;
        }
    });

    const internalExperienceLevels = computed<string[]>({
        get() {
            return pendingFilters.value.experienceLevels?.map((e: ContentLibraryItemExperienceLevel): string => e.toString()) ?? [];
        },
        set(newValue: string[]) {
            pendingFilters.value.experienceLevels = newValue.map((e: string) => ContentLibraryItemExperienceLevel[ContentLibraryItemExperienceLevelDescription[Number(e)]]);
        }
    });

    //#endregion

    //#region Functions

    /** Emits the `filteredItems` event. */
    function emitFilteredItemsChanged(): void {
        emit("filteredItems", props.items.filter(appliedFilterOptions.value.filter));

        // Save the filters person preference.
        // No need to wait for it to succeed.
        setFiltersPersonPreference(pendingFilters.value);
        preferences.save();
    }

    /** Gets the selected filters as filter options. */
    function getSelectedFilters(): FilterOptions {
        const selectedFilters: FilterOptions[] = [];

        const experienceLevels = pendingFilters.value.experienceLevels;
        if (experienceLevels?.length) {
            for (let experienceLevel of experienceLevels) {
                selectedFilters.push({
                    filterButtonText: ContentLibraryItemExperienceLevelDescription[experienceLevel],
                    filter(item) {
                        return experienceLevel === ContentLibraryItemExperienceLevel[ContentLibraryItemExperienceLevelDescription[Number(item.experienceLevel?.value)]];
                    }
                });
            }
        }

        const licenseTypeGuids = pendingFilters.value.licenseTypes;
        if (licenseTypeGuids?.length) {
            for (let licenseTypeGuid of licenseTypeGuids) {
                selectedFilters.push({
                    filterButtonText: getLicenseTypeName(licenseTypeGuid) ?? licenseTypeGuid,
                    filter(item) {
                        return !!item.licenseType?.value && licenseTypeGuid.toLowerCase() === item.licenseType.value.toLowerCase();
                    }
                });
            }
        }

        if (pendingFilters.value.mustBePopular) {
            selectedFilters.push({
                filterButtonText: "Popular",
                filter(item) {
                    return item.isPopular;
                }
            });
        }

        if (pendingFilters.value.mustBeTrending) {
            selectedFilters.push({
                filterButtonText: "Trending",
                filter(item) {
                    return item.isTrending;
                }
            });
        }

        const organizationNames = pendingFilters.value.organizations;
        if (organizationNames?.length) {
            for (let organizationName of organizationNames) {
                selectedFilters.push({
                    filterButtonText: organizationName,
                    filter(item) {
                        return !!item.sourcePublisherName && organizationName.toLowerCase() === item.sourcePublisherName.toLowerCase();
                    }
                });
            }
        }

        const publishedDate = pendingFilters.value.publishedDate;
        if (publishedDate) {
            const slidingDateRange = parseSlidingDateRangeString(publishedDate);

            if (slidingDateRange) {
                const dateRange = calculateSlidingDateRange(slidingDateRange);

                if (dateRange.start || dateRange.end) {
                    selectedFilters.push({
                        filterButtonText: "Publish Date",
                        filter(item) {
                            const itemPublishedDate = RockDateTime.parseISO(item.publishedDateTime ?? "");

                            if (!itemPublishedDate) {
                                return false;
                            }

                            if (dateRange.start && itemPublishedDate.toMilliseconds() < dateRange.start.toMilliseconds()) {
                                return false;
                            }

                            if (dateRange.end && itemPublishedDate.toMilliseconds() >= dateRange.end.toMilliseconds()) {
                                return false;
                            }

                            return true;
                        }
                    });
                }
            }
        }

        const topicGuids = pendingFilters.value.topics;
        if (topicGuids?.length) {
            for (let topicGuid of topicGuids) {
                selectedFilters.push({
                    filterButtonText: getTopicName(topicGuid) ?? topicGuid,
                    filter(item) {
                        return !!item.topic?.value && topicGuid.toLowerCase() === item.topic.value.toLowerCase();
                    }
                });
            }
        }

        if (selectedFilters.length) {
            return {
                filterButtonText: selectedFilters.length === 1 ? `Filter: ${selectedFilters[0].filterButtonText}` : `Filters Applied: ${selectedFilters.length}`,
                filter(item) {
                    return selectedFilters.some(f => f.filter(item));
                }
            };
        }
        else {
            // No filters are selected.
            return noFilter;
        }
    }

    /** Gets the person preference key for the content channel ID key. */
    function getContentChannelPersonPreferenceKey(key: PersonPreferenceKey): string {
        return `${props.contentChannelIdKey}-${key}`;
    }

    /** Gets the filters person preferences. */
    function getFiltersPersonPreference(): LibraryViewerItemFiltersBag {
        const key = props.contentChannelIdKey ? getContentChannelPersonPreferenceKey(PersonPreferenceKey.Filters) : PersonPreferenceKey.Filters;

        // Return the filters from the person preferences and fallback to the default filters.
        return getPersonPreference<LibraryViewerItemFiltersBag>(preferences, key) ?? {
            mustBePopular: false,
            mustBeTrending: false
        };
    }

    /** Sets the filters from person preferences for the content channel ID key. */
    function setFiltersPersonPreference(filters: LibraryViewerItemFiltersBag): void {
        const key = props.contentChannelIdKey ? getContentChannelPersonPreferenceKey(PersonPreferenceKey.Filters) : PersonPreferenceKey.Filters;
        setPersonPreference<LibraryViewerItemFiltersBag>(preferences, key, filters);
    }

    /** Gets the license type name for a license type guid. */
    function getLicenseTypeName(licenseTypeGuid: string | null | undefined): string | null | undefined {
        return licenseTypeOptions.value.find(o => o.value?.toLowerCase() === licenseTypeGuid?.toLowerCase())?.text;
    }

    /** Gets the topic name for a topic guid. */
    function getTopicName(topicGuid: string | null | undefined): string | null | undefined {
        return topicOptions.value.find(o => o.value?.toLowerCase() === topicGuid?.toLowerCase())?.text;
    }

    //#endregion

    //#region Event Handlers

    /**
     * Event handler for the Apply button being clicked.
     */
    function onApplyClicked(): void {
        // Update the `appliedFilterOptions` value with the selected filters.
        // There is a watcher observing this value. When the value is changed,
        // the `filteredItems` event is emitted.
        appliedFilterOptions.value = getSelectedFilters();
    }

    /**
     * Event handler for the Clear All button being clicked.
     */
    function onClearAllClicked(): void {
        pendingFilters.value = {
            mustBePopular: false,
            mustBeTrending: false
        };
    }

    //#endregion

    //#region Watchers

    watch(() => [props.items, appliedFilterOptions.value], () => {
        emitFilteredItemsChanged();
    });

    watch(() => internalModelValue.value, (wasOpen, isOpen) => {
        // If the filters controls is closed
        // AND if applyFiltersOnClose is true,
        // then apply the filters.
        if (!wasOpen && isOpen && props.areFiltersAppliedOnClose) {
            appliedFilterOptions.value = getSelectedFilters();
        }
    });

    //#endregion

    onMounted(() => {
        appliedFilterOptions.value = getSelectedFilters();
    });
</script>