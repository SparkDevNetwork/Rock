<!-- Copyright by the Spark Development Network; Licensed under the Rock Community License -->
<template>
    <div class="library-viewer-item-list-sort">
        <ToolbarMenu :getTitle="getSortTitle"
                     iconCssClass="fa fa-sort"
                     menuButtonCssClass="library-viewer-toolbar-button">
            <ToolbarMenuButtons v-model="appliedSortOption"
                                dropDownMenuAlignment="right"
                                itemClass="library-viewer-item-list-sort-button"
                                :items="sortOptions" />
        </ToolbarMenu>
    </div>
</template>

<style scoped>
    .library-viewer-item-list-sort-container {
        display: flex;
        flex-direction: column;
    }

    .library-viewer-item-list-sort-button {
        text-align: left;
        border: none;
    }
</style>

<script setup lang="ts">
    import { onMounted, PropType, ref, watch } from "vue";
    import ToolbarMenu from "./toolbarMenu.partial.obs";
    import ToolbarMenuButtons from "./toolbarMenuButtons.partial.obs";
    import { PersonPreferenceKey, MenuButton } from "./types.partial";
    import { compareDateStrings, compareNumbers, compareStrings, getPersonPreference, setPersonPreference } from "./utils.partial";
    import { usePersonPreferences } from "@Obsidian/Utility/block";
    import { LibraryViewerItemBag } from "@Obsidian/ViewModels/Blocks/Cms/LibraryViewer/libraryViewerItemBag";

    type SortOption = MenuButton & {
        sortButtonText: string;
        sort: (item1: LibraryViewerItemBag, item2: LibraryViewerItemBag) => number;
    };

    const props = defineProps({
        items: {
            type: Object as PropType<LibraryViewerItemBag[]>,
            required: true
        },
        contentChannelIdKey: {
            type: String as PropType<string | null | undefined>,
            required: false
        }
    });

    const emit = defineEmits<{
        (e: "sortedItems", value: LibraryViewerItemBag[]): void
    }>();

    const preferences = usePersonPreferences().blockPreferences;

    const defaultSortOption: SortOption = {
        sortButtonText: "Sort",
        sort(item1, item2) {
            // Multiply by -1 to sort Newest to Oldest.
            return compareDateStrings(item1?.publishedDateTime, item2?.publishedDateTime) * -1;
        }
    };

    const sortOptions: SortOption[] = [
        {
            title: "Publish Date - Newest to Oldest",
            sortButtonText: "Sort: Publish Date",
            sort(item1, item2) {
                // Multiply by -1 to sort Newest to Oldest.
                return compareDateStrings(item1?.publishedDateTime, item2?.publishedDateTime) * -1;
            }
        },
        {
            title: "Downloads - Most to Fewest",
            sortButtonText: "Sort: Downloads",
            sort(item1, item2) {
                // Multiply by -1 to sort Most to Fewest.
                return compareNumbers(item1?.downloads, item2?.downloads) * -1;
            }
        },
        {
            title: "Organization",
            sortButtonText: "Sort: Organization",
            sort(item1, item2) {
                return compareStrings(item1?.sourcePublisherName, item2?.sourcePublisherName);
            }
        }
    ];

    //#region Values

    const appliedSortOption = ref<SortOption>(getSortPersonPreference());

    //#endregion

    //#region Functions

    /** Emits the `sortedItems` event. */
    function emitSortedItems(): void {
        emit("sortedItems", [...props.items].sort(appliedSortOption.value.sort));
    }

    /** Gets the sort person preference. */
    function getSortPersonPreference(): SortOption {
        return getPersonPreference<SortOption>(preferences, getSortPersonPreferenceKey()) ?? defaultSortOption;
    }

    /** Gets the sort person preference key. */
    function getSortPersonPreferenceKey(): string {
        if (props.contentChannelIdKey) {
            return `${props.contentChannelIdKey}-${PersonPreferenceKey.Sort}`;
        }
        else {
            return PersonPreferenceKey.Sort;
        }
    }

    /** Sets the sort person preference. */
    function setSortPersonPreference(sort: SortOption): void {
        setPersonPreference<SortOption>(preferences, getSortPersonPreferenceKey(), sort);
    }

    function getSortTitle(): string {
        if (appliedSortOption.value) {
            return appliedSortOption.value.sortButtonText;
        }

        return "Sort";
    }

    //#endregion

    //#region Watchers

    watch(() => props.items, () => {
        emitSortedItems();
    });

    watch(() => appliedSortOption.value, () => {
        // Save the sort person preference.
        // No need to wait for it to succeed.
        setSortPersonPreference(appliedSortOption.value);
        preferences.save();

        emitSortedItems();

    });

    //#endregion

    onMounted(() => {
        // Emit the sorted items right away.
        emitSortedItems();
    });
</script>