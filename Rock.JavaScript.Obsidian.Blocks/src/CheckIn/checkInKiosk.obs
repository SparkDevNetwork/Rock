<!-- Copyright by the Spark Development Network; Licensed under the Rock Community License -->
<template>
    <div class="check-in-page">
        <PageHeader title="Rock Solid"
                    :hasBack="hasBackButton"
                    :hideNavigation="!hasNavigation"
                    :isOverrideMode="isOverrideMode"
                    @back="onBack"
                    @home="onHome" />

        <section class="page-body">
            <ContentTransition>
                <WelcomeScreen v-if="currentScreen === Screen.Welcome"
                               :configuration="configuration"
                               :session="currentSession"
                               @start="onNextScreen"
                               @updateActions="onUpdateActions($event, Screen.Welcome)">
                </WelcomeScreen>

                <SearchScreen v-if="currentScreen === Screen.Search"
                              :configuration="configuration"
                              :session="currentSession"
                              @next="onNextScreen"
                              @editFamily="onEditFamily"
                              @updateActions="onUpdateActions($event, Screen.Search)" />

                <FamilySelectScreen v-if="currentScreen === Screen.FamilySelect"
                                    :configuration="configuration"
                                    :session="currentSession"
                                    @next="onNextScreen"
                                    @editFamily="onEditFamily"
                                    @updateActions="onUpdateActions($event, Screen.FamilySelect)" />

                <ActionSelectScreen v-if="currentScreen === Screen.ActionSelect"
                                    :configuration="configuration"
                                    :session="currentSession"
                                    @next="onNextScreen"
                                    @updateActions="onUpdateActions($event, Screen.ActionSelect)" />

                <CheckoutSelectScreen v-if="currentScreen === Screen.CheckoutSelect"
                                      :configuration="configuration"
                                      :session="currentSession"
                                      @next="onNextScreen"
                                      @updateActions="onUpdateActions($event, Screen.CheckoutSelect)" />

                <PersonSelectScreen v-if="currentScreen === Screen.PersonSelect"
                                    :configuration="configuration"
                                    :session="currentSession"
                                    @next="onNextScreen"
                                    @editFamily="onEditFamily"
                                    @updateActions="onUpdateActions($event, Screen.PersonSelect)" />

                <AutoModeOpportunitySelectScreen v-if="currentScreen === Screen.AutoModeOpportunitySelect"
                                                 :configuration="configuration"
                                                 :session="currentSession"
                                                 @next="onNextScreen"
                                                 @updateActions="onUpdateActions($event, Screen.AutoModeOpportunitySelect)" />

                <AbilityLevelSelectScreen v-if="currentScreen === Screen.AbilityLevelSelect"
                                          :configuration="configuration"
                                          :session="currentSession"
                                          @next="onNextScreen"
                                          @updateActions="onUpdateActions($event, Screen.AbilityLevelSelect)" />

                <AreaSelectScreen v-if="currentScreen === Screen.AreaSelect"
                                  :configuration="configuration"
                                  :session="currentSession"
                                  @next="onNextScreen"
                                  @updateActions="onUpdateActions($event, Screen.AreaSelect)" />

                <GroupSelectScreen v-if="currentScreen === Screen.GroupSelect"
                                   :configuration="configuration"
                                   :session="currentSession"
                                   @next="onNextScreen"
                                   @updateActions="onUpdateActions($event, Screen.GroupSelect)" />

                <LocationSelectScreen v-if="currentScreen === Screen.LocationSelect"
                                      :configuration="configuration"
                                      :session="currentSession"
                                      @next="onNextScreen"
                                      @updateActions="onUpdateActions($event, Screen.LocationSelect)" />

                <ScheduleSelectScreen v-if="currentScreen === Screen.ScheduleSelect"
                                      :configuration="configuration"
                                      :session="currentSession"
                                      @next="onNextScreen"
                                      @updateActions="onUpdateActions($event, Screen.ScheduleSelect)" />

                <SuccessScreen v-if="currentScreen === Screen.Success"
                               :configuration="configuration"
                               :session="currentSession"
                               @updateActions="onUpdateActions($event, Screen.Success)" />

                <CheckoutSuccessScreen v-if="currentScreen === Screen.CheckoutSuccess"
                                       :configuration="configuration"
                                       :session="currentSession"
                                       @updateActions="onUpdateActions($event, Screen.CheckoutSuccess)" />

                <template v-for="supervisorScreen in supervisorScreens">
                    <component v-if="supervisorScreen.screen === currentScreen"
                               :key="supervisorScreen.screen"
                               :is="supervisorScreen.component"
                               :configuration="configuration"
                               :supervisorData="supervisorData"
                               @updateActions="onUpdateActions($event, supervisorScreen.screen)"
                               @enableOverride="onEnableOverride($event)"
                               @supervisorScreen="onSupervisorScreen"
                               @closeSupervisor="onCloseSupervisor" />
                </template>

                <template v-for="registrationScreen in registrationScreens">
                    <component v-if="registrationScreen.screen === currentScreen"
                               :key="registrationScreen.screen"
                               :is="registrationScreen.component"
                               :configuration="configuration"
                               :registrationData="registrationData"
                               @updateActions="onUpdateActions($event, registrationScreen.screen)"
                               @enableOverride="onEnableOverride($event)"
                               @registrationScreen="onRegistrationScreen"
                               @checkInFamily="onRegistrationCheckInFamily"
                               @closeRegistration="onCloseRegistration" />
                </template>
            </ContentTransition>
        </section>

        <PageFooter :title="footerStatusText" :hideConfigure="isConfigureHidden" :actions="currentScreenActions" @configure="onConfigureClick" />
    </div>
</template>

<script setup lang="ts">
    import AbilityLevelSelectScreen from "./CheckInKiosk/abilityLevelSelectScreen.partial.obs";
    import ActionSelectScreen from "./CheckInKiosk/actionSelectScreen.partial.obs";
    import AreaSelectScreen from "./CheckInKiosk/areaSelectScreen.partial.obs";
    import CheckoutSelectScreen from "./CheckInKiosk/checkoutSelectScreen.partial.obs";
    import CheckoutSuccessScreen from "./CheckInKiosk/checkoutSuccessScreen.partial.obs";
    import FamilySelectScreen from "./CheckInKiosk/familySelectScreen.partial.obs";
    import GroupSelectScreen from "./CheckInKiosk/groupSelectScreen.partial.obs";
    import LocationSelectScreen from "./CheckInKiosk/locationSelectScreen.partial.obs";
    import AutoModeOpportunitySelectScreen from "./CheckInKiosk/autoModeOpportunitySelectScreen.partial.obs";
    import PageFooter from "./CheckInKiosk/pageFooter.partial.obs";
    import PageHeader from "./CheckInKiosk/pageHeader.partial.obs";
    import PersonSelectScreen from "./CheckInKiosk/personSelectScreen.partial.obs";
    import RegistrationEditFamilyScreen from "./CheckInKiosk/registrationEditFamilyScreen.partial.obs";
    import RegistrationEditIndividualScreen from "./CheckInKiosk/registrationEditIndividualScreen.partial.obs";
    import ScheduleSelectScreen from "./CheckInKiosk/scheduleSelectScreen.partial.obs";
    import SearchScreen from "./CheckInKiosk/searchScreen.partial.obs";
    import SuccessScreen from "./CheckInKiosk/successScreen.partial.obs";
    import SupervisorActionsScreen from "./CheckInKiosk/supervisorActionsScreen.partial.obs";
    import SupervisorLoginScreen from "./CheckInKiosk/supervisorLoginScreen.partial.obs";
    import SupervisorReprintScreen from "./CheckInKiosk/supervisorReprintScreen.partial.obs";
    import SupervisorScheduleLocationsScreen from "./CheckInKiosk/supervisorScheduleLocationsScreen.partial.obs";
    import WelcomeScreen from "./CheckInKiosk/welcomeScreen.partial.obs";
    import ContentTransition from "./CheckInKiosk/contentTransition.partial.obs";
    import { Component as VueComponent, computed, onBeforeUnmount, onMounted, ref, shallowRef } from "vue";
    import { useConfigurationValues, useInvokeBlockAction } from "@Obsidian/Utility/block";
    import { getTopic, ITopic } from "@Obsidian/Utility/realTime";
    import { provideKioskState } from "./CheckInKiosk/utils.partial";
    import { SupervisorScreen, SupervisorScreenData, KioskButton, Screen, RegistrationScreen, RegistrationScreenData, KioskConfiguration } from "./CheckInKiosk/types.partial";
    import { KioskConfigurationBag } from "@Obsidian/ViewModels/Blocks/CheckIn/CheckInKiosk/kioskConfigurationBag";
    import { CheckInSession } from "./CheckInKiosk/checkInSession.partial";
    import { useHttp } from "@Obsidian/Utility/http";
    import { SavedKioskConfigurationBag } from "@Obsidian/ViewModels/Blocks/CheckIn/CheckInKiosk/savedKioskConfigurationBag";
    import { SubscribeToRealTimeResponseBag } from "@Obsidian/ViewModels/Blocks/CheckIn/CheckInKiosk/subscribeToRealTimeResponseBag";
    import { FamilySearchMode } from "@Obsidian/Enums/CheckIn/familySearchMode";
    import { AttendanceUpdatedMessageBag } from "@Obsidian/ViewModels/Event/attendanceUpdatedMessageBag";
    import { Guid } from "@Obsidian/Types";

    const blockConfiguration = useConfigurationValues<Record<string, unknown>>();
    const invokeBlockAction = useInvokeBlockAction();
    const http = useHttp();

    const kioskState: Record<string, unknown> = {};

    provideKioskState(kioskState);

    // #region Values

    const configuration = ref<KioskConfiguration>({
        locationIdMap: {},
        groupIdMap: {},
        on: watchConfigurationEvent,
        off: unwatchConfigurationEvent
    });
    const currentScreen = ref<Screen | SupervisorScreen | RegistrationScreen>(Screen.None);
    const currentScreenActions = ref<KioskButton[]>([]);
    const currentSession = shallowRef<CheckInSession>(createNewSession());
    const previousScreens = shallowRef<CheckInSession[]>([]);
    let currentAttendeeId: string | undefined | null;
    let lastActivity: number = Date.now();
    let idleTimer: number | undefined;
    let realTimeTopic: ITopic | undefined;
    const activityEvents = ["mousemove", "mousedown", "touchmove", "touchstart", "keydown"];
    const configurationEvents: Record<string, unknown[]> = {};

    const supervisorData = ref<SupervisorScreenData>({ pinCode: "" });
    const supervisorScreens = ref<{ screen: SupervisorScreen, component: VueComponent }[]>([
        {
            screen: SupervisorScreen.Login,
            component: SupervisorLoginScreen
        },
        {
            screen: SupervisorScreen.Actions,
            component: SupervisorActionsScreen
        },
        {
            screen: SupervisorScreen.Reprint,
            component: SupervisorReprintScreen
        },
        {
            screen: SupervisorScreen.ScheduleLocations,
            component: SupervisorScheduleLocationsScreen
        }
    ]);

    const registrationData = ref<RegistrationScreenData>({} as RegistrationScreenData);
    const registrationScreens = ref<{ screen: RegistrationScreen, component: VueComponent }[]>([
        {
            screen: RegistrationScreen.EditFamily,
            component: RegistrationEditFamilyScreen
        },
        {
            screen: RegistrationScreen.EditIndividual,
            component: RegistrationEditIndividualScreen
        }
    ]);

    // #endregion

    // #region Computed Values

    const hasNavigation = computed((): boolean => {
        return currentScreen.value !== Screen.Welcome;
    });

    const hasBackButton = computed((): boolean => {
        return currentScreen.value !== Screen.Welcome
            && currentScreen.value !== Screen.Success
            && currentScreen.value !== Screen.CheckoutSuccess
            && previousScreens.value.length > 0;
    });

    const footerStatusText = computed((): string => {
        if (!configuration.value.kiosk || !configuration.value.template) {
            return "";
        }

        return `${configuration.value.kiosk.name} Â· ${configuration.value.template.name}`;
    });

    /** Kiosk is current in override mode which bypasses some filtering logic. */
    const isOverrideMode = computed((): boolean => {
        return currentSession.value.overridePinCode !== undefined
            && currentSession.value.overridePinCode !== "";
    });

    /**
     * The configure button should be hidden if we are in the configure
     * screens already.
     */
    const isConfigureHidden = computed((): boolean => {
        return currentScreen.value >= SupervisorScreen.Login;
    });

    // #endregion

    // #region Functions

    /**
     * Reads configuration from local storage. This is set by the setup block
     * before redirecting to us. If everything is valid then show the welcome
     * screen. Otherwise redirect to the setup page.
     */
    async function readConfigurationFromLocalStorage(): Promise<void> {
        const json = localStorage.getItem("Rock.CheckIn.CheckInKiosk.Configuration");

        if (!json) {
            return redirectToSetupPage();
        }

        try {
            const savedConfig = JSON.parse(json) as SavedKioskConfigurationBag;
            const data = {
                savedConfiguration: savedConfig
            };

            const result = await invokeBlockAction<KioskConfigurationBag>("GetKioskConfiguration", data);

            if (result.isSuccess && result.data) {
                configuration.value = {
                    ...result.data,
                    locationIdMap: configuration.value.locationIdMap,
                    groupIdMap: configuration.value.groupIdMap,
                    on: watchConfigurationEvent,
                    off: watchConfigurationEvent
                };
                navigateToScreen(Screen.Welcome);
            }
            else {
                redirectToSetupPage();
            }
        }
        catch {
            redirectToSetupPage();
        }
    }

    /**
     * Adds a new callback to the named configuration event.
     *
     * @param event The name of the event.
     * @param callback The callback function to be called.
     */
    function watchConfigurationEvent(event: string, callback: unknown): void {
        if (!configurationEvents[event]) {
            configurationEvents[event] = [];
        }

        configurationEvents[event].push(callback);
    }

    /**
     * Removes a callback from the named configuration event.
     *
     * @param event The name of the event.
     * @param callback The callback function to no longer be called.
     */
    function unwatchConfigurationEvent(event: string, callback: unknown): void {
        if (configurationEvents[event]) {
            const index = configurationEvents[event].indexOf(callback);

            if (index >= 0) {
                configurationEvents[event].splice(index, 1);
            }
        }
    }

    /**
     * Emits the named configuration event.
     *
     * @param event The name of the event.
     * @param args The arguments to pass to the callbacks.
     */
    function emitConfigurationEvent(event: string, ...args: unknown[]): void {
        const callbacks = configurationEvents[event];

        if (!callbacks) {
            return;
        }

        for (const callback of callbacks) {
            const fn = callback as (...args: unknown[]) => void;
            fn(...args);
        }
    }

    function redirectToSetupPage(): void {
        if (!blockConfiguration.setupPageRoute) {
            throw new Error("Kiosk Setup is required but setup page has not been configured.");
        }

        window.location.href = blockConfiguration.setupPageRoute as string;
    }

    function createNewSession(): CheckInSession {
        let session = new CheckInSession(configuration.value, http);

        if (blockConfiguration.apiKey) {
            session = session.withApiKey(blockConfiguration.apiKey as string);
        }

        return session;
    }

    function navigateToScreen(screen: Screen): void {
        currentScreenActions.value = [];
        currentScreen.value = screen;

        // Delete any pending attendance records created, this should be moved
        // to the session object.
        if (screen === Screen.Welcome) {
            // This is async, but we don't need to wait for it to complete.
            currentSession.value.cancelSession();

            currentSession.value = createNewSession();
            previousScreens.value = [];

            // If we lost real-time connection, force a reconnect.
            if (realTimeTopic?.isDisconnected) {
                const url = window.location.href;
                window.location.href = url;
            }
        }
    }

    /**
     * Initialize the real-time engine and start monitoring for updates to the
     * proxy connection status messages.
     */
    async function setupRealTime(): Promise<void> {
        realTimeTopic = await getTopic("Rock.RealTime.Topics.EntityUpdatedTopic");

        const request = {
            connectionId: realTimeTopic.connectionId,
            kioskId: configuration.value.kiosk?.id,
            areaIds: configuration.value.areas?.map(a => a.id)
        };

        realTimeTopic.on("attendanceUpdated", onAttendanceUpdated);
        realTimeTopic.on("attendanceDeleted", onAttendanceDeleted);

        const result = await invokeBlockAction<SubscribeToRealTimeResponseBag>("SubscribeToRealTime", request);

        if (result.isSuccess) {
            if (result.data?.locationMap) {
                for (const loc of result.data.locationMap) {
                    if (loc.guid && loc.idKey) {
                        configuration.value.locationIdMap[loc.guid] = loc.idKey;
                    }
                }
            }
            if (result.data?.groupMap) {
                for (const loc of result.data.groupMap) {
                    if (loc.guid && loc.idKey) {
                        configuration.value.groupIdMap[loc.guid] = loc.idKey;
                    }
                }
            }
        }
    }

    // #endregion

    // #region Event Handlers

    function onUpdateActions(actions: KioskButton[], source: Screen | SupervisorScreen | RegistrationScreen): void {
        if (currentScreen.value === source) {
            currentScreenActions.value = actions;
        }
    }

    function onNextScreen(session: CheckInSession): void {
        previousScreens.value = [...previousScreens.value, currentSession.value];

        // Prevent moving back to a previous attendee if we have any attendance
        // records created.
        if (session.attendances.length > 0 && currentAttendeeId !== session.getCurrentAttendee()?.person?.id) {
            previousScreens.value = [];
        }

        currentAttendeeId = session.getCurrentAttendee()?.person?.id;
        currentSession.value = session;

        navigateToScreen(session.currentScreen);
    }

    function onHome(): void {
        navigateToScreen(Screen.Welcome);
    }

    function onBack(): void {
        currentSession.value = previousScreens.value[previousScreens.value.length - 1];

        var newPreviousScreens: CheckInSession[] = [...previousScreens.value];
        newPreviousScreens.splice(newPreviousScreens.length - 1, 1);

        previousScreens.value = newPreviousScreens;
        currentScreenActions.value = [];
        currentScreen.value = currentSession.value.currentScreen;
    }

    /**
     * Called when one of the activity producing events happens in the UI.
     * This will reset the last activity to now, which resets the idle timeout.
     */
    function onWindowActivity(): void {
        lastActivity = Date.now();
    }

    /**
     * Called on every tick of the idle timer to check if we need to redirect
     * back to the welcome screen.
     */
    function onIdleTimerCheck(): void {
        if (currentScreen.value === Screen.Welcome) {
            if (realTimeTopic?.isDisconnected) {
                // Redirect back to ourselves to try and reconnect.
                const url = window.location.href;
                window.location.href = url;
            }

            return;
        }
        if (currentScreen.value >= SupervisorScreen.Login) {
            return;
        }

        if (Date.now() - lastActivity > 20000) {
            navigateToScreen(Screen.Welcome);
        }
    }

    /**
     * Called when we receive a RealTime message that an attendance record
     * has been created or updated.
     *
     * @param attendance The details about the attendance record.
     */
    function onAttendanceUpdated(attendance: AttendanceUpdatedMessageBag): void {
        emitConfigurationEvent("attendanceUpdated", attendance);

        if (supervisorData.value?.counts && attendance.isNew) {
            // Add the attendance to the supervisor data.
            const locationId = configuration.value.locationIdMap[attendance.locationGuid ?? ""];
            const groupId = configuration.value.groupIdMap[attendance.groupGuid ?? ""];
            if (locationId && groupId) {
                supervisorData.value.counts.attendance?.push({
                    id: attendance.attendanceIdKey,
                    locationId: locationId,
                    groupId: groupId,
                    status: attendance.checkInStatus
                });
            }
        }
    }

    /**
     * Called when we receive a RealTime message that an attendance record has
     * been deleted from the system.
     *
     * @param attendanceGuid The unique identifier of the attendance record.
     * @param attendance The details about the attendance record.
     */
    function onAttendanceDeleted(_attendanceGuid: Guid, attendance?: AttendanceUpdatedMessageBag | null): void {
        if (supervisorData.value?.counts?.attendance) {
            // Remove the attendance record from the supervisor data.
            const index = supervisorData.value.counts.attendance.findIndex(a => a.id === attendance?.attendanceIdKey);

            if (index >= 0) {
                supervisorData.value.counts.attendance.splice(index, 1);
            }
        }
    }

    // #endregion

    // #region Supervisor Functions

    /**
     * Called when the configure button is clicked. Show the supervisor login
     * screen to allow to kiosk administration.
     */
    function onConfigureClick(): void {
        previousScreens.value = [];
        currentScreen.value = SupervisorScreen.Login;
    }

    /**
     * Called when the supervisor screen wants to enter override mode. Configure
     * a new session in override mode.
     *
     * @param pinCode The PIN code to use when authorizing override mode to the REST APIs.
     */
    async function onEnableOverride(pinCode: string): Promise<void> {
        // This is async, but we don't need to wait for it to complete.
        currentSession.value.cancelSession();

        currentSession.value = createNewSession().withStartOverride(pinCode);
        previousScreens.value = [];

        navigateToScreen(currentSession.value.currentScreen);
    }

    function onSupervisorScreen(screen: SupervisorScreen): void {
        currentScreen.value = screen;
    }

    /**
     * Called when the supervisor screen should be closed. This will return to
     * the welcome screen.
     */
    function onCloseSupervisor(): void {
        navigateToScreen(Screen.Welcome);
    }

    // #endregion

    // #region Registration Functions

    /**
     * Called when the supervisor wants to edit the current family.
     */
    function onEditFamily(data: RegistrationScreenData): void {
        previousScreens.value = [];
        registrationData.value = data;
        currentScreen.value = RegistrationScreen.EditFamily;
    }

    function onRegistrationScreen(screen: RegistrationScreen): void {
        currentScreen.value = screen;
    }

    async function onRegistrationCheckInFamily(familyId: string): Promise<void> {
        const blankSession = createNewSession();

        let session = await blankSession.withFamilySearch(familyId, FamilySearchMode.FamilyId);

        if (!session.families || session.families.length === 0) {
            return onNextScreen(createNewSession());
        }

        session = await session.withFamily(familyId);
        session = await session.withNextScreen();

        // Make the back button go back to the welcome screen.
        currentSession.value = blankSession;

        onNextScreen(session);
    }

    /**
     * Called when the registration screen should be closed. This will return
     * to the welcome screen.
     */
    function onCloseRegistration(): void {
        navigateToScreen(Screen.Welcome);
    }

    // #endregion

    // Read our check-in configuration and then start up.
    readConfigurationFromLocalStorage();
    setupRealTime();

    onMounted(() => {
        activityEvents.forEach(ev => {
            window.addEventListener(ev, onWindowActivity);
        });

        idleTimer = window.setInterval(onIdleTimerCheck, 1000);
    });

    onBeforeUnmount(() => {
        activityEvents.forEach(ev => {
            window.removeEventListener(ev, onWindowActivity);
        });

        if (idleTimer !== undefined) {
            window.clearInterval(idleTimer);
            idleTimer = undefined;
        }
    });
</script>
