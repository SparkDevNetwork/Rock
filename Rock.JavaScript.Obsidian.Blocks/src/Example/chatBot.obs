<template>
    <div class="chat-container" ref="chatContainer">
        <div class="sessions-column">
            <div class="sessions-container" ref="sessionsContainer">
                <div v-for="session in sessions"
                     :key="session.id"
                     class="session"
                     :class="{ 'active': session.id === sessionId }"
                     @click="onSelectSession(session.id)">
                    <strong>{{ session.name || "Unnamed Session" }}</strong><br>
                    {{ RockDateTime.parseISO(session.lastMessageDateTime!)?.localDateTime.toASPString("g") }}
                </div>
            </div>

            <RockButton btnType="info"
                        autoDisable
                        @click="onNewSession">
                New Session
            </RockButton>
        </div>

        <div class="conversation-container">
            <div class="well messages-container" ref="messagesContainer">
                <div v-for="(message, index) in messages"
                     :key="index"
                     class="message"
                     :class="getMessageClass(message)"
                     :title="getTokenCounts(message)">
                    <span class="message-text" v-html="parse(message.message)"></span>
                </div>
            </div>

            <div v-if="sortedAnchors.length > 0" class="anchors-container">
                <div v-for="anchor in sortedAnchors"
                     :key="anchor.id"
                     class="anchor">
                    <span class="anchor-type">{{ anchor.entityTypeName }}</span>
                    <span class="anchor-text">{{ anchor.name }}</span>
                    <span class="anchor-clear" @click="onDeleteAnchor(anchor.entityTypeId)"><i class="ti ti-x"></i></span>
                </div>
            </div>

            <div>
                <TextBox v-model="message"
                         placeholder="Type your message here..."
                         @keyup.enter="onSubmit">
                    <template #inputGroupAppend>
                        <span class="input-group-btn">
                            <button class="btn btn-primary"
                                    :disabled="isSendDisabled"
                                    @click.prevent="onSubmit">Send</button>
                        </span>
                    </template>
                </TextBox>
            </div>
        </div>
    </div>
</template>

<style scoped>
.chat-container {
    display: flex;
    flex-direction: row;
    gap: var(--spacing-small);
}

.sessions-column {
    display: flex;
    flex-direction: column;
    gap: var(--spacing-small);
}

.sessions-container {
    display: flex;
    flex-direction: column;
    gap: var(--spacing-small);
    flex-grow: 1;
    overflow-y: auto;
}

.sessions-container :first-child {
    margin-top: auto;
}

.session {
    background-color: var(--color-info-soft);
    color: var(--color-info-strong);
    padding: var(--spacing-small);
    border-radius: var(--rounded-small);
    cursor: pointer;
    min-width: 200px;
}

.session.active {
    border: 2px solid var(--color-info-strong);
    cursor: initial;
}

.conversation-container {
    display: flex;
    flex-direction: column;
    flex-grow: 1;
    gap: var(--spacing-small);
}

.messages-container {
    display: flex;
    flex-direction: column;
    flex-grow: 1;
    overflow-y: auto;
    gap: var(--spacing-small);
    margin-bottom: 0;
    padding: var(--spacing-medium);
    background-color: var(--color-interface-softer);
    border: 1px solid var(--color-interface-soft);
    border-radius: var(--rounded-small);
}

.message {
    padding: var(--spacing-tiny) var(--spacing-small);
    border-radius: var(--rounded-medium);
    max-width: 75%;
}

.message-user {
    background-color: #4298e5;
    color: white;
    margin-left: auto;
}

.message-assistant {
    background-color: #dfdfdf;
    color: #333;
    margin-right: auto;
}

.anchors-container {
    display: flex;
    gap: var(--spacing-xsmall);
}

.anchor {
    border: 1px solid var(--color-success-strong);
    background-color: var(--color-success-soft);
    color: var(--color-success-strong);
    font-size: var(--font-size-small);
    display: flex;
    border-radius: 12px;
    height: 24px;
    line-height: 1em;
    align-items: center;
    padding: 0 8px 0 12px;
    gap: 8px;
}

.anchor-type {
    font-weight: var(--font-weight-semibold);
}

.anchor-type::after {
    content: ":";
}

.anchor-clear {
    font-size: calc(0.77 * var(--font-size-xsmall));
    padding-top: 2px;
    cursor: pointer;
}
</style>

<script setup lang="ts">
    import RockButton from "@Obsidian/Controls/rockButton.obs";
    import TextBox from "@Obsidian/Controls/textBox.obs";
    import { parse } from "@Obsidian/Libs/marked";
    import { useConfigurationValues, useInvokeBlockAction } from "@Obsidian/Utility/block";
    import { alert } from "@Obsidian/Utility/dialogs";
    import { asFormattedString } from "@Obsidian/Utility/numberUtils";
    import { RockDateTime } from "@Obsidian/Utility/rockDateTime";
    import { computed, nextTick, onBeforeUnmount, onMounted, reactive, ref } from "vue";

    const enum AuthorRole {
        User = 0,

        Assistant = 1
    }

    type ChatBotConfigurationBag = {
        error?: string | null;

        sessionId?: number | null;

        sessions?: ChatSessionBag[] | null;

        messages?: ChatMessageBag[] | null;

        anchors?: ChatAnchorBag[] | null;
    };

    type ChatSessionBag = {
        id: number;

        name?: string | null;

        lastMessageDateTime?: string | null;
    };

    type ChatMessageBag = {
        role: AuthorRole;

        message?: string | null;

        tokenCount: number;

        consumedTokenCount: number;
    };

    type ChatAnchorBag = {
        id: number;

        entityTypeId: number;

        entityTypeName?: string | null;

        name?: string | null;
    };

    const config = useConfigurationValues<ChatBotConfigurationBag>();
    const invokeBlockAction = useInvokeBlockAction();

    const chatContainer = ref<HTMLDivElement>();
    const sessionsContainer = ref<HTMLDivElement>();
    const messagesContainer = ref<HTMLDivElement>();

    const message = ref("");
    const isSending = ref(false);
    const messages = reactive(config.messages ?? []);
    const sessions = reactive(config.sessions ?? []);
    const anchors = reactive(config.anchors ?? []);
    const sessionId = ref(config.sessionId ?? 0);

    const isSendDisabled = computed((): boolean => {
        return isSending.value || !message.value;
    });

    const sortedAnchors = computed((): ChatAnchorBag[] => {
        return anchors.sort((a, b) => a.entityTypeName?.localeCompare(b.entityTypeName ?? "") || 0);
    });

    function updateContainerHeight(): void {
        if (!chatContainer.value) {
            return;
        }

        const top = chatContainer.value.getBoundingClientRect().y;
        chatContainer.value.style.height = `${window.innerHeight - top - 75}px`;
    }

    function getMessageClass(message: ChatMessageBag): string {
        return message.role === AuthorRole.User ? "message-user" : "message-assistant";
    }

    function getTokenCounts(message: ChatMessageBag): string {
        if (message.role === AuthorRole.User) {
            return `Tokens: ${asFormattedString(message.tokenCount)}`;
        }

        return `Input tokens: ${asFormattedString(message.consumedTokenCount - message.tokenCount)}; Output token: ${asFormattedString(message.tokenCount)}`;
    }

    function updateSessionDate(): void {
        const session = sessions.find(s => s.id === sessionId.value);

        if (session) {
            session.lastMessageDateTime = RockDateTime.now().toISOString();
        }

        updateSessionOrder();
    }

    function updateSessionOrder(): void {
        sessions.sort((a, b) => {
            const da = RockDateTime.parseISO(a.lastMessageDateTime ?? "");
            const db = RockDateTime.parseISO(b.lastMessageDateTime ?? "");

            if (!da) {
                return 1;
            }

            if (!db) {
                return -1;
            }

            return da.toMilliseconds() - db.toMilliseconds();
        });
    }

    async function onSubmit(): Promise<void> {
        if (!message.value) {
            return;
        }

        var msg = message.value;

        message.value = "";

        if (msg.startsWith("#")) {
            return onSpecialCommand(msg);
        }

        messages.push({
            role: AuthorRole.User,
            message: msg,
            tokenCount: 0,
            consumedTokenCount: 0
        });
        nextTick(() => messagesContainer.value?.scrollTo(0, messagesContainer.value.scrollHeight));

        isSending.value = true;
        try {
            const response = await invokeBlockAction<ChatMessageBag>("SendMessage", { message: msg, sessionId: sessionId.value });

            if (response.isSuccess && response.data) {
                messages.push(response.data);
                updateSessionDate();
                nextTick(() => messagesContainer.value?.scrollTo(0, messagesContainer.value.scrollHeight));
            }
            else {
                await alert(response.errorMessage ?? "Unknown error while trying to send message.");
                messages.pop(); // Remove the user's message if sending failed.
            }
        }
        finally {
            isSending.value = false;
        }
    }

    async function onSpecialCommand(command: string): Promise<void> {
        if (command.startsWith("#anchor ")) {
            const parts = command.split(" ");
            if (parts.length !== 3) {
                await alert("Invalid anchor command. Usage: #anchor <EntityTypeName> <EntityId>");
                return;
            }

            const entityTypeName = parts[1];
            const entityId = parseInt(parts[2]);

            const result = await invokeBlockAction<ChatAnchorBag[]>("CreateAnchor", { sessionId: sessionId.value, entityTypeName, entityId });

            if (result.isSuccess && result.data) {
                anchors.splice(0, anchors.length, ...result.data);
            }
            else {
                await alert(result.errorMessage || "Unknown error while trying to add anchor.");
            }
            return;
        }

        await alert(`Unknown command: ${command}`);
    }

    async function onDeleteAnchor(entityTypeId: number): Promise<void> {
        const result = await invokeBlockAction("DeleteAnchor", { sessionId: sessionId.value, entityTypeId });

        if (result.isSuccess) {
            const index = anchors.findIndex(a => a.entityTypeId === entityTypeId);
            if (index !== -1) {
                anchors.splice(index, 1);
            }
        }
        else {
            await alert(result.errorMessage || "Unknown error while trying to delete anchor.");
        }
    }

    async function onSelectSession(id: number): Promise<void> {
        if (sessionId.value === id) {
            return;
        }

        const result = await invokeBlockAction<{ messages: ChatMessageBag[], anchors: ChatAnchorBag[] }>("LoadSession", { sessionId: id });

        if (result.isSuccess && result.data) {
            sessionId.value = id;
            messages.splice(0, messages.length, ...result.data.messages);
            anchors.splice(0, anchors.length, ...result.data.anchors);
            updateSessionOrder();
        }
        else {
            await alert(result.errorMessage ?? "Unknown error while trying to load session messages.");
        }
    }

    async function onNewSession(): Promise<void> {
        const result = await invokeBlockAction<ChatSessionBag>("StartNewSession");

        if (result.isSuccess && result.data) {
            sessionId.value = result.data.id;
            messages.splice(0, messages.length);
            anchors.splice(0, anchors.length);
            sessions.push(result.data);
            nextTick(() => sessionsContainer.value?.scrollTo(0, sessionsContainer.value.scrollHeight));
        }
        else {
            await alert(result.errorMessage ?? "Unknown error while trying to start new session.");
        }
    }

    onMounted(() => {
        updateContainerHeight();
        messagesContainer.value?.scrollTo(0, messagesContainer.value.scrollHeight);
        sessionsContainer.value?.scrollTo(0, sessionsContainer.value.scrollHeight);

        window.addEventListener("resize", updateContainerHeight);
    });

    onBeforeUnmount(() => {
        window.removeEventListener("resize", updateContainerHeight);
    });
</script>
