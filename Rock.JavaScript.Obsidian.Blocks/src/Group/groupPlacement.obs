<!-- Copyright by the Spark Development Network; Licensed under the Rock Community License -->
<template>
    <Panel type="block" panelBodyCssClass="overflow-hidden" class="styled-scroll">
        <template #title>
            <div class="d-flex align-items-center">
                <span v-if="!isNullOrWhiteSpace(box.backPageUrl)" class="clickable text-sm mr-3" @click="onBack">
                    <i class="fa fa-chevron-left d-block"></i>
                </span>
                <h1 class="panel-title">
                    {{ box.title }}
                </h1>
            </div>
        </template>

        <template #headerActions>
            <div class="d-flex gap-1 mr-3">
                <div class="dropdown">
                    <RockButton :btnType="BtnType.Default"
                                :btnSize="BtnSize.Small"
                                :isSquare="true"
                                title="Sort Items"
                                data-toggle="dropdown">
                        <i class="fa fa-sort"></i>
                    </RockButton>
                    <ul class="dropdown-menu dropdown-menu-right">
                        <li v-for="[key, label] in sortOptions" :key="key">
                            <a href="#" @click.prevent="changeSort(key)">
                                {{ label }}
                            </a>
                        </li>
                    </ul>
                </div>
                <RockButton :btnType="BtnType.Default"
                            :btnSize="BtnSize.Small"
                            :isSquare="true"
                            title="Gender Highlight"
                            @click="toggleHighlightGender">
                    <i class="fa fa-venus-mars"></i>
                </RockButton>
                <RockButton :btnType="BtnType.Default"
                            :btnSize="BtnSize.Small"
                            :isSquare="true"
                            title="Toggle Details"
                            @click="toggleCardExpansion">
                    <i class="fa fa-info-circle"></i>
                </RockButton>
                <RockButton :btnType="BtnType.Default"
                            :btnSize="BtnSize.Small"
                            :isSquare="true"
                            title="Settings"
                            @click="openPlacementConfigSettings">
                    <i class="fa fa-cog"></i>
                </RockButton>
            </div>
        </template>

        <div class="d-flex w-100 h-100">
            <div class="col-xs-5 col-md-4 col-lg-3 p-0 h-100 helper-height">
                <Panel type="default"
                       title="People To Place"
                       panelBodyCssClass="h-100 overflow-hidden">
                    <template #headerActions>
                        <RockButton :btnType="BtnType.Default"
                                    :btnSize="BtnSize.Small"
                                    :isSquare="true"
                                    title="Search People"
                                    :class="['mr-3', { 'active': isPersonSearchVisible }]"
                                    @click="toggleIsPersonSearchVisible">
                            <i class="fa fa-search"></i>
                        </RockButton>
                    </template>
                    <template #subheaderLeft>
                        <transition name="slide">
                            <div v-show="isPersonSearchVisible" ref="personSearchContainerElement" class="p-3">
                                <TextBox v-model="personSearchText" placeholder="Search" isClearable>
                                    <template #inputGroupPrepend>
                                        <div class="input-group-addon">
                                            <i class="fa fa-search"></i>
                                        </div>
                                    </template>
                                </TextBox>
                            </div>
                        </transition>
                    </template>

                    <!-- TODO: See about adding "Filter" to drawer. -->
                    <template v-if="Object.keys(sourceAttributesForFilter).length > 0 || registrantFeeItemsForFilter.length > 0" #drawer>
                        <AttributeValuesContainer v-model="pendingSourceAttributeValuesForFilter" :attributes="sourceAttributesForFilter" isEditMode :numberOfColumns="1" />
                        <DropDownList v-model="pendingRegistrantFeeItemValuesForFilter"
                                      v-if="placementConfigurationSettings.areFeesDisplayed"
                                      label="Fees"
                                      :items="registrantFeeItemsForFilter ?? []"
                                      :enhanceForLongLists="true"
                                      :multiple="true" />
                        <RockButton :btnType="BtnType.Action"
                                    :btnSize="BtnSize.ExtraSmall"
                                    @click="applyPeopleFilter"
                                    class="mr-2">
                            Apply Filter
                        </RockButton>
                        <RockButton :btnType="BtnType.Default"
                                    :btnSize="BtnSize.ExtraSmall"
                                    @click="clearPeopleFilters">
                            Clear Filter
                        </RockButton>
                    </template>

                    <div class="people-to-place-panel-body">
                        <div class="w-100 p-2 pb-0">
                            <div class="d-flex justify-content-start">
                                <HighlightLabel v-if="sourcePerson" labelType="custom" customClass="source-person-label">
                                    {{ sourcePerson.firstName }} {{ sourcePerson.lastName }} <i class="fa fa-times cursor-pointer" @click="removeSourcePerson"></i>
                                </HighlightLabel>
                            </div>
                            <div class="d-flex justify-content-between align-items-center">
                                <div class="prevent-clear">
                                    <CheckBox v-model="areAllPeopleSelected"
                                              label=""
                                              text="Select All"
                                              @click="toggleSelectAllCheckbox()" />
                                </div>
                                <span class="text-muted">{{ selectedPeopleCount }} Selected
                                    <i ref="selectionInfoElement"
                                       class="fa fa-info-circle cursor-pointer"
                                       data-toggle="tooltip"
                                       title="Ctrl (Mac: Cmd) + Click to select multiple people.">
                                    </i>
                                </span>
                            </div>
                        </div>
                        <div v-drag-source="personDragSourceOptions" v-drag-target="groupMemberDragSourceOptions.id" class="people-to-place-card-container">
                            <template v-for="(person, index) in filteredAndSortedPeopleToPlace" v-if="filteredAndSortedPeopleToPlace.length > 0">
                                <PersonCard v-if="person.personIdKey"
                                            :key="index"
                                            :data-person-id-key="person.personIdKey"
                                            :isCardExpanded="arePersonCardsExpanded"
                                            :person="person"
                                            :index="index"
                                            :isSelected="isSelected(person.personIdKey)"
                                            :isInstanceDisplayed="placementConfigurationSettings.showRegistrationInstanceName"
                                            :areFeesDisplayed="placementConfigurationSettings.areFeesDisplayed"
                                            :isFirstNameLastName="currentSortOrder === SortTypes.SortByFirstName"
                                            :isGenderHighlighting="isGenderHighlighting"
                                            :placementMode="box.placementMode"
                                            @toggleCardExpansion="toggleCardExpansion"
                                            @toggleSelection="toggleSelection(person.personIdKey)" />
                            </template>
                            <div v-else-if="arePeopleLoading" class="d-flex align-items-center justify-content-center">
                                <Loading :isLoading="arePeopleLoading" />
                            </div>
                            <div v-else>
                                <span v-if="!isNoPeopleLabelHidden" class="no-people-label">No People Available</span>
                            </div>
                        </div>
                    </div>

                </Panel>

            </div>

            <div class="col-xs-7 col-md-8 col-lg-9 p-0 h-100 helper-height">
                <Panel type="default" title="Destination Groups" panelBodyCssClass="h-100 overflow-hidden">
                    <template #headerActions>
                        <div class="d-flex gap-1 mr-3">
                            <RockButton :btnType="BtnType.Default"
                                        :btnSize="BtnSize.Small"
                                        title="Add Group"
                                        @click="openAddGroupModal">
                                <i class="fa fa-group text-xs mr-2"></i>
                                <span>Add Group</span>
                            </RockButton>

                            <RockButton :btnType="BtnType.Default"
                                        :btnSize="BtnSize.Small"
                                        :isSquare="true"
                                        @click="toggleGroupExpansion">
                                <i :class="areGroupsExpanded ? 'fa fa-angle-double-up' : 'fa fa-angle-double-down'"></i>
                            </RockButton>
                        </div>
                    </template>

                    <!-- TODO: See about adding "Filter" to drawer. -->
                    <template #drawer v-if="Object.keys(destinationGroupAttributesForFilter).length > 0 || Object.keys(destinationGroupMemberAttributesForFilter).length > 0">
                        <AttributeValuesContainer v-model="pendingDestinationGroupAttributeValuesForFilter"
                                                  :attributes="destinationGroupAttributesForFilter"
                                                  isEditMode
                                                  :numberOfColumns="3"
                                                  columnBreakpoint="lg"
                                                  :showCategoryLabel="false" />
                        <div class="w-100 mb-2">
                            <RockLabel v-if="Object.keys(destinationGroupMemberAttributesForFilter).length > 0"
                                       @click="toggleIsGroupMemberFilterDisplayed"
                                       class="group-member-filter-toggle">
                                Group Member Filters <i :class="groupMemberFilterIcon"></i>
                            </RockLabel>
                            <TransitionVerticalCollapse>
                                <div v-show="isGroupMemberFilterDisplayed">
                                    <AttributeValuesContainer v-model="pendingDestinationGroupMemberAttributeValuesForFilter"

                                                              :attributes="destinationGroupMemberAttributesForFilter"
                                                              isEditMode
                                                              :numberOfColumns="3"
                                                              columnBreakpoint="lg"
                                                              :showCategoryLabel="false" />
                                </div>
                            </TransitionVerticalCollapse>
                        </div>
                        <RockButton :btnType="BtnType.Action"
                                    :btnSize="BtnSize.ExtraSmall"
                                    @click="applyGroupFilter"
                                    class="mr-2">
                            Apply Filter
                        </RockButton>
                        <RockButton :btnType="BtnType.Default"
                                    :btnSize="BtnSize.ExtraSmall"
                                    @click="clearGroupFilters">
                            Clear Filter
                        </RockButton>
                    </template>
                    <div class="p-3 h-100 group-container">
                        <div v-if="areGroupsLoading" class="d-flex align-items-center justify-content-center">
                            <Loading :isLoading="areGroupsLoading" />
                        </div>
                        <div v-else-if="filteredAndSortedGroups.length === 0" class="h-100 d-flex align-items-center justify-content-center">
                            <div class="no-groups">
                                <i class="fa fa-group fa-2x"></i>
                                <p>No Groups</p>
                            </div>
                        </div>
                        <DestinationGroup v-for="(group, index) in filteredAndSortedGroups"
                                          v-else
                                          :key="index"
                                          :destinationGroup="group"
                                          :arePersonCardsExpanded="arePersonCardsExpanded"
                                          :isGroupExpanded="areGroupsExpanded"
                                          :groupTypeRoles="box.destinationGroupType?.roles ?? []"
                                          :dragTargetId="personDragSourceOptions.id"
                                          :groupMemberDragOptions="groupMemberDragSourceOptions"
                                          :getGroupRoleError="getGroupRoleError"
                                          :clearGroupRoleError="clearGroupRoleError"
                                          :currentSortOrder="currentSortOrder"
                                          :isGenderHighlighting="isGenderHighlighting"
                                          :isInstanceDisplayed="placementConfigurationSettings.showRegistrationInstanceName"
                                          :areSourceAttributesDisplayedOnDestinationGroupMembers="placementConfigurationSettings.areSourceAttributesDisplayedOnDestinationGroupMembers"
                                          :arePeopleLoading="arePeopleLoading"
                                          :placementMode="box.placementMode"
                                          @editGroup="editGroup"
                                          @detachGroup="detachPlacementGroup"
                                          @deleteGroup="deletePlacementGroup"
                                          @editGroupMember="editGroupMember"
                                          @removeGroupMember="removeGroupMember" />
                    </div>

                </Panel>
            </div>
        </div>

    </Panel>

    <PlacementConfigurationModal v-model="isPlacementConfigModalVisible"
                                 :placementConfigurationSettings="placementConfigurationSettings"
                                 :placementConfigurationSettingOptions="box.placementConfigurationSettingOptions ?? {}"
                                 :placementMode="box.placementMode"
                                 @save="savePlacementCofigSettings" />

    <AddGroupModal v-model="isAddGroupModalVisible"
                   ref="addGroupModalElement"
                   :groupAttributes="box.attributesForGroupAdd ?? {}"
                   :errorMessage="addGroupModalErrorText"
                   @save="addGroup"
                   @dismissMessage="addGroupModalErrorText = ''" />
</template>

<style scoped>
:deep(.panel-default) {
    height: 100%;
}

:deep(.panel-sub-header) {
    padding: 0;
    background-color: var(--color-interface-softer);
    min-height: unset;
}

:deep(.panel-default>.panel-heading) {
    background-color: var(--color-interface-softest);
    border-color: var(--color-interface-softer);
    color: #2d2e31;
}

/* Work-around to allow the height to descend (through the fullscreen div) all the way down to panel-body */
:deep(.helper-height > div:first-child) {
    height: 100%;
}

.slide-enter-active,
.slide-leave-active {
    transition: all 0.5s ease;
}

.slide-enter-from,
.slide-leave-to {
    max-height: 0;
    opacity: 0;
    overflow: hidden;
    padding: 0 1rem !important;
}

.slide-enter-to,
.slide-leave-from {
    max-height: var(--slide-height, 200px);
    opacity: 1;
    padding: 1rem !important;
}

.group-member-filter-toggle {
    cursor: pointer;
    user-select: none;
    color: var(--color-interface-medium);
}

.no-people-label {
    color: var(--color-interface-medium);
}

.gu-mirror.multi-drag-preview {
    border: 1px solid var(--color-primary) !important;
    background-color: var(--interface-softest);
    color: var(--color-primary) !important;
    border-radius: 4px;
    opacity: 0.7;
    transform: rotate(-15deg);
    display: flex;
    justify-content: center;
    align-items: center;
    /* box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15); */
    pointer-events: none;
    z-index: 2;
}

.gu-transit.multi-hover-preview {
    border: 1px solid var(--color-primary) !important;
    background-color: var(--interface-softest);
    /* padding: 10px; */
    color: var(--color-primary) !important;
    border-radius: 4px;
    opacity: 0.7;
    display: flex;
    justify-content: center;
    align-items: center;
    pointer-events: none;
    z-index: 2;
    min-height: 50px;
}

/* .multi-card-preview i {
    opacity: 1;
    color: var(--color-primary);
    font-size: 1.4rem;
    z-index: 3;
} */

.multi-card-preview i {
    font-size: 1.2rem;
}

.preview-stack-clone {
    border: 1px solid var(--color-primary) !important;
    position: absolute !important;
    top: -6px !important;
    left: -6px !important;
    z-index: 0 !important;
    opacity: 0.6 !important;
}

:deep(.panel-body) {
    padding: 0;
}

.people-to-place-panel-body {
    display: flex;
    flex-direction: column;
    align-items: center;
    height: 100%;
    /* background-color: rgba(245, 245, 245, 0.4); */
    background-color: var(--color-interface-softer);
}

.people-to-place-card-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.5rem;
    padding-top: 0.5rem;
    width: 100%;
    padding: 0.5rem;
    overflow: hidden;
    overflow-y: auto;
}

.group-container {
    background-color: var(--color-interface-softer);
    overflow: hidden;
    overflow-y: auto;
}

.source-person-label {
    background-color: var(--color-interface-soft);
    color: var(--color-interface-stronger);
    font-size: var(--font-size-small);
    font-weight: var(--font-weight-semibold);
}

.no-groups {
    display: flex;
    flex-direction: column;
    align-items: center;
    color: var(--color-interface-medium);
    font-size: var(--font-size-small);
    font-weight: var(--font-weight-semibold);
}

:deep(.highlight) {
    background-color: var(--color-interface-soft) !important;
}

:deep(.is-drag-over) {
    display: none;
}
</style>

<script setup lang="ts">
    import { useConfigurationValues, usePersonPreferences, useInvokeBlockAction } from "@Obsidian/Utility/block";
    import { GroupPlacementInitializationBox } from "@Obsidian/ViewModels/Blocks/Group/GroupPlacement/groupPlacementInitializationBox";
    import { PlacementConfigurationSettingsBag } from "@Obsidian/ViewModels/Blocks/Group/GroupPlacement/placementConfigurationSettingsBag";
    import { PlacementGroupBag } from "@Obsidian/ViewModels/Blocks/Group/GroupPlacement/placementGroupBag";
    import { PersonBag } from "@Obsidian/ViewModels/Blocks/Group/GroupPlacement/personBag";
    import { onMounted, ref, nextTick, computed, watch, onBeforeUnmount } from "vue";
    import { BtnType } from "@Obsidian/Enums/Controls/btnType";
    import { BtnSize } from "@Obsidian/Enums/Controls/btnSize";
    import { tooltip } from "@Obsidian/Utility/tooltip";
    import { PreferenceKey, SortTypes, NavigationUrlKey } from "./GroupPlacement/types.partial";
    import { DragSource as vDragSource, DragTarget as vDragTarget, IDragSourceOptions } from "@Obsidian/Directives/dragDrop";
    import Panel from "@Obsidian/Controls/panel.obs";
    import RockButton from "@Obsidian/Controls/rockButton.obs";
    import TextBox from "@Obsidian/Controls/textBox.obs";
    import CheckBox from "@Obsidian/Controls/checkBox.obs";
    import RockLabel from "@Obsidian/Controls/rockLabel.obs";
    import PersonCard from "./GroupPlacement/personCard.partial.obs";
    import DestinationGroup from "./GroupPlacement/destinationGroup.partial.obs";
    import PlacementConfigurationModal from "./GroupPlacement/placementConfigurationModal.partial.obs";
    import AddGroupModal from "./GroupPlacement/addGroupModal.partial.obs";
    import AttributeValuesContainer from "@Obsidian/Controls/attributeValuesContainer.obs";
    import { areEqual, newGuid, toGuidOrNull } from "@Obsidian/Utility/guid";
    import { toNumberOrNull } from "@Obsidian/Utility/numberUtils";
    import { GroupMemberBag } from "@Obsidian/ViewModels/Blocks/Group/GroupPlacement/groupMemberBag";
    import { RockDateTime } from "@Obsidian/Utility/rockDateTime";
    import { asBooleanOrNull } from "@Obsidian/Utility/booleanUtils";
    import { AddGroupBag } from "@Obsidian/ViewModels/Blocks/Group/GroupPlacement/addGroupBag";
    import { PlacementPeopleBag } from "@Obsidian/ViewModels/Blocks/Group/GroupPlacement/placementPeopleBag";
    import Loading from "@Obsidian/Controls/loading.obs";
    import { getFieldType } from "@Obsidian/Utility/fieldTypes";
    import { ComparisonType } from "@Obsidian/Enums/Reporting/comparisonType";
    import { ComparisonValue } from "@Obsidian/Types/Reporting/comparisonValue";
    import { PublicAttributeBag } from "@Obsidian/ViewModels/Utility/publicAttributeBag";
    import { isNullOrWhiteSpace } from "@Obsidian/Utility/stringUtils";
    import { DetachGroupBag } from "@Obsidian/ViewModels/Blocks/Group/GroupPlacement/detachGroupBag";
    import DropDownList from "@Obsidian/Controls/dropDownList.obs";
    import TransitionVerticalCollapse from "@Obsidian/Controls/transitionVerticalCollapse.obs";
    import HighlightLabel from "@Obsidian/Controls/highlightLabel.obs";
    import { AddGroupMembersBag } from "@Obsidian/ViewModels/Blocks/Group/GroupPlacement/addGroupMembersBag";
    import { AttributeFiltersBag } from "@Obsidian/ViewModels/Blocks/Group/GroupPlacement/attributeFiltersBag";
    import { ListItemBag } from "@Obsidian/ViewModels/Utility/listItemBag";
    import { PlacementMode } from "@Obsidian/Enums/Group/placementMode";
    import { Guid } from "@Obsidian/Types";
    import { getTopic, ITopic, ServerFunctions } from "@Obsidian/Utility/realTime";
    import { RealTimeConnectionKeysBag } from "@Obsidian/ViewModels/Blocks/Group/GroupPlacement/realTimeConnectionKeysBag";
    import { GroupMemberUpdatedMessageBag } from "@Obsidian/ViewModels/Group/GroupMember/groupMemberUpdatedMessageBag";
    import { RegistrationRegistrantUpdatedMessageBag } from "@Obsidian/ViewModels/Event/RegistrationEntry/registrationRegistrantUpdatedMessageBag";
    import { RegistrantBag } from "@Obsidian/ViewModels/Blocks/Group/GroupPlacement/registrantBag";

    type GroupPlacementTopic = ITopic<ServerFunctions<unknown>> & {
        groupGuids: Guid[],
        registrationInstanceGuid: Guid,
        registrationTemplateGuid: Guid,
    };

    /*
        TODO's
        1. In the special case where a user overrides the Registration Template Id from the Block Settings AND a the Registration Template Placement Id is not present.
            then we will display a dropdown on the top bar (similar to Sms Conversations selected system phone number). This dropdown will allow us to select different
            Registration Template Placements.
    */

    // #region Values
    const box = useConfigurationValues<GroupPlacementInitializationBox>();
    const invokeBlockAction = useInvokeBlockAction();
    const preferences = usePersonPreferences().blockPreferences;

    const realTimetopic = ref<GroupPlacementTopic | null>();

    const arePersonCardsExpanded = ref(false);
    const areAllPeopleSelected = ref(false);
    const selectionInfoElement = ref<HTMLElement | undefined>();
    const isPlacementConfigModalVisible = ref(false);
    const isAddGroupModalVisible = ref(false);
    // const placementGroups = ref<PlacementGroupBag[]>(box.placementGroups ?? []);
    // const peopleToPlace = ref<PersonBag[]>(box.peopleToPlace ?? []);
    const placementGroups = ref<PlacementGroupBag[]>([]);
    const peopleToPlace = ref<PersonBag[]>([]);

    const areGroupsLoading = ref<boolean>(true);
    const arePeopleLoading = ref<boolean>(true);

    const selectedPersonIdKeys = ref<Set<string>>(new Set());

    const sourceAttributesForFilter = ref<Record<string, PublicAttributeBag>>({});
    const sourceAttributeValuesForFilter = ref(preferences.getValue(getPersonAttributeFilterKey()) ? JSON.parse(preferences.getValue(getPersonAttributeFilterKey())) : {});
    const registrantFeeItemsForFilter = ref<ListItemBag[]>([]);
    const pendingRegistrantFeeItemValuesForFilter = ref(preferences.getValue(getRegistrantFeeItemValuesFilterKey()) ? JSON.parse(preferences.getValue(getRegistrantFeeItemValuesFilterKey())) : {});
    const registrantFeeItemValuesForFilter = ref(preferences.getValue(getRegistrantFeeItemValuesFilterKey()) ? JSON.parse(preferences.getValue(getRegistrantFeeItemValuesFilterKey())) : {});

    const destinationGroupAttributesForFilter = ref<Record<string, PublicAttributeBag>>({});
    const destinationAttributeValuesForFilter = ref(preferences.getValue(getGroupAttributeFilterKey()) ? JSON.parse(preferences.getValue(getGroupAttributeFilterKey())) : {});
    const destinationGroupMemberAttributesForFilter = ref<Record<string, PublicAttributeBag>>({});
    const destinationMemberAttributeValuesForFilter = ref(preferences.getValue(getGroupMemberAttributeFilterKey()) ? JSON.parse(preferences.getValue(getGroupMemberAttributeFilterKey())) : {});

    const isGroupMemberFilterDisplayed = ref<boolean>(false);

    const pendingSourceAttributeValuesForFilter = ref(preferences.getValue(getPersonAttributeFilterKey()) ? JSON.parse(preferences.getValue(getPersonAttributeFilterKey())) : {});
    const pendingDestinationGroupAttributeValuesForFilter = ref(preferences.getValue(getGroupAttributeFilterKey()) ? JSON.parse(preferences.getValue(getGroupAttributeFilterKey())) : {});
    const pendingDestinationGroupMemberAttributeValuesForFilter = ref(preferences.getValue(getGroupMemberAttributeFilterKey()) ? JSON.parse(preferences.getValue(getGroupMemberAttributeFilterKey())) : {});

    const isPersonSearchVisible = ref<boolean>(false);
    const personSearchText = ref<string>("");
    const personSearchContainerElement = ref<HTMLElement>();

    const areGroupsExpanded = ref(false);
    const isNoPeopleLabelHidden = ref(false);

    const groupRoleErrors = ref<Record<number, Record<number, string>>>({});

    const sourcePerson = ref<PersonBag | null | undefined>(box.sourcePerson);

    const currentSortOrder = ref<SortTypes>(toNumberOrNull(preferences.getValue(getSortOrderKey())) as SortTypes ?? SortTypes.SortByLastName);
    const sortOptions: Array<[SortTypes, string]> = [
        [SortTypes.SortByLastName, "Last Name, First Name (Default)"],
        [SortTypes.SortByFirstName, "First Name Last Name"],
        [SortTypes.SortByDateAddedAsc, "Date Added (Oldest First)"],
        [SortTypes.SortByDateAddedDesc, "Date Added (Newest First)"]
    ];

    const addGroupModalElement = ref<InstanceType<typeof AddGroupModal>>();
    const addGroupModalErrorText = ref<string>();

    const isGenderHighlighting = ref<boolean>(asBooleanOrNull(preferences.getValue(getIsGenderHighlightingKey())) ?? false);

    const personDragSourceOptions = getPersonDragSourceOptions();
    const groupMemberDragSourceOptions = getGroupMemberDragSourceOptions();

    const placementConfigurationSettings = ref<PlacementConfigurationSettingsBag>(preferences.getValue(getPlacementConfigurationSettingsKey()) ? JSON.parse(preferences.getValue(getPlacementConfigurationSettingsKey())) : {} as PlacementConfigurationSettingsBag);

    console.log("GroupPlacementInitializationBox", box);
    console.log("placement config settings: ", placementConfigurationSettings.value);

    // #endregion

    // #region Computed Values

    const selectedPeopleCount = computed(() => selectedPersonIdKeys.value.size);

    const groupMemberFilterIcon = computed((): string => {
        return isGroupMemberFilterDisplayed.value ? "fa fa-chevron-up" : "fa fa-chevron-down";
    });

    const filteredAndSortedPeopleToPlace = computed(() => {
        const filteredPeople = peopleToPlace.value.filter(p => {
            if (sourcePerson.value && p.personIdKey !== sourcePerson.value.personIdKey) {
                return false;
            }

            const matchesSearchText = personSearchText.value
                ? p.nickname?.toLowerCase().includes(personSearchText.value.toLowerCase()) ||
                p.lastName?.toLowerCase().includes(personSearchText.value.toLowerCase())
                : true;

            if (box.placementMode === PlacementMode.TemplateMode || box.placementMode === PlacementMode.InstanceMode) {
                const matchesAttributeAndFeeFilters = p.registrants?.some(r => {
                    const hasMatchingAttributes = !sourceAttributesForFilter.value || !r.attributeValues
                        || areAttributeFiltersMet(sourceAttributesForFilter.value, sourceAttributeValuesForFilter.value, r.attributeValues);

                    const hasMatchingFees = !registrantFeeItemValuesForFilter.value.length
                        || Object.keys(r.fees || {}).some(feeItemId =>
                            registrantFeeItemValuesForFilter.value.includes(feeItemId)
                        );

                    return hasMatchingAttributes && hasMatchingFees;
                });
                return matchesSearchText && matchesAttributeAndFeeFilters;
            }
            else {  // TODO - Determine if we need else if here (Depends on EntitySetMode)
                return !p.sourceGroupMember?.attributeValues
                    || areAttributeFiltersMet(sourceAttributesForFilter.value, sourceAttributeValuesForFilter.value, p.sourceGroupMember.attributeValues);
            }
        });

        return getSortedPeople(filteredPeople);
    });

    const filteredAndSortedGroups = computed(() => {
        // TODO - Phone Number Filter seems to be broken
        const filteredPlacementGroups = placementGroups.value.filter(g => {
            if (placementConfigurationSettings.value.areFullGroupsHidden && g.groupCapacity && g.groupMembers && g.groupMembers.length >= g.groupCapacity) {
                return false;
            }

            if (!destinationGroupAttributesForFilter.value || !g.attributeValues) {
                return true;
            }
            return areAttributeFiltersMet(destinationGroupAttributesForFilter.value, destinationAttributeValuesForFilter.value, g.attributeValues);
        });

        return filteredPlacementGroups.map(group => {
            // const validGroupMembers = (group.groupMembers ?? []).filter(m => m?.person);
            if (!group.groupMembers) {
                group.groupMembers = [];
            }

            const validGroupMembers = group.groupMembers.filter(m => {
                if (!m.person) {
                    return false;
                }
                if (!destinationGroupMemberAttributesForFilter.value || !m.attributeValues) {
                    return true;
                }
                return areAttributeFiltersMet(destinationGroupMemberAttributesForFilter.value, destinationMemberAttributeValuesForFilter.value, m.attributeValues);
            });

            const sortedPeople = getSortedPeople(validGroupMembers.map(m => m.person!));

            const memberMap = new Map<string, GroupMemberBag[]>();

            for (const m of validGroupMembers) {
                const key = m.person?.personIdKey;
                if (!key || !m.groupMemberIdKey) continue;

                if (!memberMap.has(key)) {
                    memberMap.set(key, []);
                }

                memberMap.get(key)!.push(m);
            }

            const seenGroupMemberIds = new Set<string>();

            const sortedGroupMembers = sortedPeople.flatMap(p => {
                const members = memberMap.get(p.personIdKey ?? "") ?? [];
                return members.filter(m => {
                    if (!m.groupMemberIdKey) return false;
                    if (seenGroupMemberIds.has(m.groupMemberIdKey)) return false;
                    seenGroupMemberIds.add(m.groupMemberIdKey);
                    return true;
                });
            });

            return {
                ...group,
                groupMembers: sortedGroupMembers
            };
        });
    });

    const placementGroupGuids = computed(() => placementGroups.value.map(g => g.groupGuid));


    // #endregion

    // #region Functions

    function areAttributeFiltersMet(attributes: Record<string, PublicAttributeBag>, attributeValuesFromFilter: Record<string, string>, attributeValuesFromEntity: Record<string, string>): boolean {
        return Object.keys(attributeValuesFromFilter).every(attributeKey => {
            console.log("Here: ", attributes[attributeKey]);
            // If we can't find the key in attributes, then it is not being displayed and the filter should not be triggered.
            if (!attributes[attributeKey]) {
                return true;
            }

            const fieldType = getFieldType(attributes[attributeKey].fieldTypeGuid);

            if (!fieldType) {
                return false;
            }

            if (!attributeValuesFromFilter[attributeKey]) {
                return true;
            }

            const comparisonValue: ComparisonValue = {
                value: attributeValuesFromFilter[attributeKey],
                comparisonType: ComparisonType.EqualTo
            };

            var result = fieldType.doesValueMatchFilter(attributeValuesFromEntity[attributeKey], comparisonValue, attributes[attributeKey].configurationValues ?? {});

            console.log("value: ", attributeValuesFromEntity[attributeKey], " filterValue: ", comparisonValue.value, " Attribute Key: ", attributeKey, " RESULT: ", result);
            return result;
        });
    }

    function getSortedPeople(people: PersonBag[]): PersonBag[] {
        return [...people].sort((a, b) => {
            switch (currentSortOrder.value) {
                case SortTypes.SortByFirstName: {
                    const firstNameComparison = (a.firstName ?? "").localeCompare(b.firstName ?? "");
                    if (firstNameComparison !== 0) {
                        return firstNameComparison;
                    }
                    return (a.lastName ?? "").localeCompare(b.lastName ?? "");
                }

                case SortTypes.SortByLastName: {
                    const lastNameComparison = (a.lastName ?? "").localeCompare(b.lastName ?? "");
                    if (lastNameComparison !== 0) {
                        return lastNameComparison;
                    }
                    return (a.firstName ?? "").localeCompare(b.firstName ?? "");
                }

                // TODO - Figure out how to sort by date when not in registration mode.
                case SortTypes.SortByDateAddedAsc: {
                    // We'll just grab the first registrant on each person.
                    const dateA = RockDateTime.parseISO(a.registrants?.[0]?.createdDateTime ?? "");
                    const dateB = RockDateTime.parseISO(b.registrants?.[0]?.createdDateTime ?? "");

                    if (dateA && dateB) {
                        return dateA.toMilliseconds() - dateB.toMilliseconds();
                    }
                    else if (dateA && !dateB) {
                        return -1;
                    }
                    else if (!dateA && dateB) {
                        return 1;
                    }

                    return 0;
                }

                case SortTypes.SortByDateAddedDesc: {
                    // We'll just grab the first registrant on each person.
                    const dateA = RockDateTime.parseISO(a.registrants?.[0]?.createdDateTime ?? "");
                    const dateB = RockDateTime.parseISO(b.registrants?.[0]?.createdDateTime ?? "");

                    if (dateA && dateB) {
                        return dateB.toMilliseconds() - dateA.toMilliseconds();
                    }
                    else if (dateA && !dateB) {
                        return -1;
                    }
                    else if (!dateA && dateB) {
                        return 1;
                    }

                    return 0;
                }

                default:
                    return 0;
            }
        });
    }

    function setGroupRoleError(groupIdKey: string, roleIdKey: string, message: string): void {
        if (!groupRoleErrors.value[groupIdKey]) {
            groupRoleErrors.value[groupIdKey] = {};
        }

        groupRoleErrors.value[groupIdKey][roleIdKey] = message;
    }

    function clearGroupRoleError(groupIdKey: string, roleIdKey: string): void {
        const roleMap = groupRoleErrors.value[groupIdKey];

        if (roleMap) {
            delete roleMap[roleIdKey];

            // Clean up empty role maps
            if (Object.keys(roleMap).length === 0) {
                delete groupRoleErrors.value[groupIdKey];
            }
        }
    }

    function getGroupRoleError(groupIdKey: string, roleIdKey: string): string | null {
        return groupRoleErrors.value[groupIdKey]?.[roleIdKey] ?? null;
    }

    function getPersonDragSourceOptions(): IDragSourceOptions {
        return {
            id: newGuid(),
            copyElement: true,
            dragBegin(operation) {
                if (selectedPersonIdKeys.value.size > 1) {
                    nextTick(() => {
                        const mirror = document.querySelector(".gu-mirror") as HTMLElement;
                        if (!mirror) return;

                        mirror.innerHTML = "";
                        // Clone the current content before we touch it
                        const clone = mirror.cloneNode(true) as HTMLElement;

                        // Clean the original mirror and restyle it
                        mirror.classList.add("multi-drag-preview");
                        mirror.style.position = "relative";

                        mirror.innerHTML = `
                            <div class="multi-card-preview">
                            <i class="fa fa-user-friends"></i>
                            </div>
                        `;

                        clone.classList.add("preview-stack-clone");

                        const inner = document.createElement("div");
                        inner.style.position = "relative";
                        inner.style.zIndex = "1";

                        while (mirror.firstChild) {
                            inner.appendChild(mirror.firstChild);
                        }

                        mirror.appendChild(clone);
                        mirror.appendChild(inner);
                    });
                }
            },
            dragOver(operation) {
                if (isGenderHighlighting.value) {
                    nextTick(() => {
                        const transit = document.querySelector(".gu-transit") as HTMLElement;
                        if (!transit) return;

                        transit.style.display = "none";
                        // transit.style = "display: none";
                    });
                }
                else if (selectedPersonIdKeys.value.size > 1) {
                    nextTick(() => {
                        const transit = document.querySelector(".gu-transit") as HTMLElement;
                        if (!transit) return;

                        transit.innerHTML = "";

                        transit.classList.add("multi-hover-preview");

                        transit.innerHTML = `
                            <div class="multi-card-preview">
                            <i class="fa fa-user-friends"></i>
                            </div>
                        `;
                    });
                }
                if (operation.targetContainer && operation.targetContainer instanceof HTMLElement) {
                    operation.targetContainer.closest(".group-role-wrapper")?.classList.add("highlight");

                    const emptyDropZone = operation.targetContainer.querySelector(".empty-drop-zone");

                    if (emptyDropZone) {
                        emptyDropZone.classList.add("is-drag-over");
                    }
                }

            },
            dragOut(operation) {
                if (operation.targetContainer && operation.targetContainer instanceof HTMLElement) {
                    operation.targetContainer.closest(".group-role-wrapper")?.classList.remove("highlight");

                    const emptyDropZone = operation.targetContainer.querySelector(".empty-drop-zone");

                    if (emptyDropZone) {
                        emptyDropZone.classList.remove("is-drag-over");
                    }
                }

            },
            async dragDrop(operation) {
                operation.element.remove();

                var rawGroupSectionId = (operation.targetContainer as HTMLElement)?.dataset.groupSectionId;
                const [groupIdKey, groupRoleIdKey] = (rawGroupSectionId ?? "").split("|");
                if (!groupIdKey) {
                    return;
                }
                const placementGroup = placementGroups.value.find(g => g.groupIdKey === groupIdKey);
                if (!placementGroup) {
                    return;
                }
                var pendingGroupMembers: GroupMemberBag[] = [];

                if (selectedPersonIdKeys.value.size > 1) {
                    const selectedPeopleToPlace = peopleToPlace.value.filter(p => p.personIdKey && selectedPersonIdKeys.value.has(p.personIdKey));

                    if (selectedPeopleToPlace && groupRoleIdKey && operation.targetIndex !== undefined) {
                        selectedPeopleToPlace.forEach((person) => {
                            pendingGroupMembers.push({
                                groupMemberId: 0,
                                groupRoleIdKey: groupRoleIdKey,
                                person: person,
                                groupMemberIdKey: null
                            });
                        });
                    }
                }
                else {
                    const personIdKey = (operation.element as HTMLElement).dataset.personIdKey;
                    const person = peopleToPlace.value.find(p => p.personIdKey === personIdKey);

                    if (person && groupRoleIdKey && operation.targetIndex !== undefined) {
                        pendingGroupMembers.push({
                            groupMemberId: 0,
                            groupRoleIdKey: groupRoleIdKey,
                            person: person,
                            groupMemberIdKey: null
                        });

                        //TODO - the current display of group members results in incosistency with there array index
                    }
                }

                if (!placementGroup.groupMembers) {
                    placementGroup.groupMembers = [];
                }

                // TODO - what happens on error?
                var newGroupMembers = await addGroupMembersToGroup(pendingGroupMembers, placementGroup);
                console.log("New group members: ", newGroupMembers);
                // Handled by realtime now.
                // newGroupMembers.forEach((groupMember, i) => {
                //     // placementGroup.groupMembers!.splice(operation.targetIndex! + i, 0, {
                //     //     groupRoleIdKey: groupMember.groupRoleIdKey,
                //     //     person: groupMember.person,
                //     //     groupMemberIdKey: groupMember.groupMemberIdKey
                //     // });
                //     // No need to splice because we are always sorting.
                //     placementGroup.groupMembers!.push({
                //         groupMemberId: groupMember.groupMemberId,
                //         groupRoleIdKey: groupMember.groupRoleIdKey,
                //         person: groupMember.person,
                //         groupMemberIdKey: groupMember.groupMemberIdKey
                //     });

                //     if (!box.isPlacementAllowingMultiple) {
                //         peopleToPlace.value = peopleToPlace.value.filter(
                //             p => groupMember.person?.personIdKey !== p.personIdKey
                //         );
                //     }
                // });

                selectedPersonIdKeys.value.clear();
            }
        };
    }

    function getGroupMemberDragSourceOptions(): IDragSourceOptions {
        return {
            id: newGuid(),
            copyElement: true,
            dragOver(operation) {
                if (peopleToPlace.value.length === 0) {
                    isNoPeopleLabelHidden.value = true;
                }
                if (operation.targetContainer && operation.targetContainer instanceof HTMLElement) {
                    // TODO - ask UI team if they want this.
                    operation.targetContainer.closest(".people-to-place-card-container")?.classList.add("highlight");
                }
            },
            dragOut(operation) {
                if (operation.targetContainer && operation.targetContainer instanceof HTMLElement) {
                    operation.targetContainer.closest(".people-to-place-card-container")?.classList.remove("highlight");
                }
            },
            dragCancel(operation) {
                isNoPeopleLabelHidden.value = false;
            },
            async dragDrop(operation) {
                operation.element.remove();
                isNoPeopleLabelHidden.value = false;

                const groupIdKey = (operation.element as HTMLElement).dataset.groupIdKey;
                const groupMemberIdKey = (operation.element as HTMLElement).dataset.groupMemberIdKey;

                removeGroupMember(groupIdKey, groupMemberIdKey);
            }
        };
    }

    async function removeGroupMember(groupIdKey: string | undefined, groupMemberIdKey: string | undefined): Promise<void> {
        const placementGroup = placementGroups.value.find(g => g.groupIdKey === groupIdKey);
        if (!placementGroup?.groupMembers || !groupMemberIdKey || !placementGroup.groupIdKey) {
            return;
        }

        const groupMember = placementGroup.groupMembers?.find(gm => gm.groupMemberIdKey === groupMemberIdKey);

        if (groupMember && groupMember.person) {
            if (!peopleToPlace.value) {
                peopleToPlace.value = [];
            }

            var isRemoveSuccess = await removeGroupMemberFromGroup(groupMemberIdKey, placementGroup.groupIdKey);

            if (isRemoveSuccess) {
                // // If the person does not have a Registrant in any of the included Registration Instances, then they should not be shown in the People To Place Panel.
                // // This matches with functionality from the old Webforms Block.
                // // TODO - maybe move this to filter computed?
                // var isPersonBeDisplayed = shouldPersonBeDisplayed(groupMember);

                // if (isPersonBeDisplayed) {
                //     // peopleToPlace.value.splice(operation.targetIndex, 0, {
                //     //     ...groupMember.person,
                //     // });
                //     // No need to splice because we are always sorting.
                //     peopleToPlace.value.push({ ...groupMember.person });
                // }

                // placementGroup.groupMembers = placementGroup.groupMembers?.filter(gm => gm.groupMemberIdKey !== groupMemberIdKey);
            }
        }
    }

    function editGroup(key: string): void {
        if (box.navigationUrls?.[NavigationUrlKey.GroupDetailPage]) {
            window.location.href = box.navigationUrls[NavigationUrlKey.GroupDetailPage].replace("((Key))", key.toString());
        }
    }

    function editGroupMember(key: string): void {
        if (box.navigationUrls?.[NavigationUrlKey.GroupMemberDetailPage]) {
            window.location.href = box.navigationUrls[NavigationUrlKey.GroupMemberDetailPage].replace("((Key))", key.toString());
        }
    }

    const shouldPersonBeDisplayed = (groupMember: GroupMemberBag): boolean => {
        let shouldBeDisplayed: boolean = true;

        if (box.placementMode === PlacementMode.TemplateMode) {
            // Default to true if person or registrants were not found for some reason.
            shouldBeDisplayed = groupMember!.person?.registrants?.some(r => {
                if (placementConfigurationSettings.value.includedRegistrationInstanceIds?.length === 0) {
                    return true;
                }

                return placementConfigurationSettings.value.includedRegistrationInstanceIds!.includes(r.registrationInstanceIdKey ?? "");
            }) ?? true;
        }

        if (!box.isPlacementAllowingMultiple) {
            // If there is another group member present with the same person idkey then the person should not be displayed in people to place.
            shouldBeDisplayed = !placementGroups.value.some(group =>
                group.groupMembers?.some(gm =>
                    gm.groupMemberIdKey !== groupMember.groupMemberIdKey &&
                    gm.person?.personIdKey === groupMember.person?.personIdKey
                )
            );
        }
        else {
            // If the group placement is allowing multiple then all people are already displayed.
            // So there is no need to display the newly removed group member.
            shouldBeDisplayed = false;
        }

        if (box.placementMode === PlacementMode.TemplateMode || box.placementMode === PlacementMode.InstanceMode) {
            // If the group member being removed is not a registrant than they should not be displayed.
            if (groupMember.person?.registrants?.length === 0) {
                shouldBeDisplayed = false;
            }
        }
        else if (box.placementMode === PlacementMode.GroupMode) {
            // If the group member being removed is not part of the source group than they should not be displayed.
            if (!groupMember.person?.sourceGroupMember?.groupMemberIdKey) {
                shouldBeDisplayed = false;
            }
        }

        return shouldBeDisplayed;
    };

    function handleOutsideClick(event: MouseEvent) {
        const clickedEl = event.target as HTMLElement;

        // Only clear if clicked outside a .person-card
        if (!clickedEl.closest(".person-card") && !clickedEl.closest(".prevent-clear")) {
            selectedPersonIdKeys.value.clear();
        }
    }

    function toggleSelection(personIdKey: string) {
        if (selectedPersonIdKeys.value.has(personIdKey)) {
            selectedPersonIdKeys.value.delete(personIdKey);
        }
        else {
            selectedPersonIdKeys.value.add(personIdKey);
        }
    }

    function isSelected(personIdKey: string): boolean {
        return selectedPersonIdKeys.value.has(personIdKey);
    }

    function toggleSelectAllCheckbox() {
        if (areAllPeopleSelected.value) {
            selectedPersonIdKeys.value.clear();
        }
        else {
            for (const person of filteredAndSortedPeopleToPlace.value) {
                if (person.personIdKey) {
                    selectedPersonIdKeys.value.add(person.personIdKey);
                }
            }
        }
    }

    function onBack(): void {
        if (box.backPageUrl) {
            window.location.href = box.backPageUrl;
        }
        // window.history.back();
    }

    function changeSort(sortType: SortTypes): void {
        currentSortOrder.value = sortType;
        // Add logic here to apply the sort
        console.log("Sort changed to:", sortType);
    }

    function toggleHighlightGender(): void {
        isGenderHighlighting.value = !isGenderHighlighting.value;
    }

    function openPlacementConfigSettings(): void {
        console.log("Open placement config settings");
        isPlacementConfigModalVisible.value = true;
    }

    function toggleIsPersonSearchVisible(): void {
        isPersonSearchVisible.value = !isPersonSearchVisible.value;
        if (isPersonSearchVisible.value) {
            nextTick(() => {
                const searchInput = personSearchContainerElement.value?.querySelector("input") as HTMLInputElement | null;
                searchInput?.focus();
            });
        }
        else {
            personSearchText.value = "";
        }
    }

    function openAddGroupModal(): void {
        isAddGroupModalVisible.value = true;
    }

    function toggleCardExpansion(): void {
        arePersonCardsExpanded.value = !arePersonCardsExpanded.value;
        console.log("Card expansion toggled");
    }

    function toggleGroupExpansion(): void {
        areGroupsExpanded.value = !areGroupsExpanded.value;
    }

    function applyPeopleFilter(): void {
        sourceAttributeValuesForFilter.value = pendingSourceAttributeValuesForFilter.value;
        registrantFeeItemValuesForFilter.value = pendingRegistrantFeeItemValuesForFilter.value;
    }

    function clearPeopleFilters(): void {
        pendingSourceAttributeValuesForFilter.value = {};
        sourceAttributeValuesForFilter.value = {};
        pendingRegistrantFeeItemValuesForFilter.value = [];
        registrantFeeItemValuesForFilter.value = [];
    }

    function applyGroupFilter(): void {
        destinationAttributeValuesForFilter.value = pendingDestinationGroupAttributeValuesForFilter.value;
        destinationMemberAttributeValuesForFilter.value = pendingDestinationGroupMemberAttributeValuesForFilter.value;
    }

    function clearGroupFilters(): void {
        pendingDestinationGroupAttributeValuesForFilter.value = {};
        pendingDestinationGroupMemberAttributeValuesForFilter.value = {};
        destinationAttributeValuesForFilter.value = {};
        destinationMemberAttributeValuesForFilter.value = {};
    }

    function toggleIsGroupMemberFilterDisplayed(): void {
        isGroupMemberFilterDisplayed.value = !isGroupMemberFilterDisplayed.value;
    }

    function removeSourcePerson(): void {
        sourcePerson.value = null;
    }

    function getSortOrderKey(): string {
        if (box.placementMode === PlacementMode.InstanceMode && box.groupPlacementKeys?.registrationInstanceIdKey) {
            return PreferenceKey.SortOrderRegistrationInstanceId.replace("{0}", box.groupPlacementKeys.registrationInstanceIdKey.toString());
        }
        else if (box.placementMode === PlacementMode.TemplateMode && box.groupPlacementKeys?.registrationTemplateIdKey) {
            return PreferenceKey.SortOrderRegistrationTemplateId.replace("{0}", box.groupPlacementKeys.registrationTemplateIdKey.toString());
        }
        else if (box.placementMode === PlacementMode.GroupMode && box.groupPlacementKeys?.sourceGroupIdKey) {
            return PreferenceKey.SortOrderSourceGroupId.replace("{0}", box.groupPlacementKeys.sourceGroupIdKey.toString());
        }
        return "";
    }

    function getIsGenderHighlightingKey(): string {
        if (box.placementMode === PlacementMode.InstanceMode && box.groupPlacementKeys?.registrationInstanceIdKey) {
            return PreferenceKey.IsGenderHighlightingRegistrationInstanceId.replace("{0}", box.groupPlacementKeys.registrationInstanceIdKey.toString());
        }
        else if (box.placementMode === PlacementMode.TemplateMode && box.groupPlacementKeys?.registrationTemplateIdKey) {
            return PreferenceKey.IsGenderHighlightingRegistrationTemplateId.replace("{0}", box.groupPlacementKeys.registrationTemplateIdKey.toString());
        }
        else if (box.placementMode === PlacementMode.GroupMode && box.groupPlacementKeys?.sourceGroupIdKey) {
            return PreferenceKey.IsGenderHighlightingSourceGroupId.replace("{0}", box.groupPlacementKeys.sourceGroupIdKey.toString());
        }
        return "";
    }

    function getPersonAttributeFilterKey(): string {
        if (box.placementMode === PlacementMode.InstanceMode && box.groupPlacementKeys?.registrationInstanceIdKey) {
            return PreferenceKey.PersonAttributeFilterRegistrationInstanceId.replace("{0}", box.groupPlacementKeys.registrationInstanceIdKey.toString());
        }
        else if (box.placementMode === PlacementMode.TemplateMode && box.groupPlacementKeys?.registrationTemplateIdKey) {
            return PreferenceKey.PersonAttributeFilterRegistrationTemplateId.replace("{0}", box.groupPlacementKeys.registrationTemplateIdKey.toString());
        }
        else if (box.placementMode === PlacementMode.GroupMode && box.groupPlacementKeys?.sourceGroupIdKey) {
            return PreferenceKey.PersonAttributeFilterSourceGroupId.replace("{0}", box.groupPlacementKeys.sourceGroupIdKey.toString());
        }
        return "";
    }

    function getPlacementConfigurationSettingsKey(): string {
        if (box.groupPlacementKeys?.registrationInstanceIdKey) {
            return PreferenceKey.PlacementConfigurationJSONRegistrationInstanceId.replace("{0}", box.groupPlacementKeys.registrationInstanceIdKey.toString());
        }
        else if (box.groupPlacementKeys?.registrationTemplateIdKey) {
            return PreferenceKey.PlacementConfigurationJSONRegistrationTemplateId.replace("{0}", box.groupPlacementKeys.registrationTemplateIdKey.toString());
        }
        else if (box.placementMode === PlacementMode.GroupMode && box.groupPlacementKeys?.sourceGroupIdKey) {
            return PreferenceKey.PlacementConfigurationJSONSourceGroupId.replace("{0}", box.groupPlacementKeys.sourceGroupIdKey.toString());
        }
        return "";
    }

    function getRegistrantFeeItemValuesFilterKey(): string {
        if (box.placementMode === PlacementMode.InstanceMode && box.groupPlacementKeys?.registrationInstanceIdKey) {
            return PreferenceKey.RegistrantFeeItemValuesForFiltersJSONRegistrationInstanceId.replace("{0}", box.groupPlacementKeys.registrationInstanceIdKey.toString());
        }
        else if (box.placementMode === PlacementMode.TemplateMode && box.groupPlacementKeys?.registrationTemplateIdKey) {
            return PreferenceKey.RegistrantFeeItemValuesForFiltersJSONRegistrationTemplateId.replace("{0}", box.groupPlacementKeys.registrationTemplateIdKey.toString());
        }
        return "";
    }

    function getGroupAttributeFilterKey(): string {
        if (box.destinationGroupType?.idKey) {
            return PreferenceKey.GroupAttributeFilterGroupTypeId.replace("{0}", box.destinationGroupType.idKey.toString());
        }
        return "";
    }

    function getGroupMemberAttributeFilterKey(): string {
        if (box.destinationGroupType?.idKey) {
            return PreferenceKey.GroupMemberAttributeFilterGroupTypeId.replace("{0}", box.destinationGroupType.idKey.toString());
        }
        return "";
    }

    function getPlacementContext(groupMember: GroupMemberUpdatedMessageBag): {
        placementGroup: PlacementGroupBag | undefined;
        existingPerson: PersonBag | undefined;
    } {
        const placementGroup = placementGroups.value.find(
            g => g.groupIdKey === groupMember.groupIdKey
        );

        if (!placementGroup) {
            return { placementGroup: undefined, existingPerson: undefined };
        }

        if (!placementGroup.groupMembers) {
            placementGroup.groupMembers = [];
        }

        let existingPerson: PersonBag | undefined;
        const personIdKey = groupMember?.person?.personIdKey;

        if (!isNullOrWhiteSpace(personIdKey)) {
            existingPerson = getExistingPerson(personIdKey!);
        }

        return { placementGroup, existingPerson };
    }


    function getExistingPerson(personIdKey: string): PersonBag | undefined {
        // Try to find the person from peopleToPlace
        let existingPerson = peopleToPlace.value.find(
            p => p.personIdKey === personIdKey
        );

        // If not found, try to find the person from other placement groups
        if (!existingPerson) {
            for (const pg of placementGroups.value) {
                const groupMemberWithMatchingPerson = pg.groupMembers?.find(
                    gm => gm.person?.personIdKey === personIdKey
                );

                if (groupMemberWithMatchingPerson?.person) {
                    existingPerson = groupMemberWithMatchingPerson.person;
                    break;
                }
            }
        }

        return existingPerson;
    }

    async function processDestinationGroups(groupsPromise: Promise<PlacementGroupBag[]>): Promise<void> {
        var groups = await groupsPromise;

        return new Promise((resolve, reject) => {
            try {
                // setTimeout(() => {
                placementGroups.value = groups.map(g => ({
                    ...g,
                    groupMembers: [] // Ensure groupMembers is initialized
                }));
                areGroupsLoading.value = false;
                areGroupsExpanded.value = groups.length > 3 ? false : true;
                console.log("placementGroups: ", placementGroups.value);
                resolve();
                // }, 3000);
            }
            catch (error) {
                reject(error);
            }
        });
    }

    async function loadPlacementData() {
        // Start API calls immediately
        const attributeFiltersPromise = populateAttributeFilters();
        const groupsPromise = getDestinationGroups();
        const placementPeoplePromise = getPlacementPeople();

        attributeFiltersPromise.then(attributeFilters => {
            // TODO - Probably can remove the population of attribute values from the server. We only care about attributes. Values are handled by preferences.
            sourceAttributesForFilter.value = attributeFilters.sourceAttributesForFilter ?? {};
            registrantFeeItemsForFilter.value = attributeFilters.registrantFeeItemsForFilter ?? [];
            destinationGroupAttributesForFilter.value = attributeFilters.destinationGroupAttributesForFilter ?? {};
            destinationGroupMemberAttributesForFilter.value = attributeFilters.destinationGroupMemberAttributesForFilter ?? {};
            console.log("Attribute Filters: ", attributeFilters);
        });

        // TODO - Come back to cleanup promise logic
        const processGroupsPromise = processDestinationGroups(groupsPromise);


        placementPeoplePromise.then(async placementPeople => {
            // Wait here until groups and attribute filters are loaded
            // await attributeFiltersPromise;
            await processGroupsPromise;
            console.log("placementpeople: ", placementPeople);

            if (placementPeople.peopleToPlace) {
                peopleToPlace.value = placementPeople.peopleToPlace;
            }
            if (placementPeople.tempGroups) {
                placementPeople.tempGroups.forEach(g => {
                    const placementGroup = placementGroups.value.find(pg => pg.groupIdKey === g.groupIdKey);
                    if (placementGroup?.groupMembers && g.groupMembers?.length) {
                        placementGroup.groupMembers.push(...g.groupMembers);
                    }
                });
            }

            arePeopleLoading.value = false;
        });
    }

    async function savePlacementCofigSettings(bag: PlacementConfigurationSettingsBag): Promise<void> {
        console.log("Here is my saved bag: ", bag);
        preferences.setValue(getPlacementConfigurationSettingsKey(), JSON.stringify(bag));

        console.log("Saving preferences: ", preferences);
        isPlacementConfigModalVisible.value = false;

        await preferences.save();
        placementConfigurationSettings.value = bag;

        loadPlacementData();
    }

    /**
     * Subscribes to the real-time GroupPlacementTopic and returns it.
     */
    async function getGroupPlacementTopic(groupGuids: Guid[], registrationInstanceGuid: Guid | null | undefined, registrationTemplateGuid: Guid | null | undefined): Promise<GroupPlacementTopic> {
        const topic = await getTopic("Rock.RealTime.Topics.GroupPlacementTopic");

        // Add Source Group Guid here...
        const request: RealTimeConnectionKeysBag = {
            connectionId: topic.connectionId,
            groupGuids: groupGuids,
            registrationInstanceGuid: registrationInstanceGuid,
            registrationTemplateGuid: registrationTemplateGuid
        };

        console.log("request: ", request);

        await invokeBlockAction("SubscribeToRealTime", {
            realTimeConnectionKeysBag: request
        });

        Object.defineProperty(topic, "registrationInstanceGuid", {
            value: registrationInstanceGuid,
            writable: false
        });

        Object.defineProperty(topic, "registrationTemplateGuid", {
            value: registrationTemplateGuid,
            writable: false
        });

        Object.defineProperty(topic, "groupGuids", {
            value: groupGuids,
            writable: false
        });

        return topic as GroupPlacementTopic;
    }

    /**
     * Subscribes to the topic using the current Group and AttendanceOccurrence unique identifiers.
     */
    async function startRealTime(): Promise<void> {
        // const groupGuid = config.value.groupGuid;
        // const occurrenceGuid = attendanceOccurrenceGuid.value;
        const registrationInstanceGuid = box.groupPlacementKeys?.registrationInstanceGuid;
        const registrationTemplateGuid = box.groupPlacementKeys?.registrationTemplateGuid;

        console.log("group Guids: ", placementGroupGuids.value);

        // if (topic.value && areEqual(topic.value.groupGuid, groupGuid) && areEqual(topic.value.registrationInstanceGuid, registrationInstanceGuid)
        //     && areEqual(topic.value.registrationTemplateGuid, registrationTemplateGuid)) {
        //     // Skip if already subscribed.
        //     return;
        // }

        // if (!config.value.groupGuid) {
        //     throw "Unable to start real-time";
        // }

        // if (!attendanceOccurrenceGuid.value) {
        //     // If the occurrence is new, do not start real-time yet.
        //     return;
        // }

        const groupPlacementTopic = await getGroupPlacementTopic(placementGroupGuids.value, registrationInstanceGuid, registrationTemplateGuid);
        console.log("TOPIC ", groupPlacementTopic);
        groupPlacementTopic.onDisconnected(async () => {
            await startRealTime();
        });

        groupPlacementTopic.on("groupMemberUpdated", onGroupMemberUpdatedFromServer);
        groupPlacementTopic.on("groupMemberDeleted", onGroupMemberDeletedFromServer);
        groupPlacementTopic.on("registrantUpdated", onRegistrantUpdatedFromServer);
        groupPlacementTopic.on("registrantDeleted", onRegistrantDeletedFromServer);

        return;
    }

    function onGroupMemberUpdatedFromServer(groupMember: GroupMemberUpdatedMessageBag): void {
        console.log("Reltime update of Group Member: ", groupMember);

        if (groupMember.groupIdKey === box.groupPlacementKeys?.sourceGroupIdKey) {
            // If a group member was added to the source group then we add to peopleToPlace

        }
        else {
            const { placementGroup, existingPerson } = getPlacementContext(groupMember);

            if (!placementGroup) {
                return;
            }

            const personToUse = existingPerson || groupMember.person;

            placementGroup.groupMembers!.push({
                groupMemberId: groupMember.groupMemberId,
                groupRoleIdKey: groupMember.groupRoleIdKey,
                person: personToUse,
                groupMemberIdKey: groupMember.groupMemberIdKey
            });

            if (!box.isPlacementAllowingMultiple) {
                peopleToPlace.value = peopleToPlace.value.filter(
                    p => groupMember.person?.personIdKey !== p.personIdKey
                );
            }
        }

    }

    function onGroupMemberDeletedFromServer(_groupMemberGuid: Guid, groupMember: GroupMemberUpdatedMessageBag): void {
        console.log("Realtime removal of Group Member: ", groupMember);

        const { placementGroup, existingPerson } = getPlacementContext(groupMember);
        if (!placementGroup) {
            return;
        }

        groupMember.person = existingPerson || groupMember.person;

        // If the person does not have a Registrant in any of the included Registration Instances, then they should not be shown in the People To Place Panel.
        // This matches with functionality from the old Webforms Block.
        // TODO - maybe move this to filter computed?
        if (shouldPersonBeDisplayed(groupMember) && groupMember.person) {
            peopleToPlace.value.push({ ...groupMember.person });
        }

        placementGroup.groupMembers = placementGroup.groupMembers?.filter(gm => gm.groupMemberIdKey !== groupMember.groupMemberIdKey);
    }

    function onRegistrantUpdatedFromServer(registrant: RegistrationRegistrantUpdatedMessageBag): void {
        console.log("Realtime update of Registrant: ", registrant);

        if (isNullOrWhiteSpace(registrant.person?.personIdKey)) {
            return;
        }

        const existingPerson = getExistingPerson(registrant.person!.personIdKey!);

        if (existingPerson) {
            if (!existingPerson.registrants) {
                existingPerson.registrants = [];
            }
            existingPerson.registrants.push({
                registrantIdKey: registrant.registrantIdKey,
                registrationInstanceIdKey: registrant.registrationInstanceIdKey,
                registrationInstanceName: registrant.registrationInstanceName
            } as RegistrantBag);
        }
        else {

            var newPerson = registrant.person! as PersonBag;
            newPerson.registrants = [{
                registrantIdKey: registrant.registrantIdKey,
                registrationInstanceIdKey: registrant.registrationInstanceIdKey,
                registrationInstanceName: registrant.registrationInstanceName
            } as RegistrantBag];

            peopleToPlace.value.push(newPerson);
        }
    }

    function onRegistrantDeletedFromServer(_registrantGuid: Guid, registrant: RegistrationRegistrantUpdatedMessageBag): void {
        console.log("Realtime delete of Registrant: ", registrant);

        const personInPeopleToPlace = peopleToPlace.value.find(p => p.personIdKey === registrant.person?.personIdKey);
        if (personInPeopleToPlace && personInPeopleToPlace.registrants) {
            personInPeopleToPlace.registrants = personInPeopleToPlace.registrants.filter(
                r => r.registrantIdKey !== registrant.registrantIdKey
            );

            // Remove person if they have no registrants left
            if (personInPeopleToPlace.registrants.length === 0) {
                peopleToPlace.value = peopleToPlace.value.filter(
                    p => p.personIdKey !== personInPeopleToPlace.personIdKey
                );
            }
        }

        // Update in all placement groups
        for (const group of placementGroups.value) {
            for (const gm of group.groupMembers ?? []) {
                if (gm.person?.personIdKey === registrant.person?.personIdKey && gm.person?.registrants) {
                    gm.person.registrants = gm.person.registrants.filter(
                        r => r.registrantIdKey !== registrant.registrantIdKey
                    );
                }
            }
        }
    }

    // #endregion

    // #region Block Actions

    async function getPlacementPeople(): Promise<PlacementPeopleBag> {
        arePeopleLoading.value = true;

        const result = await invokeBlockAction<PlacementPeopleBag>("GetPlacementPeople", {
            groupPlacementKeys: box.groupPlacementKeys,
            isPlacementAllowingMultiple: box.isPlacementAllowingMultiple
        });

        if (result.isSuccess && result.data) {
            console.log("PEOPLE RESULT: ", result.data);
            return result.data;
        }
        else {
            console.error(result.errorMessage);
        }
        return {};
    }

    async function getDestinationGroups(): Promise<PlacementGroupBag[]> {
        areGroupsLoading.value = true;

        const result = await invokeBlockAction<PlacementGroupBag[]>("GetDestinationGroups", {
            groupPlacementKeys: box.groupPlacementKeys
        });

        if (result.isSuccess && result.data) {
            return result.data;
        }
        else {
            console.error(result.errorMessage);
        }
        return [];
    }

    async function populateAttributeFilters(): Promise<AttributeFiltersBag> {
        areGroupsLoading.value = true;

        const result = await invokeBlockAction<AttributeFiltersBag>("PopulateAttributeFilters", {
            groupPlacementKeys: box.groupPlacementKeys
        });

        if (result.isSuccess && result.data) {
            return result.data;
        }
        else {
            console.error(result.errorMessage);
        }
        return {};
    }

    async function addGroupMembersToGroup(pendingGroupMembers: GroupMemberBag[], placementGroup: PlacementGroupBag): Promise<GroupMemberBag[]> {
        const result = await invokeBlockAction<GroupMemberBag[]>("AddGroupMembersToGroup", {
            addGroupMembersBag: {
                pendingGroupMembers,
                targetGroup: placementGroup,
                placementMode: box.placementMode,
                groupPlacementKeys: box.groupPlacementKeys
            } as AddGroupMembersBag
        });

        if (result.isSuccess && result.data) {
            return result.data;
        }
        else {
            if (pendingGroupMembers[0].groupRoleIdKey) {
                setGroupRoleError(placementGroup.groupIdKey!, pendingGroupMembers[0].groupRoleIdKey, result.errorMessage ?? "Unknown error while trying to add a group member.");
            }
        }
        return [];
    }

    async function removeGroupMemberFromGroup(groupMemberIdKey: string, groupIdKey: string): Promise<boolean> {
        const result = await invokeBlockAction<GroupMemberBag[]>("RemoveGroupMemberFromGroup", {
            groupMemberIdKey: groupMemberIdKey,
            groupIdKey: groupIdKey
        });

        if (result.isSuccess) {
            console.log("Remove group member success.");
            return true;
        }
        else {
            console.error(result.errorMessage ?? "Unknown error while trying to remove a group member.");
        }
        return false;
    }

    async function addGroup(addGroupBag: AddGroupBag) {
        // TODO - need to make grouptypeid non nullable
        if (!box.destinationGroupType?.idKey) {
            console.error("Group Type Id required");
            return;
        }

        addGroupBag.groupPlacementKeys = box.groupPlacementKeys;
        addGroupBag.groupTypeIdKey = box.destinationGroupType.idKey;

        const result = await invokeBlockAction("AddPlacementGroup", {
            addGroupBag
        });

        if (result.isSuccess) {
            console.log("Add group success.");
            addGroupModalElement.value?.resetForm();
            isAddGroupModalVisible.value = false;
            loadPlacementData();
        }
        else {
            addGroupModalErrorText.value = result.errorMessage ?? "Unknown error while adding a group.";
        }
    }

    async function detachPlacementGroup(groupIdKey: string): Promise<void> {
        const result = await invokeBlockAction("DetachPlacementGroup", {
            detachGroupBag: {
                groupIdKey: groupIdKey,
                groupPlacementKeys: box.groupPlacementKeys,
                placementMode: box.placementMode
            } as DetachGroupBag
        });

        if (result.isSuccess) {
            // TODO - this doesn't work on template mode. Same on Webforms.
            console.log("Detach group success.");
            loadPlacementData();
        }
        else {
            console.error(result.errorMessage ?? "Unknown error while trying to detach a group.");
        }
    }

    async function deletePlacementGroup(groupIdKey: string): Promise<void> {
        const result = await invokeBlockAction("DeletePlacementGroup", {
            groupIdKey: groupIdKey
        });

        if (result.isSuccess) {
            console.log("Delete group success.");
            loadPlacementData();
        }
        else {
            console.error(result.errorMessage ?? "Unknown error while trying to delete a group.");
        }
    }

    // #endregion

    // #region Watchers

    watch(selectionInfoElement, element => {
        if (element) {
            tooltip(element);
        }
    });

    // watch(isPersonSearchVisible, () => {
    //     if (!isPersonSearchVisible.value) {
    //         personSearchText.value = "";
    //     }
    // });

    watch([currentSortOrder, isGenderHighlighting, sourceAttributeValuesForFilter, registrantFeeItemValuesForFilter, destinationAttributeValuesForFilter, destinationMemberAttributeValuesForFilter], async () => {
        preferences.setValue(getSortOrderKey(), currentSortOrder.value.toString());
        preferences.setValue(getIsGenderHighlightingKey(), isGenderHighlighting.value.toString());
        preferences.setValue(getPersonAttributeFilterKey(), JSON.stringify(sourceAttributeValuesForFilter.value));
        preferences.setValue(getRegistrantFeeItemValuesFilterKey(), JSON.stringify(registrantFeeItemValuesForFilter.value));
        preferences.setValue(getGroupAttributeFilterKey(), JSON.stringify(destinationAttributeValuesForFilter.value));
        preferences.setValue(getGroupMemberAttributeFilterKey(), JSON.stringify(destinationMemberAttributeValuesForFilter.value));

        await preferences.save();
    });

    watch([selectedPersonIdKeys, filteredAndSortedPeopleToPlace], () => {
        if (filteredAndSortedPeopleToPlace.value.length === 0) {
            areAllPeopleSelected.value = false;
        }
        else {
            areAllPeopleSelected.value = filteredAndSortedPeopleToPlace.value.every(person => {
                if (person.personIdKey) {
                    return selectedPersonIdKeys.value.has(person.personIdKey);
                }
            });
        }

    }, { deep: true });

    watch(placementGroupGuids, (newValue, oldValue) => {
        if (!realTimetopic.value) {
            startRealTime();
            return;
        }

        // if (!isNullOrWhiteSpace(oldValue)) {
        //     leaveRealTimeChannel(oldValue);
        // }

        // if (!isNullOrWhiteSpace(newValue)) {
        //     addRealtimeChannel(newValue);
        // }
    });

    // #endregion

    onMounted(async () => {
        document.addEventListener("click", handleOutsideClick);

        // nextTick(() => {
        //     startRealTime();
        // });

        loadPlacementData();
    });

    onBeforeUnmount(() => {
        document.removeEventListener("click", handleOutsideClick);
    });

</script>