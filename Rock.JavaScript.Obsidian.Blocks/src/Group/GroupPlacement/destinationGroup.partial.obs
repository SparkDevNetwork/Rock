<template>
    <Panel type="block" v-model="isGroupExpanded" :hasCollapse="true" :headerSecondaryActions="secondaryActions">
        <template #title>
            <div class="d-flex align-items-center gap-2">
                {{ destinationGroup.groupName }}
                <Badge :class="[capacityStatusClass]">{{ capacityText }}</Badge>
                <span v-for="role in groupTypeRoles"
                      :key="role.id"
                      :class="['role-count', getRoleCountOverUnderCapacityClass(role.id)]">
                    {{ pluralize(role.name ?? "") }}: {{ getRoleCount(role.id) }}
                </span>
            </div>
        </template>
        <template #headerActions v-if="!isGroupExpanded">
            <div class="d-flex gap-1 mr-3">
                <Badge class="unknown-badge">{{ genderCounts.unknown }}</Badge>
                <Badge class="male-badge">{{ genderCounts.males }}</Badge>
                <Badge class="female-badge">{{ genderCounts.females }}</Badge>
            </div>
        </template>
        <div v-for="role in groupTypeRoles" :key=role.id class="panel-inline">
            <div class="panel-heading">
                <h1 class="panel-title d-inline-block mr-2">
                    {{ pluralize(role.name ?? "") }}
                </h1>
                <span :class="['role-count', getRoleCountOverUnderCapacityClass(role.id)]"
                      :ref="(el) => addTooltip(el as Element)"
                      data-toggle="tooltip"
                      :data-html="true"
                      :data-original-title="getRoleCountTooltipText(role.id)">
                    {{ getRoleSubHeaderText(role.id) }}
                </span>
            </div>
            <div class="group-wrapper">
                <PersonCard v-for="(person, index) in getPlacedPeopleFilteredByRole(role.id)"
                            :key="index"
                            :isCardExpanded="areCardsExpanded"
                            :person="person"
                            :index="index" />
            </div>
        </div>
    </Panel>
</template>

<style scoped>
:deep(.panel.panel-block) {
    height: 100%;
    margin-bottom: 24px;
}

.panel-inline {
    margin-bottom: 0 !important;
    border: none !important;
    border-radius: 0 !important;
    box-shadow: none !important;
    -webkit-bot-shadow: none !important
}

.panel-inline .panel-heading {
    padding: 8px 16px;
    background-color: rgba(245, 245, 245, 0.8);
    border-top: 1px solid #eee
}

.panel-inline .panel-title {
    font-size: 14px;
    font-weight: 600
}

.panel-drawer + .group-role-members .panel-heading,
.group-role-members:first-child .panel-heading {
    border-top: 0
}

.placement-capacity-label {
    border-radius: 100px;
}

.role-count {
    font-size: var(--font-size-small);
    font-weight: var(--font-weight-regular);
    color: var(--color-interface-medium);
}

.role-count.over-under-role-capacity {
    color: var(--color-danger);
}

.male-badge {
    background-color: #1A8AE5 !important;
}

.female-badge {
    background-color: #DE69CE !important;
}

.unknown-badge {
    background-color: var(--color-interface-soft) !important;
    color: var(--color-interface-stronger) !important;
}

.status-over {
    background-color: #d4442e !important;
}

.status-at {
    background-color: #ee7624 !important;
}

.status-near {
    background-color: #ffc870 !important;
    color: black;
}

.status-under {
    background-color: #16c98d !important;
}

.group-wrapper {
    display: grid;
    gap: 1rem;
    grid-template-columns: repeat(auto-fit, 300px);
    padding: 16px;
}

/* @media (min-width: 1024px) {
    .group-wrapper {
        grid-template-columns: repeat(2, 300px);
    }
}

@media (min-width: 1440px) {
    .group-wrapper {
        grid-template-columns: repeat(3, 300px);
    }
}

@media (min-width: 1800px) {
    .group-wrapper {
        grid-template-columns: repeat(4, 300px);
    }
}

@media (min-width: 2000px) {
    .group-wrapper {
        grid-template-columns: repeat(5, 300px);
    }
} */
</style>

<script setup lang="ts">
    import { PropType, ref, computed } from "vue";
    import Panel from "@Obsidian/Controls/panel.obs";
    import { PlacementGroupBag } from "@Obsidian/ViewModels/Blocks/Group/GroupPlacement/placementGroupBag";
    import { PersonBag } from "@Obsidian/ViewModels/Blocks/Group/GroupPlacement/personBag";
    import { PlacementGroupTypeRoleBag } from "@Obsidian/ViewModels/Blocks/Group/GroupPlacement/placementGroupTypeRoleBag";
    import PersonCard from "./personCard.partial.obs";
    import Badge from "@Obsidian/Controls/badge.obs";
    import { PanelAction } from "@Obsidian/Types/Controls/panelAction";
    import { pluralize } from "@Obsidian/Utility/stringUtils";
    import { tooltip } from "@Obsidian/Utility/tooltip";
    import { Gender } from "@Obsidian/Enums/Crm/gender";

    const props = defineProps({
        destinationGroup: {
            type: Object as PropType<PlacementGroupBag>,
            required: true
        },
        groupTypeRoles: {
            type: Array as PropType<PlacementGroupTypeRoleBag[]>,
        },
        areCardsExpanded: {
            type: Boolean,
            default: false
        }
    });

    const emit = defineEmits<{
        // (e: "toggleCardExpansion"): void;
    }>();

    const destinationGroup = ref<PlacementGroupBag>(props.destinationGroup);
    const groupTypeRoles = ref<PlacementGroupTypeRoleBag[]>(props.groupTypeRoles ?? []);
    const isGroupExpanded = ref<boolean>(true);

    const capacityStatusClass = computed(() => {
        if (!destinationGroup.value.groupCapacity) {
            return "status-under";
        }

        const groupMemberCount = destinationGroup.value.groupMembers?.length ?? 0;
        const groupCapacityPercent = (groupMemberCount / destinationGroup.value.groupCapacity) * 100;

        if (groupCapacityPercent > 100) {
            return "status-over";
        }
        else if (groupCapacityPercent === 100) {
            return "status-at";
        }
        else if (groupCapacityPercent > 80) {
            return "status-near";
        }
        else {
            return "status-under";
        }
    });

    const genderCounts = computed(() => {
        const counts = {
            males: 0,
            females: 0,
            unknown: 0
        };

        if (!destinationGroup.value.groupMembers) {
            return counts;
        }

        for (const person of destinationGroup.value.groupMembers) {
            switch (person.gender) {
                case Gender.Male:
                    counts.males++;
                    break;
                case Gender.Female:
                    counts.females++;
                    break;
                default:
                    counts.unknown++;
                    break;
            }
        }

        return counts;
    });

    const capacityText = computed(() => {
        const groupMemberCount = destinationGroup.value.groupMembers?.length ?? 0;

        if (!destinationGroup.value.groupCapacity) {
            return `${groupMemberCount}`;
        }

        return `${groupMemberCount} / ${destinationGroup.value.groupCapacity}`;
    });


    const secondaryActions = computed((): PanelAction[] | undefined => {
        const actions: PanelAction[] = [];

        actions.push({
            type: "default",
            title: "Edit",
            handler: actionGoesHere
        });

        return actions;
    });

    function getRoleCount(roleId: number): number {
        return destinationGroup.value.groupMembers?.filter(gm => gm.groupRoleId === roleId).length ?? 0;
    }

    // Low Priority TODO - there is a ux/ui issue when a panel is collapsed and the secondary actions dropdown is opened
    function getRoleCountOverUnderCapacityClass(roleId: number): string {
        const role = groupTypeRoles.value.find(r => r.id === roleId);
        const roleMax = role?.maxCount;
        const roleMin = role?.minCount;
        const count = getRoleCount(roleId);

        if (count == null) {
            return "";
        }

        const isOver = roleMax != null && count > roleMax;
        const isUnder = roleMin != null && count < roleMin;

        return (isOver || isUnder) ? "over-under-role-capacity" : "";
    }

    function getRoleSubHeaderText(roleId: number): string {
        const role = groupTypeRoles.value.find(r => r.id === roleId);
        return role?.maxCount ? `${getRoleCount(roleId)}/${role.maxCount}` : `${getRoleCount(roleId)}`;
    }

    function getPlacedPeopleFilteredByRole(roleId: number): PersonBag[] {
        return destinationGroup.value.groupMembers?.filter(gm => gm.groupRoleId === roleId) ?? [];
    }

    function getRoleCountTooltipText(roleId: number): string {
        const role = groupTypeRoles.value.find(r => r.id === roleId);
        if (!role) {
            return "";
        }

        const parts: string[] = [];

        if (role.maxCount != null) {
            parts.push(`Maximum Total: ${role.maxCount}`);
        }

        if (role.minCount != null) {
            parts.push(`Minimum Total: ${role.minCount}`);
        }

        return parts.join("<br>");
    }

    function actionGoesHere() {
        // Logic to handle the action goes here
    }

    function addTooltip(element: Element | null): void {
        if (element) {
            tooltip(element);
        }
    }
</script>