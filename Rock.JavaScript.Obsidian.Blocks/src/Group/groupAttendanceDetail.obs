<!-- Copyright by the Spark Development Network; Licensed under the Rock Community License -->
<template>
    <NotificationBox v-if="config.isAuthorizedGroupNotFoundError" alertType="danger">
        <strong>Sorry</strong>
        <p>Group was not found or you're not authorized to update the attendance for the selected group.</p>
    </NotificationBox>
    <NotificationBox v-if="config.isNoAttendanceOccurrencesError" alertType="danger">
        <strong>No Occurrences</strong>
        <p>There are currently not any active occurrences for selected group for which to take attendance.</p>
    </NotificationBox>
    <NotificationBox v-if="config.errorMessage" alertType="danger">
        <strong>Sorry</strong>
        <p>{{ config.errorMessage }}</p>
    </NotificationBox>
    <div v-if="!config.isConfigError">
        <Panel :title="panelTitle">
            <template v-if="config.isCampusFilteringAllowed" #headerActions>
                <div class="mr-2">
                    <CampusFilter v-model="campusFilter"
                        v-model:campusGuid="campusGuid"
                        :campusStatusFilter="config.campusStatusFilter"
                        :campusTypeFilter="config.campusTypeFilter" />
                </div>
            </template>

            <template #preBody>
                <div class="attendance-header">
                    <div class="row">
                        <div class="col-xs-12 col-sm-4">
                            <DatePicker
                                        v-if="config.attendanceOccurrenceDateSelectionMode === GroupAttendanceDetailDateSelectionMode.DatePicker"
                                        :modelValue="attendanceForDateString"
                                        @update:modelValue="onAttendanceForDateUpdated"
                                        :disabled="!isAutoSaveOn"
                                        :displayCurrentOption="false"
                                        :isCurrentDateOffset="false"
                                        :disableForceParse="false"
                                        :disableShowOnFocus="false"
                                        :disableHighlightToday="false"
                                        :disallowFutureDateSelection="config.isFutureOccurrenceDateSelectionRestricted"
                                        :disallowPastDateSelection="false"
                                        label="Attendance For" />
                            <div v-else-if="config.attendanceOccurrenceDateSelectionMode === GroupAttendanceDetailDateSelectionMode.Readonly">
                                <RockLabel>Attendance For</RockLabel>
                                <div>{{ attendanceForDateString }}</div>
                            </div>
                        </div>

                        <div class="col-xs-12 col-sm-4">
                            <GroupLocationPicker
                                                 v-if="config.locationSelectionMode === GroupAttendanceDetailLocationSelectionMode.GroupLocationPicker"
                                                 :disabled="!isAutoSaveOn"
                                                 :groupGuid="config.groupGuid"
                                                 label="Location"
                                                 :showBlankItem="true"
                                                 @update:modelValue="onGroupLocationPickerChanged" />
                            <div v-else-if="config.locationSelectionMode === GroupAttendanceDetailLocationSelectionMode.Readonly">
                                <RockLabel>Location</RockLabel>
                                <div>{{ config.locationLabel }}</div>
                            </div>
                        </div>

                        <div class="col-xs-12 col-sm-4">
                            <template v-if="locationGuid || !config.isLocationRequired">
                                <GroupLocationScheduleDatePicker v-if="config.attendanceOccurrenceDateSelectionMode === GroupAttendanceDetailDateSelectionMode.ScheduledDatePicker"
                                                                 @update:modelValue="onGroupLocationScheduleDatePickerChanged"
                                                                 :date="config.isDateIncludedInPickFromSchedule ? RockDateTime.parseISO(config.attendanceOccurrenceDate || '') : null"
                                                                 :disabled="!isAutoSaveOn"
                                                                 :groupGuid="config.groupGuid"
                                                                 label="Attendance For"
                                                                 :locationGuid="locationGuid"
                                                                 :numberOfPreviousDaysToShow="config.numberOfPreviousDaysToShow"
                                                                 :showBlankItem="true" />

                                <GroupLocationSchedulePicker v-else-if="config.scheduleSelectionMode === GroupAttendanceDetailScheduleSelectionMode.GroupLocationSchedulePicker && locationGuid"
                                                             @update:modelValue="onGroupLocationSchedulePickerChanged"
                                                             :disabled="!isAutoSaveOn"
                                                             :groupGuid="config.groupGuid"
                                                             label="Schedule"
                                                             :locationGuid="locationGuid"
                                                             :isoDateString="attendanceForDateIsoString"
                                                             :showBlankItem="true" />

                                <div v-else-if="config.scheduleSelectionMode === GroupAttendanceDetailScheduleSelectionMode.Readonly">
                                    <RockLabel>Schedule</RockLabel>
                                    <div v-html="config.scheduleLabel"></div>
                                </div>
                            </template>
                        </div>
                    </div>

                    <TransitionVerticalCollapse speed="fast">
                        <div class="mt-5">
                            <div class="d-flex align-items-end">
                                <InlineCheckBox
                                                v-if="isDidNotMeetShown"
                                                class="mb-0"
                                                :modelValue="didNotOccur"
                                                :disabled="isSavingDidNotOccur || config.isDidNotMeetDisabled || !isAutoSaveOn"
                                                label="We Did Not Meet"
                                                @update:modelValue="onDidNotOccurChanged" />

                                <RadioButtonList
                                                 v-if="config.attendanceOccurrenceTypes && config.isAttendanceOccurrenceTypesSectionShown"
                                                 :disabled="!isAutoSaveOn"
                                                 :formGroupClasses="'mb-0' + (isDidNotMeetShown ? ' ml-3' : '')"
                                                 :horizontal="true"
                                                 :items="config.attendanceOccurrenceTypes"
                                                 :label="config.attendanceOccurrenceTypesSectionLabel"
                                                 :modelValue="attendanceOccurrenceTypeGuid"
                                                 @update:modelValue="onAttendanceOccurrenceTypeChanged" />

                                <div v-if="!didNotOccur" class="ml-auto d-flex align-items-end">
                                    <PersonPicker
                                                  v-if="config.isNewAttendeeAdditionAllowed"
                                                  :disabled="!isAutoSaveOn"
                                                  formGroupClasses="mb-0"
                                                  :label="addPersonAsLabel"
                                                  :modelValue="addPersonSelection"
                                                  @update:modelValue="onAddPerson($event)" />
                                    <RockButton
                                                v-if="config.addGroupMemberPageUrl"
                                                btnType="default"
                                                :disabled="!isAutoSaveOn"
                                                @click="onAddGroupMemberClicked">Add Group Member</RockButton>
                                </div>
                            </div>
                        </div>
                    </TransitionVerticalCollapse>
                </div>
            </template>

            <template #default>
                <NotificationBox v-if="errorMessage" alertType="danger">{{ errorMessage }}</NotificationBox>
                <NotificationBox v-if="!isPrintingRoster && printRosterWarning" alertType="warning">{{ printRosterWarning }}</NotificationBox>

                <TransitionVerticalCollapse speed="fast">
                    <div>
                        <TransitionVerticalCollapse speed="fast">
                            <div v-show="!didNotOccur">
                                <div class="row">
                                    <div class="col-xs-12 col-sm-8 d-sm-flex">
                                        <DidAttendFilter v-model="didAttendFilter" :attendances="attendances" />
                                        <SearchFilter v-model="searchFilter" class="flex-grow-1 mt-2 mt-sm-0 ml-sm-2" />
                                    </div>
                                    <div class="col-xs-12 col-sm-4 d-flex justify-content-end">
                                        <div class="form-group mb-sm-0 btn-group">
                                            <RockButton v-if="!config.isNotesSectionHidden"
                                                        btnSize="sm"
                                                        :btnType="isNotesShown ? 'primary' : 'default'"
                                                        :disabled="!isAutoSaveOn"
                                                        @click="onShowNotesClicked()"><i class="fa fa-pencil-alt"></i> Add Note</RockButton>
                                            <RockButton v-if="config.isRosterDownloadShown"
                                                        btnType="default"
                                                        btnSize="sm"
                                                        :disabled="!isAutoSaveOn"
                                                        @click="onPrintAttendanceRosterClicked()"><i class="fa fa-file-download"></i> Roster</RockButton>
                                        </div>
                                    </div>
                                </div>

                                <TransitionVerticalCollapse speed="fast" v-if="!config.isNotesSectionHidden">
                                    <div v-show="isNotesShown">
                                        <TextBox
                                                 v-model="notes"
                                                 :disabled="!isAutoSaveOn"
                                                 :label="config.notesSectionLabel || 'Notes'"
                                                 :rows="3"
                                                 textMode="multiline"
                                                 @update:modelValue="autoUpdateNotes" />
                                    </div>
                                </TransitionVerticalCollapse>

                                <InitialsFilter
                                                v-if="!isLongListDisabled"
                                                v-model="rosterFilter"
                                                :attendances="attendances"
                                                :isFilterByFirstNameInitial="false"
                                                :isMultiselect="false" />

                                <AttendanceRoster
                                                  :attendances="attendances"
                                                  class="form-group"
                                                  :disabled="!isAutoSaveOn"
                                                  :filterBy="attendanceFilterByDelegate"
                                                  :groupBy="attendanceGroupByDelegate"
                                                  :isLongListDisabled="isLongListDisabled"
                                                  :sortBy="attendanceSortByDelegate"
                                                  @attendanceChanged="onAttendanceChanged($event)" />

                            </div>
                        </TransitionVerticalCollapse>
                    </div>
                </TransitionVerticalCollapse>
            </template>

            <template #footerActions>
                <RockButton v-if="!isBackButtonHidden" @click="onBackClicked()">Back</RockButton>
            </template>
        </Panel>
    </div>
    <Modal v-if="modalOptions"
           v-model="modalOptions.isOpen"
           :cancelText="modalOptions.cancelText"
           :saveText="modalOptions.saveText"
           @save="onModalSave">{{ modalOptions.text }}</Modal>
</template>

<style scoped>
.attendance-header {
    padding: 15px;
    background-color: #FBFBFB;
    border-bottom: 1px solid #DFE0E1;
}

.attendance-footer {
    margin-left: -15px;
    margin-right: -15px;
    border-top: 1px solid #DFE0E1;
}
</style>

<script setup lang="ts">
    import { computed, nextTick, ref } from "vue";
    import DidAttendFilter from "./GroupAttendanceDetail/didAttendFilter.partial.obs";
    import InitialsFilter from "./GroupAttendanceDetail/initialsFilter.partial.obs";
    import AttendanceRoster from "./GroupAttendanceDetail/attendanceRoster.partial.obs";
    import CampusFilter from "./GroupAttendanceDetail/campusFilter.partial.obs";
    import { sortByFirstName, sortByLastName, createEveryFilter as every, createSortBy, createSwitch, IAttendanceFilter, NoFilter, DidAttendFilter as DidAttend, createModalOptions } from "./GroupAttendanceDetail/utils.partial";
    import GroupLocationPicker from "./GroupAttendanceDetail/groupLocationPicker.partial.obs";
    import GroupLocationScheduleDatePicker from "./GroupAttendanceDetail/groupLocationScheduleDatePicker.partial.obs";
    import GroupLocationSchedulePicker from "./GroupAttendanceDetail/groupLocationSchedulePicker.partial.obs";
    import SearchFilter from "./GroupAttendanceDetail/searchFilter.partial.obs";
    import { AttendanceSortByDelegate, AttendanceFilterByDelegate, AttendanceGroupByDelegate, ModalOptionsBag } from "./GroupAttendanceDetail/types.partial";
    import NotificationBox from "@Obsidian/Controls/notificationBox.obs";
    import DatePicker from "@Obsidian/Controls/datePicker.obs";
    import InlineCheckBox from "@Obsidian/Controls/inlineCheckBox.obs";
    import Modal from "@Obsidian/Controls/modal.obs";
    import Panel from "@Obsidian/Controls/panel.obs";
    import PersonPicker from "@Obsidian/Controls/personPicker.obs";
    import RadioButtonList from "@Obsidian/Controls/radioButtonList.obs";
    import RockButton from "@Obsidian/Controls/rockButton.obs";
    import RockLabel from "@Obsidian/Controls/rockLabel.obs";
    import TextBox from "@Obsidian/Controls/textBox.obs";
    import TransitionVerticalCollapse from "@Obsidian/Controls/transitionVerticalCollapse.obs";
    import { GroupAttendanceDetailDateSelectionMode } from "@Obsidian/Enums/Blocks/Group/GroupAttendanceDetail/groupAttendanceDetailDateSelectionMode";
    import { GroupAttendanceDetailLocationSelectionMode } from "@Obsidian/Enums/Blocks/Group/GroupAttendanceDetail/groupAttendanceDetailLocationSelectionMode";
    import { GroupAttendanceDetailScheduleSelectionMode } from "@Obsidian/Enums/Blocks/Group/GroupAttendanceDetail/groupAttendanceDetailScheduleSelectionMode";
    import { AttendanceStatus } from "@Obsidian/Enums/Event/attendanceStatus";
    import { Guid } from "@Obsidian/Types";
    import { onConfigurationValuesChanged, useConfigurationValues, useInvokeBlockAction, useReloadBlock } from "@Obsidian/Utility/block";
    import { RockDateTime } from "@Obsidian/Utility/rockDateTime";
    import { GroupAttendanceDetailAddPersonRequestBag } from "@Obsidian/ViewModels/Blocks/Group/GroupAttendanceDetail/groupAttendanceDetailAddPersonRequestBag";
    import { GroupAttendanceDetailAddPersonResponseBag } from "@Obsidian/ViewModels/Blocks/Group/GroupAttendanceDetail/groupAttendanceDetailAddPersonResponseBag";
    import { GroupAttendanceDetailAttendanceBag } from "@Obsidian/ViewModels/Blocks/Group/GroupAttendanceDetail/groupAttendanceDetailAttendanceBag";
    import { GroupAttendanceDetailGetAttendanceRequestBag } from "@Obsidian/ViewModels/Blocks/Group/GroupAttendanceDetail/groupAttendanceDetailGetAttendanceRequestBag";
    import { GroupAttendanceDetailGetOrCreateRequestBag } from "@Obsidian/ViewModels/Blocks/Group/GroupAttendanceDetail/groupAttendanceDetailGetOrCreateRequestBag";
    import { GroupAttendanceDetailInitializationBox } from "@Obsidian/ViewModels/Blocks/Group/GroupAttendanceDetail/groupAttendanceDetailInitializationBox";
    import { GroupAttendanceDetailMarkAttendanceRequestBag } from "@Obsidian/ViewModels/Blocks/Group/GroupAttendanceDetail/groupAttendanceDetailMarkAttendanceRequestBag";
    import { GroupAttendanceDetailPrintRosterRequestBag } from "@Obsidian/ViewModels/Blocks/Group/GroupAttendanceDetail/groupAttendanceDetailPrintRosterRequestBag";
    import { GroupAttendanceDetailPrintRosterResponseBag } from "@Obsidian/ViewModels/Blocks/Group/GroupAttendanceDetail/groupAttendanceDetailPrintRosterResponseBag";
    import { GroupAttendanceDetailUpdateAttendanceOccurrenceTypeRequestBag } from "@Obsidian/ViewModels/Blocks/Group/GroupAttendanceDetail/groupAttendanceDetailUpdateAttendanceOccurrenceTypeRequestBag";
    import { GroupAttendanceDetailUpdateDidNotOccurRequestBag } from "@Obsidian/ViewModels/Blocks/Group/GroupAttendanceDetail/groupAttendanceDetailUpdateDidNotOccurRequestBag";
    import { GroupAttendanceDetailUpdateNotesRequestBag } from "@Obsidian/ViewModels/Blocks/Group/GroupAttendanceDetail/groupAttendanceDetailUpdateNotesRequestBag";
    import { AttendanceOccurrenceUpdatedMessageBag } from "@Obsidian/ViewModels/Event/attendanceOccurrenceUpdatedMessageBag";
    import { AttendanceUpdatedMessageBag } from "@Obsidian/ViewModels/Event/attendanceUpdatedMessageBag";
    import { ListItemBag } from "@Obsidian/ViewModels/Utility/listItemBag";
    import { getTopic, ITopic, ServerFunctions } from "@Obsidian/Utility/realTime";
    import { areEqual, emptyGuid, toGuidOrNull } from "@Obsidian/Utility/guid";
    import { isPromise, PromiseCompletionSource } from "@Obsidian/Utility/promiseUtils";
    import { debounce } from "@Obsidian/Utility/util";

    const config = ref(useConfigurationValues<GroupAttendanceDetailInitializationBox>());
    const invokeBlockAction = useInvokeBlockAction();

    type NullableListItemBags = ListItemBag | ListItemBag[] | null;

    type GroupAttendanceTopic = ITopic<ServerFunctions<unknown>> & {
        attendanceOccurrenceGuid: Guid,
        groupGuid: Guid
    };

    const autoMarkAttendanceSwitch = createSwitch();
    const autoMarkAttendance = autoMarkAttendanceSwitch.connectToFunc(markAttendance);

    const autoUpdateDidNotOccurSwitch = createSwitch();
    const autoUpdateDidNotOccur = autoUpdateDidNotOccurSwitch.connectToFunc(updateDidNotOccur);

    const autoUpdateAttendanceOccurrenceTypeSwitch = createSwitch();
    const autoUpdateAttendanceOccurrenceType = autoUpdateAttendanceOccurrenceTypeSwitch.connectToFunc(updateAttendanceOccurrenceType);

    const autoUpdateNotesSwitch = createSwitch();
    const autoUpdateNotes = autoUpdateNotesSwitch.connectToFunc(debouncePromise(updateNotes, 1000));

    //#region Values

    const isAutoSaveOn = ref<boolean>(true);
    const modalOptions = ref<ModalOptionsBag | null>(null);
    const isPrintingRoster = ref<boolean>(false);
    const printRosterWarning = ref<string>("");
    const errorMessage = ref<string>("");
    const searchFilter = ref<IAttendanceFilter>(NoFilter);
    const campusFilter = ref<IAttendanceFilter>(NoFilter);
    const rosterFilter = ref<IAttendanceFilter>(NoFilter);
    const didAttendFilter = ref<IAttendanceFilter>(NoFilter);
    const attendanceOccurrenceGuid = ref<string | null | undefined>(config.value.attendanceOccurrenceGuid);
    const attendanceForDate = ref<RockDateTime>(
        (config.value.attendanceOccurrenceDate
            ? RockDateTime.parseISO(config.value.attendanceOccurrenceDate)
            : null) ?? RockDateTime.now()
    );
    const attendanceOccurrenceTypeGuid = ref<Guid | undefined>(config.value.selectedAttendanceOccurrenceTypeValue ?? undefined);
    const locationGuid = ref<Guid | undefined | null>(config.value.locationGuid);
    const scheduleGuid = ref<Guid | undefined | null>(config.value.scheduleGuid);
    const didNotOccur = ref<boolean>(config.value.isDidNotMeetChecked);
    const isSavingDidNotOccur = ref<boolean>(false);
    const campusGuid = ref<Guid | null | undefined>();
    const notes = ref<string>(config.value.notes ?? "");
    const topic = ref<GroupAttendanceTopic | null>();
    const isNotesShown = ref<boolean>(false);
    const addPersonSelection = ref<ListItemBag | undefined>();

    //#endregion

    //#region Computed Values

    const isDidNotMeetShown = computed<boolean>(() => !config.value.isDidNotMeetDisabled || didNotOccur.value);
    const dateFormat = computed(() => config.value.attendanceOccurrenceDateSelectionMode === GroupAttendanceDetailDateSelectionMode.DatePicker ? "yyyy-MM-dd" : "dddd, MMMM d, yyyy");
    const attendanceForDateIsoString = computed<string | null>(() => attendanceForDate.value?.toISOString());
    const attendanceForDateString = computed<string>(() => attendanceForDate.value.toASPString(dateFormat.value));
    const addPersonAsLabel = computed(() => {
        if (config.value.addPersonAs) {
            return `Add Person As ${config.value.addPersonAs}`;
        }
        else {
            return "Add Person";
        }
    });
    const panelTitle = computed(() => config.value.groupName ? `${config.value.groupName} Attendance` : "Group Attendance");
    const attendances = computed<GroupAttendanceDetailAttendanceBag[]>(() => config.value?.attendances ?? []);
    const attendanceSortByDelegate = ref<AttendanceSortByDelegate>(createSortBy(sortByLastName, sortByFirstName));
    const attendanceFilterByDelegate = computed<AttendanceFilterByDelegate | null>(() => {
        const filtersToCheck = [campusFilter.value, searchFilter.value, rosterFilter.value, didAttendFilter.value];
        const filters = filtersToCheck.filter(filterToCheck => !filterToCheck.isFilter(NoFilter));

        if (filters.length === 0) {
            return null;
        }
        else if (filters.length === 1) {
            return filters[0].filter;
        }
        else {
            return every(...filters).filter;
        }
    });
    const attendanceGroupByDelegate = computed<AttendanceGroupByDelegate | null>(() => {
        // Always group by last name regardless of sort.
        return (attendance: GroupAttendanceDetailAttendanceBag) => attendance.lastName?.charAt(0) || "?";
    });
    const isBackButtonHidden = computed<boolean>(() => config.value.isBackButtonHidden || !config.value.backPageUrl);
    const isLongListDisabled = computed<boolean>(() => config.value.isLongListDisabled || attendances.value.length <= 50);

    //#endregion

    //#region Event Handlers

    /**
     * Event handler for the "Add Person As" person being selected.
     */
    async function onAddPerson(personPickerSelection: ListItemBag | undefined): Promise<void> {
        const personAliasGuid = toGuidOrNull((personPickerSelection as ListItemBag)?.value);

        if (!personAliasGuid || areEqual(personAliasGuid, emptyGuid)) {
            // No person selected.
            return;
        }

        const occurrenceGuid = toGuidOrNull(attendanceOccurrenceGuid.value);

        if (!occurrenceGuid || areEqual(occurrenceGuid, emptyGuid)) {
            // Create a new occurrence if it hasn't been saved yet.
            await getOrCreateAttendanceOccurrence({
                attendanceOccurrenceDate: attendanceForDateIsoString.value,
                locationGuid: locationGuid.value,
                scheduleGuid: scheduleGuid.value,

                // This will ensure the expected attendance is updated on the existing or newly created occurrence.
                addedPersonAliasGuid: personAliasGuid,
            });
        }
        else {
            const bag: GroupAttendanceDetailAddPersonRequestBag = {
                attendanceOccurrenceGuid: occurrenceGuid,
                personAliasGuid,
            };

            const result = await invokeBlockAction<GroupAttendanceDetailAddPersonResponseBag>("AddPerson", { bag });

            if (result?.data?.attendance) {
                // Add the attendance to the array so it can be seen in the attendances list.
                addToAttendancesArray(result?.data?.attendance);
            }
        }

        // Clear person picker.
        addPersonSelection.value = undefined;
    }

    /**
     * Event handler for the "Add Group Member" button being clicked.
     *
     * Redirects to the "Add Group Member" page.
     */
    function onAddGroupMemberClicked(): void {
        if (config.value.addGroupMemberPageUrl) {
            location.href = config.value.addGroupMemberPageUrl;
        }
    }

    /**
     * Event handler for an attendance being clicked.
     */
    async function onAttendanceChanged(attendance: GroupAttendanceDetailAttendanceBag): Promise<void> {
        await autoMarkAttendance({
            attendanceOccurrenceGuid: toGuidOrNull(attendanceOccurrenceGuid.value) ?? emptyGuid,
            personAliasId: attendance.personAliasId,
            didAttend: attendance.didAttend
        });
    }

    /**
     * Event handler for the "Attendance For" date being updated.
     */
    async function onAttendanceForDateUpdated(dateString: string | null): Promise<void> {
        const newDate = (dateString ? RockDateTime.parseISO(dateString) : null) ?? RockDateTime.now();

        // Skip if the date wasn't changed.
        if (attendanceForDate.value.date.isEqualTo(newDate.date)) {
            return;
        }

        attendanceForDate.value = newDate.date;

        await getAttendanceOccurrence({
            attendanceOccurrenceDate: attendanceForDateIsoString.value,
            locationGuid: locationGuid.value,
            scheduleGuid: scheduleGuid.value
        });
    }

    /**
     * Event handler for the Attendance Occurrence Type being changed.
     */
    async function onAttendanceOccurrenceTypeChanged(newAttendanceOccurrenceType: Guid): Promise<void> {
        newAttendanceOccurrenceType = toGuidOrNull(newAttendanceOccurrenceType) ?? emptyGuid;
        attendanceOccurrenceTypeGuid.value = newAttendanceOccurrenceType;
        await autoUpdateAttendanceOccurrenceType({
            attendanceOccurrenceGuid: toGuidOrNull(attendanceOccurrenceGuid.value) ?? emptyGuid,
            attendanceOccurrenceTypeGuid: newAttendanceOccurrenceType
        });
    }

    /**
     * Event handler for the Back button being clicked.
     */
    function onBackClicked(): void {
        if (config.value.backPageUrl) {
            window.location.href = config.value.backPageUrl;
        }
    }

    /**
     * Event handler for the "We did not meet" button being clicked.
     */
    async function onDidNotOccurChanged(newDidNotOccur: boolean): Promise<void> {
        if (config.value.isDidNotMeetDisabled) {
            // Do not allow updates.
            return;
        }

        if (didNotOccur.value === newDidNotOccur) {
            // Ignore if value didn't change.
            return;
        }

        // If there are attendances marked as DidAttend and the individual is checking "We Did Not Meet",
        // then confirm with the individual before saving.
        if (newDidNotOccur && attendances.value.some(DidAttend.filter)) {
            modalOptions.value = createModalOptions({
                saveText: "Yes",
                cancelText: "No",
                text: "Attendance has already been taken for this occurrence. Continue?",
                onCancel(): void {
                    didNotOccur.value = true;
                    nextTick(() => didNotOccur.value = false);
                },
                async onSave(): Promise<void> {
                    didNotOccur.value = newDidNotOccur;

                    // Mark all attendances as did not meet = null instead of waiting for real-time updates.
                    for (const attendance of attendances.value) {
                        if (attendance?.didAttend === true) {
                            attendance.didAttend = null;
                        }
                    }

                    await autoUpdateDidNotOccur({
                        attendanceOccurrenceGuid: attendanceOccurrenceGuid.value ?? emptyGuid,
                        didNotOccur: newDidNotOccur
                    });
                }
            });
        }
        else {
            didNotOccur.value = newDidNotOccur;
            autoUpdateDidNotOccur({
                attendanceOccurrenceGuid: attendanceOccurrenceGuid.value ?? emptyGuid,
                didNotOccur: newDidNotOccur
            }).then(() => {/* do nothing */ });
        }
    }

    /**
     * Event handler for the config being changed.
     */
    function onConfigChanged(): void {
        attendanceForDate.value = config.value.attendanceOccurrenceDate && RockDateTime.parseISO(config.value.attendanceOccurrenceDate) || RockDateTime.now();
        locationGuid.value = config.value.locationGuid;
        scheduleGuid.value = config.value.scheduleGuid;
        attendanceOccurrenceGuid.value = config.value.attendanceOccurrenceGuid;
        attendanceOccurrenceTypeGuid.value = config.value.selectedAttendanceOccurrenceTypeValue ?? undefined;
        didNotOccur.value = config.value.isDidNotMeetChecked;
        notes.value = config.value.notes ?? "";

        // Start watching real-time events whenever the config (occurrence) changes.
        startRealTime();
    }

    /**
     * Event handler for the location picker being changed.
     */
    async function onGroupLocationPickerChanged(locationPickerSelection: NullableListItemBags): Promise<void> {
        locationGuid.value = toGuidOrNull((locationPickerSelection as ListItemBag)?.value);

        // Clear the selected schedule whenever the location changes.
        scheduleGuid.value = null;

        // Reset the attendance occurrence date if we are showing the scheduled date picker.
        if (config.value.attendanceOccurrenceDateSelectionMode === GroupAttendanceDetailDateSelectionMode.ScheduledDatePicker) {
            attendanceForDate.value = RockDateTime.now();
        }

        await getAttendanceOccurrence({
            attendanceOccurrenceDate: attendanceForDateIsoString.value,
            locationGuid: locationGuid.value,
            scheduleGuid: scheduleGuid.value
        });
    }

    /**
     * Event handler for the schedule+date picker being changed.
     */
    async function onGroupLocationScheduleDatePickerChanged(scheduleDatePickerSelection: NullableListItemBags): Promise<void> {
        const selectedValue = (scheduleDatePickerSelection as ListItemBag)?.value;

        if (selectedValue) {
            const [date, guid] = selectedValue.split("|");
            attendanceForDate.value = RockDateTime.parseISO(date) ?? RockDateTime.now();
            scheduleGuid.value = guid;
        }

        await getAttendanceOccurrence({
            attendanceOccurrenceDate: attendanceForDateIsoString.value,
            locationGuid: locationGuid.value,
            scheduleGuid: scheduleGuid.value
        });
    }

    /**
     * Event handler for the schedule picker being changed.
     */
    async function onGroupLocationSchedulePickerChanged(schedulePickerSelection: NullableListItemBags): Promise<void> {
        scheduleGuid.value = (schedulePickerSelection as ListItemBag)?.value;

        await getAttendanceOccurrence({
            attendanceOccurrenceDate: attendanceForDateIsoString.value,
            locationGuid: locationGuid.value,
            scheduleGuid: scheduleGuid.value
        });
    }

    async function onModalSave(): Promise<void> {
        if (modalOptions.value) {
            const result = modalOptions.value.onSave();
            if (isPromise(result)) {
                await result;
            }
        }
    }

    /**
     * Event handler for the Notes button being clicked.
     */
    function onShowNotesClicked(): void {
        isNotesShown.value = !isNotesShown.value;
    }

    /**
     * Event handler for the Roster button being clicked.
     */
    async function onPrintAttendanceRosterClicked(): Promise<void> {
        await printAttendanceRoster();
    }

    /**
     * Event handler for attendance update being received from the server in real-time.
     */
    function onAttendanceUpdatedFromServer(message: AttendanceUpdatedMessageBag): void {
        if (message.occurrenceGuid !== attendanceOccurrenceGuid.value) {
            // Ignore if not for this occurrence.
            return;
        }

        const attendance = attendances.value.find(attendance => areEqual(attendance.personGuid, message.personGuid));

        if (attendance) {
            attendance.didAttend = message.status === AttendanceStatus.DidAttend;
        }
        else {
            const attendanceGuid = toGuidOrNull(message.attendanceGuid);

            const bag: GroupAttendanceDetailGetAttendanceRequestBag = {
                attendanceGuid: attendanceGuid ?? emptyGuid
            };

            // Attendance was added outside of this browser so add it here (it could have been added by an individual on another device).
            invokeBlockAction<GroupAttendanceDetailAttendanceBag>("GetAttendance", { bag })
                .then(result => result?.data)
                .then((attendance: GroupAttendanceDetailAttendanceBag | null) => {
                    addToAttendancesArray(attendance);
                });
        }
    }

    /**
     * Adds an attendance record to the array so it can be seen in the attendances list.
     */
    function addToAttendancesArray(attendance: GroupAttendanceDetailAttendanceBag | null): void {
        if (!attendance) {
            return;
        }

        // Check if the Attendance record already exists added before adding it.
        const existingAttendance = attendances.value.find(a => areEqual(a.personGuid, attendance.personGuid));

        if (existingAttendance) {
            // Update the existing attendance "did attend" value to whatever was passed in.
            existingAttendance.didAttend = attendance.didAttend;
            existingAttendance.itemTemplate = attendance.itemTemplate;
        }
        else {
            config.value.attendances = [...config.value.attendances ?? [], attendance];
        }
    }

    /**
     * Event handler for attendance update being received from the server in real-time.
     */
    function onAttendanceOccurrenceUpdatedFromServer(message: AttendanceOccurrenceUpdatedMessageBag): void {
        if (message.occurrenceGuid !== attendanceOccurrenceGuid.value) {
            // Ignore if not for this occurrence.
            return;
        }

        if (message.didNotOccur !== didNotOccur.value) {
            // Turn off auto-save before updating the value bound to our control.
            autoUpdateDidNotOccurSwitch.off();

            didNotOccur.value = !!message.didNotOccur;

            // Turn on auto-save after the bindings are updated.
            nextTick(() => autoUpdateDidNotOccurSwitch.on());

            if (!message.didNotOccur) {
                // Start auto-updating attendance if meeting did occur after the bindings are updated.
                nextTick(() => autoMarkAttendanceSwitch.on());
            }
        }

        if (message.attendanceOccurrenceTypeGuid !== attendanceOccurrenceTypeGuid.value) {
            // Turn off auto-save before updating the value bound to our control.
            autoUpdateAttendanceOccurrenceTypeSwitch.off();

            attendanceOccurrenceTypeGuid.value = message.attendanceOccurrenceTypeGuid ?? undefined;

            // Turn on auto-save after the bindings are updated.
            nextTick(() => autoUpdateAttendanceOccurrenceTypeSwitch.on());
        }
    }

    //#endregion

    //#region Functions

    /**
     * Subscribes to the real-time GroupAttendanceTopic and returns it.
     */
    async function getGroupAttendanceTopic(groupGuid: Guid, attendanceOccurrenceGuid: Guid): Promise<GroupAttendanceTopic> {
        const topic = await getTopic("Rock.RealTime.Topics.EntityUpdatedTopic");

        const request: {
            connectionId?: string | null | undefined;
            groupGuid: Guid;
        } = {
            connectionId: topic.connectionId,
            groupGuid: toGuidOrNull(groupGuid) ?? emptyGuid
        };

        await invokeBlockAction("SubscribeToRealTime", request);

        // Associate the AttendanceOccurrence and Group unique identifiers to the topic so we don't have to keep passing them around.
        Object.defineProperty(topic, "attendanceOccurrenceGuid", {
            value: attendanceOccurrenceGuid,
            writable: false
        });

        Object.defineProperty(topic, "groupGuid", {
            value: groupGuid,
            writable: false
        });

        return topic as GroupAttendanceTopic;
    }

    /**
     * Gets the AttendanceOccurrence based on the currently selected date, location, and schedule.
     * Note that the returned occurrence may not have been saved yet.
     */
    async function getAttendanceOccurrence(bag: GroupAttendanceDetailGetOrCreateRequestBag): Promise<void> {
        autoSaveOff();

        // Clear the error before calling get/create.
        errorMessage.value = "";

        const response = await invokeBlockAction<GroupAttendanceDetailInitializationBox>("Get", { bag });

        if (response?.data) {
            config.value = response.data;
            onConfigChanged();
        }
        else if (config) {
            config.value.errorMessage = response?.errorMessage || "An unexpected error occurred.";
        }

        // Wait until the next tick to give the UI a chance to update values from the new config.
        nextTick(() => autoSaveOn());
    }

    /**
     * Gets or creates the AttendanceOccurrence based on the currently selected date, location, and schedule.
     */
    async function getOrCreateAttendanceOccurrence(bag: GroupAttendanceDetailGetOrCreateRequestBag): Promise<void> {
        autoSaveOff();

        // Clear the error before calling get/create.
        errorMessage.value = "";

        const response = await invokeBlockAction<GroupAttendanceDetailInitializationBox>("GetOrCreate", { bag });

        if (response?.data) {
            config.value = response.data;
            onConfigChanged();
        }
        else if (config) {
            config.value.errorMessage = response?.errorMessage || "An unexpected error occurred.";
        }

        // Wait until the next tick to give the UI a chance to update values from the new config.
        nextTick(() => autoSaveOn());
    }

    /**
     * Updates the DidAttend value of a single Attendance.
     */
    async function markAttendance(bag: GroupAttendanceDetailMarkAttendanceRequestBag): Promise<void> {
        const occurenceGuid = toGuidOrNull(attendanceOccurrenceGuid.value);
        const locationGuidOrNull = toGuidOrNull(locationGuid.value);
        const scheduleGuidOrNull = toGuidOrNull(scheduleGuid.value);

        if (!occurenceGuid) {
            // Create a new occurrence if it hasn't been saved yet.
            await getOrCreateAttendanceOccurrence({
                attendanceOccurrenceDate: attendanceForDateIsoString.value,
                locationGuid: locationGuidOrNull,
                scheduleGuid: scheduleGuidOrNull,

                // Pass all attendances...
                // If a new occurrence is created,
                // then attendances with a null didAttend value
                // will be created with a false didAttend value.
                // Otherwise, if another device already created the occurrence,
                // then only attendances with a true/false didAttend value
                // will be updated, while those with null didAttend values will be ignored.
                updatedAttendances: attendances.value.map(attendance => ({
                    ...attendance,
                    attendanceOccurrenceGuid: emptyGuid,
                })),
            });
        }
        else if (attendances.value.some(a => (a.didAttend ?? null) === null)) {
            // There are new people to add to the occurrence so
            // invoke get/create to save multiple attendances.
            await getOrCreateAttendanceOccurrence({
                attendanceOccurrenceDate: attendanceForDateIsoString.value,
                locationGuid: locationGuidOrNull,
                scheduleGuid: scheduleGuidOrNull,

                // Pass the attendance that changed and any new people (didAttend is null).
                updatedAttendances: attendances.value.filter(attendance => attendance.personAliasId === bag.personAliasId || ((attendance.didAttend ?? null) === null)).map(attendance => ({
                    ...attendance,
                    attendanceOccurrenceGuid: occurenceGuid,
                }))
            });
        }
        else {
            // Mark the single attendance that has changed.
            await invokeBlockAction("MarkAttendance", { bag });
        }
    }

    /**
     * Prints the Attendance roster.
     */
    async function printAttendanceRoster(): Promise<void> {
        try {
            isPrintingRoster.value = true;
            let occurrenceGuid = toGuidOrNull(attendanceOccurrenceGuid.value);
            const locationGuidOrNull = toGuidOrNull(locationGuid.value);
            const scheduleGuidOrNull = toGuidOrNull(scheduleGuid.value);

            if (!occurrenceGuid || areEqual(occurrenceGuid, emptyGuid)) {
                // The attendance occurrence hasn't been created yet for the selected date, location, and schedule.
                // Create it before printing the roster.

                await getOrCreateAttendanceOccurrence({
                    attendanceOccurrenceDate: attendanceForDateIsoString.value,
                    locationGuid: locationGuidOrNull,
                    scheduleGuid: scheduleGuidOrNull
                });

                // Update the occurrence guid to the created/retrieved attendance occurrence.
                occurrenceGuid = toGuidOrNull(attendanceOccurrenceGuid.value);
            }

            const bag: GroupAttendanceDetailPrintRosterRequestBag = {
                attendanceOccurrenceDate: attendanceForDateIsoString.value,
                attendanceOccurrenceGuid: occurrenceGuid,
                locationGuid: locationGuidOrNull,
                scheduleGuid: scheduleGuidOrNull
            };

            var result = await invokeBlockAction<GroupAttendanceDetailPrintRosterResponseBag>("PrintRoster", { bag });

            if (result?.errorMessage) {
                printRosterWarning.value = result.errorMessage;
            }
            else if (result?.data?.redirectUrl) {
                window.location.href = result.data.redirectUrl;
            }
        }
        finally {
            isPrintingRoster.value = false;
        }
    }

    /**
     * Updates the type of the current AttendanceOccurrence.
     */
    async function updateAttendanceOccurrenceType(bag: GroupAttendanceDetailUpdateAttendanceOccurrenceTypeRequestBag): Promise<void> {
        const occurrenceGuid = toGuidOrNull(attendanceOccurrenceGuid.value);

        if (!occurrenceGuid || areEqual(occurrenceGuid, emptyGuid)) {
            // Create a new occurrence if it hasn't been saved yet.
            await getOrCreateAttendanceOccurrence({
                attendanceOccurrenceDate: attendanceForDateIsoString.value,
                locationGuid: toGuidOrNull(locationGuid.value),
                scheduleGuid: toGuidOrNull(scheduleGuid.value),

                // This will ensure the updated attendance occurrence type is set on the existing or newly created occurrence.
                updatedAttendanceOccurrenceTypeGuid: bag.attendanceOccurrenceTypeGuid,
            });
        }
        else {
            await invokeBlockAction("UpdateAttendanceOccurrenceType", { bag });
        }
    }

    /**
     * Updates the AttendanceOccurrence DidNotOccur value.
     */
    async function updateDidNotOccur(bag: GroupAttendanceDetailUpdateDidNotOccurRequestBag): Promise<void> {
        if (isSavingDidNotOccur.value) {
            // Skip if "did not occur" is already being saved.
            return;
        }

        if (bag.didNotOccur) {
            // If the occurrence did not happen, then stop auto-saving attendances before we auto-save "did occur".
            autoMarkAttendanceSwitch.off();
        }

        try {
            isSavingDidNotOccur.value = true;
            const occurrenceGuid = toGuidOrNull(attendanceOccurrenceGuid.value);

            if (!occurrenceGuid || areEqual(occurrenceGuid, emptyGuid)) {
                // Create a new occurrence if it hasn't been saved yet.
                await getOrCreateAttendanceOccurrence({
                    attendanceOccurrenceDate: attendanceForDateIsoString.value,
                    locationGuid: toGuidOrNull(locationGuid.value),
                    scheduleGuid: toGuidOrNull(scheduleGuid.value),

                    // This will ensure the updated did not occur flag is set on the existing or newly created occurrence.
                    updatedDidNotOccur: bag.didNotOccur,
                });
            }
            else {
                await invokeBlockAction<void>("UpdateDidNotOccur", { bag });
            }
        }
        finally {
            isSavingDidNotOccur.value = false;
        }

        if (!bag.didNotOccur) {
            // If the occurrence did happen, then start auto-saving attendances after "did occur" is auto-saved.
            autoMarkAttendanceSwitch.on();
        }
    }

    /**
     * Saves the AttendanceOccurrence notes.
     */
    async function updateNotes(): Promise<void> {
        if (!attendanceOccurrenceGuid.value) {
            // Create a new occurrence if it hasn't been saved yet.
            await getOrCreateAttendanceOccurrence({
                attendanceOccurrenceDate: attendanceForDateIsoString.value,
                locationGuid: toGuidOrNull(locationGuid.value),
                scheduleGuid: toGuidOrNull(scheduleGuid.value),

                // This will ensure the updated notes are set on the existing or newly created occurrence.
                updatedNotes: notes.value,
            });
        }
        else {
            const bag: GroupAttendanceDetailUpdateNotesRequestBag = {
                attendanceOccurrenceGuid: toGuidOrNull(attendanceOccurrenceGuid.value) ?? emptyGuid,
                notes: notes.value
            };

            await invokeBlockAction<void>("UpdateNotes", { bag });
        }
    }

    /**
     * Subscribes to the topic using the current Group and AttendanceOccurrence unique identifiers.
     */
    async function startRealTime(): Promise<void> {
        const groupGuid = config.value.groupGuid;
        const occurrenceGuid = attendanceOccurrenceGuid.value;

        if (topic.value && areEqual(topic.value.groupGuid, groupGuid) && areEqual(topic.value.attendanceOccurrenceGuid, occurrenceGuid)) {
            // Skip if already subscribed.
            return;
        }

        if (!config.value.groupGuid) {
            throw "Unable to start real-time";
        }

        if (!attendanceOccurrenceGuid.value) {
            // If the occurrence is new, do not start real-time yet.
            return;
        }

        const groupAttendanceTopic = await getGroupAttendanceTopic(config.value.groupGuid, attendanceOccurrenceGuid.value);

        groupAttendanceTopic.onDisconnected(async () => {
            await startRealTime();
        });

        groupAttendanceTopic.on("attendanceUpdated", onAttendanceUpdatedFromServer);
        groupAttendanceTopic.on("attendanceOccurrenceUpdated", onAttendanceOccurrenceUpdatedFromServer);

        return;
    }

    /**
     * Turns off auto-save functionality by turning off all auto-save switches.
     */
    function autoSaveOff(): void {
        autoMarkAttendanceSwitch.off();
        autoUpdateDidNotOccurSwitch.off();
        autoUpdateAttendanceOccurrenceTypeSwitch.off();
        autoUpdateNotesSwitch.off();
        isAutoSaveOn.value = false;
    }

    /**
     * Turns on auto-save functionality by turning on all auto-save switches.
     */
    function autoSaveOn(): void {
        autoMarkAttendanceSwitch.on();
        autoUpdateDidNotOccurSwitch.on();
        autoUpdateAttendanceOccurrenceTypeSwitch.on();
        autoUpdateNotesSwitch.on();
        isAutoSaveOn.value = true;
    }

    /**
     * Debounces the execution of a Promise.
     */
    function debouncePromise(func: () => Promise<void>, delayMs: number): () => Promise<void> {
        const promise = new PromiseCompletionSource();

        const internalDebounce = debounce(() => func().then(() => promise.resolve()), delayMs);

        return async () => {
            internalDebounce();
            await promise.promise;
        };
    }

    //#endregion

    // Auto-save can be disabled by disabling all auto-save switches.
    // autoMarkAttendanceSwitch.disable();
    // autoUpdateAttendanceOccurrenceTypeSwitch.disable();
    // autoUpdateDidNotOccurSwitch.disable();
    // autoUpdateNotesSwitch.disable();

    // Turn on auto-save right away.
    autoSaveOn();

    if (config.value.attendanceOccurrenceGuid) {
        startRealTime();
    }

    onConfigurationValuesChanged(useReloadBlock());

</script>
